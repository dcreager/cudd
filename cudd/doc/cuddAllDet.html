<html>
<head><title>The cudd package: all functions </title></head>
<body>


<HR>
<DL>
<dt><pre>
<A NAME="AssessPathLength"></A>
static unsigned int <I></I>
<B>AssessPathLength</B>(
  unsigned int * <b>pathLengthArray</b>, <i>array determining number of nodes belonging to the different path lengths</i>
  int  <b>threshold</b>, <i>threshold to determine maximum allowable nodes in the subset</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  unsigned int * <b>excess</b>, <i>number of nodes labeled maxpath required in the subset</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> Chooses the maximum allowable path length under each node.
  The corner cases are when the threshold is larger than the number
  of nodes in the BDD iself, in which case 'numVars + 1' is returned.
  If all nodes of a particular path length are needed, then the
  maxpath returned is the next one with excess nodes = 0;
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="BAapplyBias"></A>
static int <I></I>
<B>BAapplyBias</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>b</b>, <i></i>
  ApproxInfo * <b>info</b>, <i></i>
  DdHashTable * <b>cache</b> <i></i>
)
</pre>
<dd> Finds don't care nodes by traversing f and b in parallel.
  Returns the care status of the visited f node if successful; CARE_ERROR
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBiasedUnderApprox">cuddBiasedUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="BAmarkNodes"></A>
static int <I></I>
<B>BAmarkNodes</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be analyzed</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>threshold</b>, <i>when to stop approximating</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Marks nodes for remapping. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRemapUnderApprox">cuddRemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="BuildConjuncts"></A>
static Conjuncts * <I></I>
<B>BuildConjuncts</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  st_table * <b>distanceTable</b>, <i></i>
  st_table * <b>cacheTable</b>, <i></i>
  int  <b>approxDistance</b>, <i></i>
  int  <b>maxLocalRef</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>mintermTable</b> <i></i>
)
</pre>
<dd> Builds the conjuncts recursively, bottom up. Constants
  are returned as (f, f). The cache is checked for previously computed
  result. The decomposition points are determined by the local
  reference count of this node and the longest distance from the
  constant. At the decomposition point, the factors returned are (f,
  1). Recur on the two children. The order is determined by the
  heavier branch. Combine the factors of the two children and pick the
  one that already occurs in the gh table. Occurence in g is indicated
  by value 1, occurence in h by 2, occurence in both 3.
<p>

<dd> <b>See Also</b> <code><a href="#cuddConjunctsAux">cuddConjunctsAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="BuildSubsetBdd"></A>
static DdNode * <I></I>
<B>BuildSubsetBdd</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  st_table * <b>pathTable</b>, <i>path table with path lengths and computed results</i>
  DdNode * <b>node</b>, <i>current node</i>
  struct AssortedInfo * <b>info</b>, <i>assorted information structure</i>
  st_table * <b>subsetNodeTable</b> <i>table storing computed results</i>
)
</pre>
<dd> Builds the BDD with nodes labeled with path length
  under maxpath and as many nodes labeled maxpath as determined by the
  threshold. The procedure uses the path table to determine which nodes
  in the original bdd need to be retained. This procedure picks a
  shortest path (tie break decided by taking the child with the shortest
  distance to the constant) and recurs down the path till it reaches the
  constant. the procedure then starts building the subset upward from
  the constant. All nodes labeled by path lengths less than the given
  maxpath are used to build the subset.  However, in the case of nodes
  that have label equal to maxpath, as many are chosen as required by
  the threshold. This number is stored in the info structure in the
  field thresholdReached. This field is decremented whenever a node
  labeled maxpath is encountered and the nodes labeled maxpath are
  aggregated in a maxpath table. As soon as the thresholdReached count
  goes to 0, the shortest path from this node to the constant is found.
  The extraction of nodes with the above labeling is based on the fact
  that each node, labeled with a path length, P, has at least one child
  labeled P or less. So extracting all nodes labeled a given path length
  P ensures complete paths between the root and the constant. Extraction
  of a partial number of nodes with a given path length may result in
  incomplete paths and hence the additional number of nodes are grabbed
  to complete the path. Since the Bdd is built bottom-up, other nodes
  labeled maxpath do lie on complete paths.  The procedure may cause the
  subset to have a larger or smaller number of nodes than the specified
  threshold. The increase in the number of nodes is caused by the
  building of a subset and the reduction by recombination. However in
  most cases, the recombination overshadows the increase and the
  procedure returns a result with lower number of nodes than specified.
  The subsetNodeTable is NIL when there is no hard limit on the number
  of nodes. Further efforts towards keeping the subset closer to the
  threshold number were abandoned in favour of keeping the procedure
  simple and fast.
<p>

<dd> <b>Side Effects</b> SubsetNodeTable is changed if it is not NIL.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="BuildSubsetBdd"></A>
static DdNode * <I></I>
<B>BuildSubsetBdd</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int * <b>size</b>, <i>current size of the subset</i>
  st_table * <b>visitedTable</b>, <i>visited table storing all node data</i>
  int  <b>threshold</b>, <i></i>
  st_table * <b>storeTable</b>, <i></i>
  st_table * <b>approxTable</b> <i></i>
)
</pre>
<dd> The procedure carries out the building of the subset BDD
  starting at the root. Using the three different counts labelling each node,
  the procedure chooses the heavier branch starting from the root and keeps
  track of the number of nodes it discards at each step, thus keeping count
  of the size of the subset BDD dynamically. Once the threshold is satisfied,
  the procedure then calls ITE to build the BDD.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="CheckInTables"></A>
static Conjuncts * <I></I>
<B>CheckInTables</B>(
  DdNode * <b>node</b>, <i></i>
  DdNode * <b>g1</b>, <i></i>
  DdNode * <b>h1</b>, <i></i>
  DdNode * <b>g2</b>, <i></i>
  DdNode * <b>h2</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b>, <i></i>
  int * <b>outOfMem</b> <i></i>
)
</pre>
<dd> Check if the two pairs exist in the table. If any of
  the conjuncts do exist, store in the cache and return the
  corresponding pair.
<p>

<dd> <b>See Also</b> <code><a href="#ZeroCase">ZeroCase</a>
<a href="#BuildConjuncts">BuildConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CheckTablesCacheAndReturn"></A>
static Conjuncts * <I></I>
<B>CheckTablesCacheAndReturn</B>(
  DdNode * <b>node</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b> <i></i>
)
</pre>
<dd> Check the tables for the existence of pair and return
  one combination, cache the result. The assumption is that one of the
  conjuncts is already in the tables.
<p>

<dd> <b>Side Effects</b> g and h referenced for the cache
<p>

<dd> <b>See Also</b> <code><a href="#ZeroCase">ZeroCase</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="ConjunctsFree"></A>
static void <I></I>
<B>ConjunctsFree</B>(
  DdManager * <b>dd</b>, <i></i>
  Conjuncts * <b>factors</b> <i></i>
)
</pre>
<dd> Free factors structure
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CorrelCleanUp"></A>
static enum st_retval <I></I>
<B>CorrelCleanUp</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees memory associated with hash table. Returns
  ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="CorrelCompare"></A>
static int <I></I>
<B>CorrelCompare</B>(
  const char * <b>key1</b>, <i></i>
  const char * <b>key2</b> <i></i>
)
</pre>
<dd> Compares two hash table entries. Returns 0 if they are
  identical; 1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="CorrelHash"></A>
static int <I></I>
<B>CorrelHash</B>(
  char * <b>key</b>, <i></i>
  int  <b>modulus</b> <i></i>
)
</pre>
<dd> Hashes a hash table entry. It is patterned after
  st_strhash. Returns a value between 0 and modulus.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="CountMinterms"></A>
static double <I></I>
<B>CountMinterms</B>(
  DdNode * <b>node</b>, <i></i>
  double  <b>max</b>, <i></i>
  st_table * <b>mintermTable</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Count the number of minterms of each node ina a BDD and
  store it in a hash table.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CreateBotDist"></A>
static NodeStat * <I></I>
<B>CreateBotDist</B>(
  DdNode * <b>node</b>, <i></i>
  st_table * <b>distanceTable</b> <i></i>
)
</pre>
<dd> Get longest distance of node from constant. Returns the
  distance of the root from the constant if successful; CUDD_OUT_OF_MEM
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="CreateBotDist"></A>
static int <I></I>
<B>CreateBotDist</B>(
  DdNode * <b>node</b>, <i>current node</i>
  st_table * <b>pathTable</b>, <i>path table with path lengths</i>
  unsigned int * <b>pathLengthArray</b>, <i>array that stores number of nodes belonging to a particular path length.</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> Labels each node with the shortest distance from the constant.
  This is done in a DFS search of the BDD. Each node has an odd
  and even parity distance from the sink (since there exists paths to both
  zero and one) which is less than MAXSHORTINT. At each node these distances
  are updated using the minimum distance of its children from the constant.
  SInce now both the length from the root and child is known, the minimum path
  length(length of the shortest path between the root and the constant that
  this node lies on) of this node can be calculated and used to update the
  pathLengthArray
<p>

<dd> <b>Side Effects</b> Updates Path Table and path length array
<p>

<dd> <b>See Also</b> <code><a href="#CreatePathTable">CreatePathTable</a>
<a href="#CreateTopDist">CreateTopDist</a>
<a href="#AssessPathLength">AssessPathLength</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="CreatePathTable"></A>
static st_table * <I></I>
<B>CreatePathTable</B>(
  DdNode * <b>node</b>, <i>root of function</i>
  unsigned int * <b>pathLengthArray</b>, <i>array of path lengths to store nodes labeled with the various path lengths</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> The outer procedure to label each node with its shortest
  distance from the root and constant. Calls CreateTopDist and CreateBotDist.
  The basis for computing the distance between root and constant is that
  the distance may be the sum of even distances from the node to the root
  and constant or the sum of odd distances from the node to the root and
  constant.  Both CreateTopDist and CreateBotDist create the odd and
  even parity distances from the root and constant respectively.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#CreateTopDist">CreateTopDist</a>
<a href="#CreateBotDist">CreateBotDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="CreateTopDist"></A>
static void <I></I>
<B>CreateTopDist</B>(
  st_table * <b>pathTable</b>, <i>hast table to store path lengths</i>
  int  <b>parentPage</b>, <i>the pointer to the page on which the first parent in the queue is to be found.</i>
  int  <b>parentQueueIndex</b>, <i>pointer to the first parent on the page</i>
  int  <b>topLen</b>, <i>current distance from the root</i>
  DdNode ** <b>childPage</b>, <i>pointer to the page on which the first child is to be added.</i>
  int  <b>childQueueIndex</b>, <i>pointer to the first child</i>
  int  <b>numParents</b>, <i>number of parents to process in this recursive call</i>
  FILE * <b>fp</b> <i>where to write messages</i>
)
</pre>
<dd> Labels each node with its shortest distance from the root.
  This is done in a BFS search of the BDD. The nodes are processed
  in a queue implemented as pages(array) to reduce memory fragmentation.
  An entry is created for each node visited. The distance from the root
  to the node with the corresponding  parity is updated. The procedure
  is called recursively each recusion level handling nodes at a given
  level from the root.
<p>

<dd> <b>Side Effects</b> Creates entries in the pathTable
<p>

<dd> <b>See Also</b> <code><a href="#CreatePathTable">CreatePathTable</a>
<a href="#CreateBotDist">CreateBotDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AddHook"></A>
int <I></I>
<B>Cudd_AddHook</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_HFP  <b>f</b>, <i></i>
  Cudd_HookType  <b>where</b> <i></i>
)
</pre>
<dd> Adds a function to a hook. A hook is a list of
  application-provided functions called on certain occasions by the
  package. Returns 1 if the function is successfully added; 2 if the
  function was already in the list; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RemoveHook">Cudd_RemoveHook</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaAdd"></A>
DdApaDigit <I></I>
<B>Cudd_ApaAdd</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>a</b>, <i></i>
  DdApaNumber  <b>b</b>, <i></i>
  DdApaNumber  <b>sum</b> <i></i>
)
</pre>
<dd> Adds two arbitrary precision integers.  Returns the
  carry out of the most significant digit.
<p>

<dd> <b>Side Effects</b> The result of the sum is stored in parameter <code>sum</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaCompareRatios"></A>
int <I></I>
<B>Cudd_ApaCompareRatios</B>(
  int  <b>digitsFirst</b>, <i></i>
  DdApaNumber  <b>firstNum</b>, <i></i>
  unsigned int  <b>firstDen</b>, <i></i>
  int  <b>digitsSecond</b>, <i></i>
  DdApaNumber  <b>secondNum</b>, <i></i>
  unsigned int  <b>secondDen</b> <i></i>
)
</pre>
<dd> Compares the ratios of two arbitrary precision integers
  to two unsigned ints. Returns 1 if the first number is larger; 0 if
  they are equal; -1 if the second number is larger.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaCompare"></A>
int <I></I>
<B>Cudd_ApaCompare</B>(
  int  <b>digitsFirst</b>, <i></i>
  DdApaNumber  <b>first</b>, <i></i>
  int  <b>digitsSecond</b>, <i></i>
  DdApaNumber  <b>second</b> <i></i>
)
</pre>
<dd> Compares two arbitrary precision integers. Returns 1 if
  the first number is larger; 0 if they are equal; -1 if the second
  number is larger.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaCopy"></A>
void <I></I>
<B>Cudd_ApaCopy</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>source</b>, <i></i>
  DdApaNumber  <b>dest</b> <i></i>
)
</pre>
<dd> Makes a copy of an arbitrary precision integer.
<p>

<dd> <b>Side Effects</b> Changes parameter <code>dest</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaCountMinterm"></A>
DdApaNumber <I></I>
<B>Cudd_ApaCountMinterm</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  int * <b>digits</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a DD. The function is
  assumed to depend on nvars variables. The minterm count is
  represented as an arbitrary precision unsigned integer, to allow for
  any number of variables CUDD supports.  Returns a pointer to the
  array representing the number of minterms of the function rooted at
  node if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The number of digits of the result is returned in
  parameter <code>digits</code>.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CountMinterm">Cudd_CountMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaIntDivision"></A>
unsigned int <I></I>
<B>Cudd_ApaIntDivision</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>dividend</b>, <i></i>
  unsigned int  <b>divisor</b>, <i></i>
  DdApaNumber  <b>quotient</b> <i></i>
)
</pre>
<dd> Divides an arbitrary precision integer by a 32-bit
  unsigned integer. Returns the remainder of the division. This
  procedure relies on the assumption that the number of bits of a
  DdApaDigit plus the number of bits of an unsigned int is less the
  number of bits of the mantissa of a double. This guarantees that the
  product of a DdApaDigit and an unsigned int can be represented
  without loss of precision by a double. On machines where this
  assumption is not satisfied, this procedure will malfunction.
<p>

<dd> <b>Side Effects</b> The quotient is returned in parameter <code>quotient</code>.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ApaShortDivision">Cudd_ApaShortDivision</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaNumberOfDigits"></A>
int <I></I>
<B>Cudd_ApaNumberOfDigits</B>(
  int  <b>binaryDigits</b> <i></i>
)
</pre>
<dd> Finds the number of digits for an arbitrary precision
  integer given the maximum number of binary digits.  The number of
  binary digits should be positive. Returns the number of digits if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPowerOfTwo"></A>
void <I></I>
<B>Cudd_ApaPowerOfTwo</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b>, <i></i>
  int  <b>power</b> <i></i>
)
</pre>
<dd> Sets an arbitrary precision integer to a power of
  two. If the power of two is too large to be represented, the number
  is set to 0.
<p>

<dd> <b>Side Effects</b> The result is returned in parameter <code>number</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPrintDecimal"></A>
int <I></I>
<B>Cudd_ApaPrintDecimal</B>(
  FILE * <b>fp</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b> <i></i>
)
</pre>
<dd> Prints an arbitrary precision integer in decimal format.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ApaPrintHex">Cudd_ApaPrintHex</a>
<a href="#Cudd_ApaPrintExponential">Cudd_ApaPrintExponential</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPrintDensity"></A>
int <I></I>
<B>Cudd_ApaPrintDensity</B>(
  FILE * <b>fp</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b> <i></i>
)
</pre>
<dd> Prints the density of a BDD or ADD using
  arbitrary precision arithmetic. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPrintExponential"></A>
int <I></I>
<B>Cudd_ApaPrintExponential</B>(
  FILE * <b>fp</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b>, <i></i>
  int  <b>precision</b> <i></i>
)
</pre>
<dd> Prints an arbitrary precision integer in exponential format.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ApaPrintHex">Cudd_ApaPrintHex</a>
<a href="#Cudd_ApaPrintDecimal">Cudd_ApaPrintDecimal</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPrintHex"></A>
int <I></I>
<B>Cudd_ApaPrintHex</B>(
  FILE * <b>fp</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b> <i></i>
)
</pre>
<dd> Prints an arbitrary precision integer in hexadecimal format.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ApaPrintDecimal">Cudd_ApaPrintDecimal</a>
<a href="#Cudd_ApaPrintExponential">Cudd_ApaPrintExponential</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPrintMintermExp"></A>
int <I></I>
<B>Cudd_ApaPrintMintermExp</B>(
  FILE * <b>fp</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  int  <b>precision</b> <i></i>
)
</pre>
<dd> Prints the number of minterms of a BDD or ADD in
  exponential format using arbitrary precision arithmetic. Parameter
  precision controls the number of signficant digits printed. Returns
  1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ApaPrintMinterm">Cudd_ApaPrintMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaPrintMinterm"></A>
int <I></I>
<B>Cudd_ApaPrintMinterm</B>(
  FILE * <b>fp</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b> <i></i>
)
</pre>
<dd> Prints the number of minterms of a BDD or ADD using
  arbitrary precision arithmetic. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ApaPrintMintermExp">Cudd_ApaPrintMintermExp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaSetToLiteral"></A>
void <I></I>
<B>Cudd_ApaSetToLiteral</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>number</b>, <i></i>
  DdApaDigit  <b>literal</b> <i></i>
)
</pre>
<dd> Sets an arbitrary precision integer to a one-digit literal.
<p>

<dd> <b>Side Effects</b> The result is returned in parameter <code>number</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaShiftRight"></A>
void <I></I>
<B>Cudd_ApaShiftRight</B>(
  int  <b>digits</b>, <i></i>
  DdApaDigit  <b>in</b>, <i></i>
  DdApaNumber  <b>a</b>, <i></i>
  DdApaNumber  <b>b</b> <i></i>
)
</pre>
<dd> Shifts right an arbitrary precision integer by one
  binary place. The most significant binary digit of the result is
  taken from parameter <code>in</code>.
<p>

<dd> <b>Side Effects</b> The result is returned in parameter <code>b</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaShortDivision"></A>
DdApaDigit <I></I>
<B>Cudd_ApaShortDivision</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>dividend</b>, <i></i>
  DdApaDigit  <b>divisor</b>, <i></i>
  DdApaNumber  <b>quotient</b> <i></i>
)
</pre>
<dd> Divides an arbitrary precision integer by a digit.
<p>

<dd> <b>Side Effects</b> The quotient is returned in parameter <code>quotient</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ApaSubtract"></A>
DdApaDigit <I></I>
<B>Cudd_ApaSubtract</B>(
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>a</b>, <i></i>
  DdApaNumber  <b>b</b>, <i></i>
  DdApaNumber  <b>diff</b> <i></i>
)
</pre>
<dd> Subtracts two arbitrary precision integers.  Returns the
  borrow out of the most significant digit.
<p>

<dd> <b>Side Effects</b> The result of the subtraction is stored in parameter
  <code>diff</code>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AutodynDisableZdd"></A>
void <I></I>
<B>Cudd_AutodynDisableZdd</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables automatic dynamic reordering of ZDDs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AutodynEnableZdd">Cudd_AutodynEnableZdd</a>
<a href="#Cudd_ReorderingStatusZdd">Cudd_ReorderingStatusZdd</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AutodynDisable"></A>
void <I></I>
<B>Cudd_AutodynDisable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables automatic dynamic reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AutodynEnable">Cudd_AutodynEnable</a>
<a href="#Cudd_ReorderingStatus">Cudd_ReorderingStatus</a>
<a href="#Cudd_AutodynDisableZdd">Cudd_AutodynDisableZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AutodynEnableZdd"></A>
void <I></I>
<B>Cudd_AutodynEnableZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Enables automatic dynamic reordering of ZDDs. Parameter
  method is used to determine the method used for reordering ZDDs. If
  CUDD_REORDER_SAME is passed, the method is unchanged.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AutodynDisableZdd">Cudd_AutodynDisableZdd</a>
<a href="#Cudd_ReorderingStatusZdd">Cudd_ReorderingStatusZdd</a>
<a href="#Cudd_AutodynEnable">Cudd_AutodynEnable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AutodynEnable"></A>
void <I></I>
<B>Cudd_AutodynEnable</B>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Enables automatic dynamic reordering of BDDs and
  ADDs. Parameter method is used to determine the method used for
  reordering. If CUDD_REORDER_SAME is passed, the method is
  unchanged.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
<a href="#Cudd_ReorderingStatus">Cudd_ReorderingStatus</a>
<a href="#Cudd_AutodynEnableZdd">Cudd_AutodynEnableZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_AverageDistance"></A>
double <I></I>
<B>Cudd_AverageDistance</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Computes the average distance between adjacent nodes in
  the manager. Adjacent nodes are node pairs such that the second node
  is the then child, else child, or next node in the collision list.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_BddToAdd"></A>
DdNode * <I></I>
<B>Cudd_BddToAdd</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b> <i></i>
)
</pre>
<dd> Converts a BDD to a 0-1 ADD. Returns a pointer to the
  resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
<a href="#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_BddToCubeArray"></A>
int <I></I>
<B>Cudd_BddToCubeArray</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  int * <b>array</b> <i></i>
)
</pre>
<dd> Builds a positional array from the BDD of a cube.
  Array must have one entry for each BDD variable.  The positional
  array has 1 in i-th position if the variable of index i appears in
  true form in the cube; it has 0 in i-th position if the variable of
  index i appears in complemented form in the cube; finally, it has 2
  in i-th position if the variable of index i does not appear in the
  cube.  Returns 1 if successful (the BDD is indeed a cube); 0
  otherwise.
<p>

<dd> <b>Side Effects</b> The result is in the array passed by reference.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CubeArrayToBdd">Cudd_CubeArrayToBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_BiasedOverApprox"></A>
DdNode * <I></I>
<B>Cudd_BiasedOverApprox</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is
  identical to the underapproximation procedure except for the fact that it
  works on the complement of the given function. Extracting the subset
  of the complement function is equivalent to extracting the superset
  of the function.
  Returns a pointer to the BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory. The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation.  The optimal number
  should be as close as possible to the size of the support of f.
  However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023.  If numVars is
  larger than 1023, it will overflow. If a 0 parameter is passed then
  the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="#Cudd_RemapOverApprox">Cudd_RemapOverApprox</a>
<a href="#Cudd_BiasedUnderApprox">Cudd_BiasedUnderApprox</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="Cudd_BiasedUnderApprox"></A>
DdNode * <I></I>
<B>Cudd_BiasedUnderApprox</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure uses
  a biased remapping technique and density as the cost function. The bias
  is a function. This procedure tries to approximate where the bias is 0
  and preserve the given function where the bias is 1.
  Returns a pointer to the BDD of the subset if
  successful. NULL if the procedure runs out of memory. The parameter
  numVars is the maximum number of variables to be used in minterm
  calculation.  The optimal number should be as close as possible to
  the size of the support of f.  However, it is safe to pass the value
  returned by Cudd_ReadSize for numVars when the number of variables
  is under 1023.  If numVars is larger than 1023, it will cause
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="#Cudd_UnderApprox">Cudd_UnderApprox</a>
<a href="#Cudd_RemapUnderApprox">Cudd_RemapUnderApprox</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CProjection"></A>
DdNode * <I></I>
<B>Cudd_CProjection</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>R</b>, <i></i>
  DdNode * <b>Y</b> <i></i>
)
</pre>
<dd> Computes the compatible projection of relation R with
  respect to cube Y. Returns a pointer to the c-projection if
  successful; NULL otherwise. For a comparison between Cudd_CProjection
  and Cudd_PrioritySelect, see the documentation of the latter.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CheckKeys"></A>
int <I></I>
<B>Cudd_CheckKeys</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Checks for the following conditions:
  <ul>
  <li>Wrong sizes of subtables.
  <li>Wrong number of keys found in unique subtable.
  <li>Wrong number of dead found in unique subtable.
  <li>Wrong number of keys found in the constant table
  <li>Wrong number of dead found in the constant table
  <li>Wrong number of total slots found
  <li>Wrong number of maximum keys found
  <li>Wrong number of total dead found
  </ul>
  Reports the average length of non-empty lists. Returns the number of
  subtables for which the number of keys is wrong.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DebugCheck">Cudd_DebugCheck</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CheckZeroRef"></A>
int <I></I>
<B>Cudd_CheckZeroRef</B>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Checks the unique table for nodes with non-zero
  reference counts. It is normally called before Cudd_Quit to make sure
  that there are no memory leaks due to missing Cudd_RecursiveDeref's.
  Takes into account that reference counts may saturate and that the
  basic constants and the projection functions are referenced by the
  manager.  Returns the number of nodes with non-zero reference count.
  (Except for the cases mentioned above.)
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ClassifySupport"></A>
int <I></I>
<B>Cudd_ClassifySupport</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first DD</i>
  DdNode * <b>g</b>, <i>second DD</i>
  DdNode ** <b>common</b>, <i>cube of shared variables</i>
  DdNode ** <b>onlyF</b>, <i>cube of variables only in f</i>
  DdNode ** <b>onlyG</b> <i>cube of variables only in g</i>
)
</pre>
<dd> Classifies the variables in the support of two DDs
  <code>f</code> and <code>g</code>, depending on whther they appear
  in both DDs, only in <code>f</code>, or only in <code>g</code>.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The cubes of the three classes of variables are
  returned as side effects.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Support">Cudd_Support</a>
<a href="#Cudd_VectorSupport">Cudd_VectorSupport</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ClearErrorCode"></A>
void <I></I>
<B>Cudd_ClearErrorCode</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Clear the error code of a manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadErrorCode">Cudd_ReadErrorCode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CofMinterm"></A>
double * <I></I>
<B>Cudd_CofMinterm</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes the fraction of minterms in the on-set of all
  the positive cofactors of DD. Returns the pointer to an array of
  doubles if successful; NULL otherwise. The array has as many
  positions as there are BDD variables in the manager plus one. The
  last position of the array contains the fraction of the minterms in
  the ON-set of the function represented by the BDD or ADD. The other
  positions of the array hold the variable signatures.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSign.c"TARGET="ABSTRACT"><CODE>cuddSign.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Cofactor"></A>
DdNode * <I></I>
<B>Cudd_Cofactor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the cofactor of f with respect to g; g must be
  the BDD or the ADD of a cube. Returns a pointer to the cofactor if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCof.c"TARGET="ABSTRACT"><CODE>cuddCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CountLeaves"></A>
int <I></I>
<B>Cudd_CountLeaves</B>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of leaves in a DD. Returns the number
  of leaves in the DD rooted at node if successful; CUDD_OUT_OF_MEM
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CountMinterm"></A>
double <I></I>
<B>Cudd_CountMinterm</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a DD. The function is
  assumed to depend on nvars variables. The minterm count is
  represented as a double, to allow for a larger number of variables.
  Returns the number of minterms of the function rooted at node if
  successful; (double) CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_CountPath">Cudd_CountPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CountPathsToNonZero"></A>
double <I></I>
<B>Cudd_CountPathsToNonZero</B>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of paths to a non-zero terminal of a
  DD.  The path count is
  represented as a double, to allow for a larger number of variables.
  Returns the number of paths of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CountMinterm">Cudd_CountMinterm</a>
<a href="#Cudd_CountPath">Cudd_CountPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CountPath"></A>
double <I></I>
<B>Cudd_CountPath</B>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of paths of a DD.  Paths to all
  terminal nodes are counted. The path count is represented as a
  double, to allow for a larger number of variables.  Returns the
  number of paths of the function rooted at node if successful;
  (double) CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CountMinterm">Cudd_CountMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_CubeArrayToBdd"></A>
DdNode * <I></I>
<B>Cudd_CubeArrayToBdd</B>(
  DdManager * <b>dd</b>, <i></i>
  int * <b>array</b> <i></i>
)
</pre>
<dd> Builds a cube from a positional array.  The array must
  have one integer entry for each BDD variable.  If the i-th entry is
  1, the variable of index i appears in true form in the cube; If the
  i-th entry is 0, the variable of index i appears complemented in the
  cube; otherwise the variable does not appear in the cube.  Returns a
  pointer to the BDD for the cube if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddComputeCube">Cudd_bddComputeCube</a>
<a href="#Cudd_IndicesToCube">Cudd_IndicesToCube</a>
<a href="#Cudd_BddToCubeArray">Cudd_BddToCubeArray</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DagSize"></A>
int <I></I>
<B>Cudd_DagSize</B>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Counts the number of nodes in a DD. Returns the number
  of nodes in the graph rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SharingSize">Cudd_SharingSize</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DeadAreCounted"></A>
int <I></I>
<B>Cudd_DeadAreCounted</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Tells whether dead nodes are counted towards triggering
  reordering. Returns 1 if dead nodes are counted; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_TurnOnCountDead">Cudd_TurnOnCountDead</a>
<a href="#Cudd_TurnOffCountDead">Cudd_TurnOffCountDead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DebugCheck"></A>
int <I></I>
<B>Cudd_DebugCheck</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Checks for inconsistencies in the DD heap:
  <ul>
  <li> node has illegal index
  <li> live node has dead children
  <li> node has illegal Then or Else pointers
  <li> BDD/ADD node has identical children
  <li> ZDD node has zero then child
  <li> wrong number of total nodes
  <li> wrong number of dead nodes
  <li> ref count error at node
  </ul>
  Returns 0 if no inconsistencies are found; DD_OUT_OF_MEM if there is
  not enough memory; 1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CheckKeys">Cudd_CheckKeys</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Decreasing"></A>
DdNode * <I></I>
<B>Cudd_Decreasing</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Determines whether the function represented by BDD f is
  negative unate (monotonic decreasing) in variable i. Returns the
  constant one is f is unate and the (logical) constant zero if it is not.
  This function does not generate any new nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Increasing">Cudd_Increasing</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DelayedDerefBdd"></A>
void <I></I>
<B>Cudd_DelayedDerefBdd</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Enqueues node n for later dereferencing. If the queue
  is full decreases the reference count of the oldest node N to make
  room for n. If N dies, recursively decreases the reference counts of
  its children.  It is used to dispose of a BDD that is currently not
  needed, but may be useful again in the near future. The dereferencing
  proper is done as in Cudd_IterDerefBdd.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="#Cudd_IterDerefBdd">Cudd_IterDerefBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Density"></A>
double <I></I>
<B>Cudd_Density</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function whose density is sought</i>
  int  <b>nvars</b> <i>size of the support of f</i>
)
</pre>
<dd> Computes the density of a BDD or ADD. The density is
  the ratio of the number of minterms to the number of nodes. If 0 is
  passed as number of variables, the number of variables existing in
  the manager is used. Returns the density if successful; (double)
  CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CountMinterm">Cudd_CountMinterm</a>
<a href="#Cudd_DagSize">Cudd_DagSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Deref"></A>
void <I></I>
<B>Cudd_Deref</B>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node. It is primarily
  used in recursive procedures to decrease the ref count of a result
  node before returning it. This accomplishes the goal of removing the
  protection applied by a previous Cudd_Ref.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="#Cudd_RecursiveDerefZdd">Cudd_RecursiveDerefZdd</a>
<a href="#Cudd_Ref">Cudd_Ref</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DisableGarbageCollection"></A>
void <I></I>
<B>Cudd_DisableGarbageCollection</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Disables garbage collection. Garbage collection is
  initially enabled. This function may be called to disable it.
  However, garbage collection will still occur when a new node must be
  created and no memory is left, or when garbage collection is required
  for correctness. (E.g., before reordering.)
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_EnableGarbageCollection">Cudd_EnableGarbageCollection</a>
<a href="#Cudd_GarbageCollectionEnabled">Cudd_GarbageCollectionEnabled</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DisableReorderingReporting"></A>
int <I></I>
<B>Cudd_DisableReorderingReporting</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Disables reporting of reordering stats.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Removes functions from the pre-reordering and post-reordering
  hooks.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_EnableReorderingReporting">Cudd_EnableReorderingReporting</a>
<a href="#Cudd_ReorderingReporting">Cudd_ReorderingReporting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Disequality"></A>
DdNode * <I></I>
<B>Cudd_Disequality</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  int  <b>c</b>, <i>right-hand side constant</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates a BDD for the function x -y != c.
  Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and
  y[0] y[1] ...  y[N-1], with 0 the most significant bit.
  The BDD is built bottom-up.
  It has a linear number of nodes if the variables are ordered as follows:
  x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Xgty">Cudd_Xgty</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DumpBlifBody"></A>
int <I></I>
<B>Cudd_DumpBlifBody</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b>, <i>pointer to the dump file</i>
  int  <b>mv</b> <i>0: blif, 1: blif-MV</i>
)
</pre>
<dd> Writes a blif body representing the argument BDDs as a
  network of multiplexers.  No header (.model, .inputs, and .outputs) and
  footer (.end) are produced by this function.  One multiplexer is written
  for each BDD node. It returns 1 in case of success; 0 otherwise (e.g.,
  out-of-memory, file system full, or an ADD with constants different
  from 0 and 1).  Cudd_DumpBlifBody does not close the file: This is the
  caller responsibility. Cudd_DumpBlifBody uses a minimal unique subset of
  the hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames. This function prints out only
  .names part.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DumpBlif"></A>
int <I></I>
<B>Cudd_DumpBlif</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  char * <b>mname</b>, <i>model name (or NULL)</i>
  FILE * <b>fp</b>, <i>pointer to the dump file</i>
  int  <b>mv</b> <i>0: blif, 1: blif-MV</i>
)
</pre>
<dd> Writes a blif file representing the argument BDDs as a
  network of multiplexers. One multiplexer is written for each BDD
  node. It returns 1 in case of success; 0 otherwise (e.g.,
  out-of-memory, file system full, or an ADD with constants different
  from 0 and 1).  Cudd_DumpBlif does not close the file: This is the
  caller responsibility. Cudd_DumpBlif uses a minimal unique subset of
  the hexadecimal address of a node as name for it.  If the argument
  inames is non-null, it is assumed to hold the pointers to the names
  of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpBlifBody">Cudd_DumpBlifBody</a>
<a href="#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DumpDDcal"></A>
int <I></I>
<B>Cudd_DumpDDcal</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a DDcal file representing the argument BDDs.
  It returns 1 in case of success; 0 otherwise (e.g., out-of-memory or
  file system full).  Cudd_DumpDDcal does not close the file: This
  is the caller responsibility. Cudd_DumpDDcal uses a minimal unique
  subset of the hexadecimal address of a node as name for it.  If the
  argument inames is non-null, it is assumed to hold the pointers to
  the names of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DumpDaVinci"></A>
int <I></I>
<B>Cudd_DumpDaVinci</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a daVinci file representing the argument BDDs.
  It returns 1 in case of success; 0 otherwise (e.g., out-of-memory or
  file system full).  Cudd_DumpDaVinci does not close the file: This
  is the caller responsibility. Cudd_DumpDaVinci uses a minimal unique
  subset of the hexadecimal address of a node as name for it.  If the
  argument inames is non-null, it is assumed to hold the pointers to
  the names of the inputs. Similarly for onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DumpDot"></A>
int <I></I>
<B>Cudd_DumpDot</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a file representing the argument DDs in a format
  suitable for the graph drawing program dot.
  It returns 1 in case of success; 0 otherwise (e.g., out-of-memory,
  file system full).
  Cudd_DumpDot does not close the file: This is the caller
  responsibility. Cudd_DumpDot uses a minimal unique subset of the
  hexadecimal address of a node as name for it.
  If the argument inames is non-null, it is assumed to hold the pointers
  to the names of the inputs. Similarly for onames.
  Cudd_DumpDot uses the following convention to draw arcs:
    <ul>
    <li> solid line: THEN arcs;
    <li> dotted line: complement arcs;
    <li> dashed line: regular ELSE arcs.
    </ul>
  The dot options are chosen so that the drawing fits on a letter-size
  sheet.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
<a href="#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="Cudd_DumpFactoredForm"></A>
int <I></I>
<B>Cudd_DumpFactoredForm</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes factored forms representing the argument BDDs.
  The format of the factored form is the one used in the genlib files
  for technology mapping in sis.  It returns 1 in case of success; 0
  otherwise (e.g., file system full).  Cudd_DumpFactoredForm does not
  close the file: This is the caller responsibility. Caution must be
  exercised because a factored form may be exponentially larger than
  the argument BDD.  If the argument inames is non-null, it is assumed
  to hold the pointers to the names of the inputs. Similarly for
  onames.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_DumpBlif">Cudd_DumpBlif</a>
<a href="#Cudd_DumpDaVinci">Cudd_DumpDaVinci</a>
<a href="#Cudd_DumpDDcal">Cudd_DumpDDcal</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Dxygtdxz"></A>
DdNode * <I></I>
<B>Cudd_Dxygtdxz</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x, y, and z variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b>, <i>array of y variables</i>
  DdNode ** <b>z</b> <i>array of z variables</i>
)
</pre>
<dd> This function generates a BDD for the function d(x,y)
  &gt; d(x,z);
  x, y, and z are N-bit numbers, x[0] x[1] ... x[N-1],
  y[0] y[1] ...  y[N-1], and z[0] z[1] ...  z[N-1],
  with 0 the most significant bit.
  The distance d(x,y) is defined as:
	sum_{i=0}^{N-1}(|x_i - y_i| cdot 2^{N-i-1}).
  The BDD is built bottom-up.
  It has 7*N-3 internal nodes, if the variables are ordered as follows:
  x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
<a href="#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
<a href="#Cudd_Xgty">Cudd_Xgty</a>
<a href="#Cudd_bddAdjPermuteX">Cudd_bddAdjPermuteX</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Dxygtdyz"></A>
DdNode * <I></I>
<B>Cudd_Dxygtdyz</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x, y, and z variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b>, <i>array of y variables</i>
  DdNode ** <b>z</b> <i>array of z variables</i>
)
</pre>
<dd> This function generates a BDD for the function d(x,y)
  &gt; d(y,z);
  x, y, and z are N-bit numbers, x[0] x[1] ... x[N-1],
  y[0] y[1] ...  y[N-1], and z[0] z[1] ...  z[N-1],
  with 0 the most significant bit.
  The distance d(x,y) is defined as:
	sum_{i=0}^{N-1}(|x_i - y_i| cdot 2^{N-i-1}).
  The BDD is built bottom-up.
  It has 7*N-3 internal nodes, if the variables are ordered as follows:
  x[0] y[0] z[0] x[1] y[1] z[1] ... x[N-1] y[N-1] z[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
<a href="#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="#Cudd_Xgty">Cudd_Xgty</a>
<a href="#Cudd_bddAdjPermuteX">Cudd_bddAdjPermuteX</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EnableGarbageCollection"></A>
void <I></I>
<B>Cudd_EnableGarbageCollection</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Enables garbage collection. Garbage collection is
  initially enabled. Therefore it is necessary to call this function
  only if garbage collection has been explicitly disabled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DisableGarbageCollection">Cudd_DisableGarbageCollection</a>
<a href="#Cudd_GarbageCollectionEnabled">Cudd_GarbageCollectionEnabled</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EnableReorderingReporting"></A>
int <I></I>
<B>Cudd_EnableReorderingReporting</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Enables reporting of reordering stats.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Installs functions in the pre-reordering and post-reordering
  hooks.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DisableReorderingReporting">Cudd_DisableReorderingReporting</a>
<a href="#Cudd_ReorderingReporting">Cudd_ReorderingReporting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EpdCountMinterm"></A>
int <I></I>
<B>Cudd_EpdCountMinterm</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  EpDouble * <b>epd</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a DD with extended precision.
  The function is assumed to depend on nvars variables. The minterm count is
  represented as an EpDouble, to allow any number of variables.
  Returns 0 if successful; CUDD_OUT_OF_MEM otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_CountPath">Cudd_CountPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EqualSupNorm"></A>
int <I></I>
<B>Cudd_EqualSupNorm</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first ADD</i>
  DdNode * <b>g</b>, <i>second ADD</i>
  CUDD_VALUE_TYPE  <b>tolerance</b>, <i>maximum allowed difference</i>
  int  <b>pr</b> <i>verbosity level</i>
)
</pre>
<dd> Compares two ADDs for equality within tolerance. Two
  ADDs are reported to be equal if the maximum difference between them
  (the sup norm of their difference) is less than or equal to the
  tolerance parameter. Returns 1 if the two ADDs are equal (within
  tolerance); 0 otherwise. If parameter <code>pr</code> is positive
  the first failure is reported to the standard output.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EquivDC"></A>
int <I></I>
<B>Cudd_EquivDC</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>F</b>, <i></i>
  DdNode * <b>G</b>, <i></i>
  DdNode * <b>D</b> <i></i>
)
</pre>
<dd> Tells whether F and G are identical wherever D is 0.  F
  and G are either two ADDs or two BDDs.  D is either a 0-1 ADD or a
  BDD.  The function returns 1 if F and G are equivalent, and 0
  otherwise.  No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLeqUnless">Cudd_bddLeqUnless</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EstimateCofactorSimple"></A>
int <I></I>
<B>Cudd_EstimateCofactorSimple</B>(
  DdNode * <b>node</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Estimates the number of nodes in a cofactor of a DD.
  Returns an estimate of the number of nodes in the positive cofactor of
  the graph rooted at node with respect to the variable whose index is i.
  This procedure implements with minor changes the algorithm of Cabodi et al.
  (ICCAD96). It does not allocate any memory, it does not change the
  state of the manager, and it is fast. However, it has been observed to
  overestimate the size of the cofactor by as much as a factor of 2.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DagSize">Cudd_DagSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_EstimateCofactor"></A>
int <I></I>
<B>Cudd_EstimateCofactor</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function</i>
  int  <b>i</b>, <i>index of variable</i>
  int  <b>phase</b> <i>1: positive; 0: negative</i>
)
</pre>
<dd> Estimates the number of nodes in a cofactor of a DD.
  Returns an estimate of the number of nodes in a cofactor of
  the graph rooted at node with respect to the variable whose index is i.
  In case of failure, returns CUDD_OUT_OF_MEM.
  This function uses a refinement of the algorithm of Cabodi et al.
  (ICCAD96). The refinement allows the procedure to account for part
  of the recombination that may occur in the part of the cofactor above
  the cofactoring variable. This procedure does no create any new node.
  It does keep a small table of results; therefore it may run out of memory.
  If this is a concern, one should use Cudd_EstimateCofactorSimple, which
  is faster, does not allocate any memory, but is less accurate.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DagSize">Cudd_DagSize</a>
<a href="#Cudd_EstimateCofactorSimple">Cudd_EstimateCofactorSimple</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Eval"></A>
DdNode * <I></I>
<B>Cudd_Eval</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>inputs</b> <i></i>
)
</pre>
<dd> Finds the value of a DD for a given variable
  assignment. The variable assignment is passed in an array of int's,
  that should specify a zero or a one for each variable in the support
  of the function. Returns a pointer to a constant node. No new nodes
  are produced.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="#Cudd_addEvalConst">Cudd_addEvalConst</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ExpectedUsedSlots"></A>
double <I></I>
<B>Cudd_ExpectedUsedSlots</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Computes the fraction of slots in the unique table that
  should be in use. This expected value is based on the assumption
  that the hash function distributes the keys randomly; it can be
  compared with the result of Cudd_ReadUsedSlots to monitor the
  performance of the unique table hash function.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadSlots">Cudd_ReadSlots</a>
<a href="#Cudd_ReadUsedSlots">Cudd_ReadUsedSlots</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FindEssential"></A>
DdNode * <I></I>
<B>Cudd_FindEssential</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the cube of the essential variables. A positive
  literal means that the variable must be set to 1 for the function to be
  1. A negative literal means that the variable must be set to 0 for the
  function to be 1. Returns a pointer to the cube BDD if successful;
  NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIsVarEssential">Cudd_bddIsVarEssential</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FindTwoLiteralClauses"></A>
DdTlcInfo * <I></I>
<B>Cudd_FindTwoLiteralClauses</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the one- and two-literal clauses of a DD.
  Returns a pointer to the structure holding the clauses if
  successful; NULL otherwise.  For a constant DD, the empty set of clauses
  is returned.  This is obviously correct for a non-zero constant.  For the
  constant zero, it is based on the assumption that only those clauses
  containing variables in the support of the function are considered.  Since
  the support of a constant function is empty, no clauses are returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FindEssential">Cudd_FindEssential</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FirstCube"></A>
DdGen * <I></I>
<B>Cudd_FirstCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int ** <b>cube</b>, <i></i>
  CUDD_VALUE_TYPE * <b>value</b> <i></i>
)
</pre>
<dd> Defines an iterator on the onset of a decision diagram
  and finds its first cube. Returns a generator that contains the
  information necessary to continue the enumeration if successful; NULL
  otherwise.<p>
  A cube is represented as an array of literals, which are integers in
  {0, 1, 2}; 0 represents a complemented literal, 1 represents an
  uncomplemented literal, and 2 stands for don't care. The enumeration
  produces a disjoint cover of the function associated with the diagram.
  The size of the array equals the number of variables in the manager at
  the time Cudd_FirstCube is called.<p>
  For each cube, a value is also returned. This value is always 1 for a
  BDD, while it may be different from 1 for an ADD.
  For BDDs, the offset is the set of cubes whose value is the logical zero.
  For ADDs, the offset is the set of cubes whose value is the
  background value. The cubes of the offset are not enumerated.
<p>

<dd> <b>Side Effects</b> The first cube and its value are returned as side effects.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FirstNode"></A>
DdGen * <I></I>
<B>Cudd_FirstNode</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>node</b> <i></i>
)
</pre>
<dd> Defines an iterator on the nodes of a decision diagram
  and finds its first node. Returns a generator that contains the
  information necessary to continue the enumeration if successful;
  NULL otherwise.  The nodes are enumerated in a reverse topological
  order, so that a node is always preceded in the enumeration by its
  descendants.
<p>

<dd> <b>Side Effects</b> The first node is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FirstPrime"></A>
DdGen * <I></I>
<B>Cudd_FirstPrime</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b>, <i></i>
  int ** <b>cube</b> <i></i>
)
</pre>
<dd> Defines an iterator on a pair of BDDs describing a
  (possibly incompletely specified) Boolean functions and finds the
  first cube of a cover of the function.  Returns a generator
  that contains the information necessary to continue the enumeration
  if successful; NULL otherwise.<p>

  The two argument BDDs are the lower and upper bounds of an interval.
  It is a mistake to call this function with a lower bound that is not
  less than or equal to the upper bound.<p>

  A cube is represented as an array of literals, which are integers in
  {0, 1, 2}; 0 represents a complemented literal, 1 represents an
  uncomplemented literal, and 2 stands for don't care. The enumeration
  produces a prime and irredundant cover of the function associated
  with the two BDDs.  The size of the array equals the number of
  variables in the manager at the time Cudd_FirstCube is called.<p>

  This iterator can only be used on BDDs.
<p>

<dd> <b>Side Effects</b> The first cube is returned as side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachPrime">Cudd_ForeachPrime</a>
<a href="#Cudd_NextPrime">Cudd_NextPrime</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FreeTree"></A>
void <I></I>
<B>Cudd_FreeTree</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Frees the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetTree">Cudd_SetTree</a>
<a href="#Cudd_ReadTree">Cudd_ReadTree</a>
<a href="#Cudd_FreeZddTree">Cudd_FreeZddTree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_FreeZddTree"></A>
void <I></I>
<B>Cudd_FreeZddTree</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Frees the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetZddTree">Cudd_SetZddTree</a>
<a href="#Cudd_ReadZddTree">Cudd_ReadZddTree</a>
<a href="#Cudd_FreeTree">Cudd_FreeTree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_GarbageCollectionEnabled"></A>
int <I></I>
<B>Cudd_GarbageCollectionEnabled</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns 1 if garbage collection is enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_EnableGarbageCollection">Cudd_EnableGarbageCollection</a>
<a href="#Cudd_DisableGarbageCollection">Cudd_DisableGarbageCollection</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_GenFree"></A>
int <I></I>
<B>Cudd_GenFree</B>(
  DdGen * <b>gen</b> <i></i>
)
</pre>
<dd> Frees a CUDD generator. Always returns 0, so that it can
  be used in mis-like foreach constructs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Increasing"></A>
DdNode * <I></I>
<B>Cudd_Increasing</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Determines whether the function represented by BDD f is
  positive unate (monotonic increasing) in variable i. It is based on
  Cudd_Decreasing and the fact that f is monotonic increasing in i if
  and only if its complement is monotonic decreasing in i.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Decreasing">Cudd_Decreasing</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_IndicesToCube"></A>
DdNode * <I></I>
<B>Cudd_IndicesToCube</B>(
  DdManager * <b>dd</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Builds a cube of BDD variables from an array of indices.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddComputeCube">Cudd_bddComputeCube</a>
<a href="#Cudd_CubeArrayToBdd">Cudd_CubeArrayToBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Inequality"></A>
DdNode * <I></I>
<B>Cudd_Inequality</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  int  <b>c</b>, <i>right-hand side constant</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates a BDD for the function x -y &ge; c.
  Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and
  y[0] y[1] ...  y[N-1], with 0 the most significant bit.
  The BDD is built bottom-up.
  It has a linear number of nodes if the variables are ordered as follows:
  x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Xgty">Cudd_Xgty</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Init"></A>
DdManager * <I></I>
<B>Cudd_Init</B>(
  unsigned int  <b>numVars</b>, <i>initial number of BDD variables (i.e., subtables)</i>
  unsigned int  <b>numVarsZ</b>, <i>initial number of ZDD variables (i.e., subtables)</i>
  unsigned int  <b>numSlots</b>, <i>initial size of the unique tables</i>
  unsigned int  <b>cacheSize</b>, <i>initial size of the cache</i>
  unsigned long  <b>maxMemory</b> <i>target maximum memory occupation</i>
)
</pre>
<dd> Creates a new DD manager, initializes the table, the
  basic constants and the projection functions. If maxMemory is 0,
  Cudd_Init decides suitable values for the maximum size of the cache
  and for the limit for fast unique table growth based on the available
  memory. Returns a pointer to the manager if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Quit">Cudd_Quit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInit.c"TARGET="ABSTRACT"><CODE>cuddInit.c</CODE></A>

<dt><pre>
<A NAME="Cudd_IsGenEmpty"></A>
int <I></I>
<B>Cudd_IsGenEmpty</B>(
  DdGen * <b>gen</b> <i></i>
)
</pre>
<dd> Queries the status of a generator. Returns 1 if the
  generator is empty or NULL; 0 otherswise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_IsInHook"></A>
int <I></I>
<B>Cudd_IsInHook</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_HFP  <b>f</b>, <i></i>
  Cudd_HookType  <b>where</b> <i></i>
)
</pre>
<dd> Checks whether a function is in a hook. A hook is a list of
  application-provided functions called on certain occasions by the
  package. Returns 1 if the function is found; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AddHook">Cudd_AddHook</a>
<a href="#Cudd_RemoveHook">Cudd_RemoveHook</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_IsNonConstant"></A>
int <I></I>
<B>Cudd_IsNonConstant</B>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns 1 if a DD node is not constant. This function is
  useful to test the results of Cudd_bddIteConstant, Cudd_addIteConstant,
  Cudd_addEvalConst. These results may be a special value signifying
  non-constant. In the other cases the macro Cudd_IsConstant can be used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_IsConstant">Cudd_IsConstant</a>
<a href="#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
<a href="#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="#Cudd_addEvalConst">Cudd_addEvalConst</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_IterDerefBdd"></A>
void <I></I>
<B>Cudd_IterDerefBdd</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node n. If n dies,
  recursively decreases the reference counts of its children.  It is
  used to dispose of a BDD that is no longer needed. It is more
  efficient than Cudd_RecursiveDeref, but it cannot be used on
  ADDs. The greater efficiency comes from being able to assume that no
  constant node will ever die as a result of a call to this
  procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_LargestCube"></A>
DdNode * <I></I>
<B>Cudd_LargestCube</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>length</b> <i></i>
)
</pre>
<dd> Finds a largest cube in a DD. f is the DD we want to
  get the largest cube for. The problem is translated into the one of
  finding a shortest path in f, when both THEN and ELSE arcs are assumed to
  have unit length. This yields a largest cube in the disjoint cover
  corresponding to the DD. Therefore, it is not necessarily the largest
  implicant of f.  Returns the largest cube as a BDD.
<p>

<dd> <b>Side Effects</b> The number of literals of the cube is returned in length.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ShortestPath">Cudd_ShortestPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_MakeBddFromZddCover"></A>
DdNode	* <I></I>
<B>Cudd_MakeBddFromZddCover</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Converts a ZDD cover to a BDD graph. If successful, it
  returns a BDD node, otherwise it returns NULL.
<p>

<dd> <b>See Also</b> <code><a href="#cuddMakeBddFromZddCover">cuddMakeBddFromZddCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_MakeTreeNode"></A>
MtrNode * <I></I>
<B>Cudd_MakeTreeNode</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  unsigned int  <b>low</b>, <i>index of the first group variable</i>
  unsigned int  <b>size</b>, <i>number of variables in the group</i>
  unsigned int  <b>type</b> <i>MTR_DEFAULT or MTR_FIXED</i>
)
</pre>
<dd> Creates a new variable group. The group starts at
  variable and contains size variables. The parameter low is the index
  of the first variable. If the variable already exists, its current
  position in the order is known to the manager. If the variable does
  not exist yet, the position is assumed to be the same as the index.
  The group tree is created if it does not exist yet.
  Returns a pointer to the group if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The variable tree is changed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MakeZddTreeNode">Cudd_MakeZddTreeNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="Cudd_MakeZddTreeNode"></A>
MtrNode * <I></I>
<B>Cudd_MakeZddTreeNode</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  unsigned int  <b>low</b>, <i>index of the first group variable</i>
  unsigned int  <b>size</b>, <i>number of variables in the group</i>
  unsigned int  <b>type</b> <i>MTR_DEFAULT or MTR_FIXED</i>
)
</pre>
<dd> Creates a new ZDD variable group. The group starts at
  variable and contains size variables. The parameter low is the index
  of the first variable. If the variable already exists, its current
  position in the order is known to the manager. If the variable does
  not exist yet, the position is assumed to be the same as the index.
  The group tree is created if it does not exist yet.
  Returns a pointer to the group if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The ZDD variable tree is changed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MakeTreeNode">Cudd_MakeTreeNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="Cudd_MinHammingDist"></A>
int <I></I>
<B>Cudd_MinHammingDist</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>function to examine</i>
  int * <b>minterm</b>, <i>reference minterm</i>
  int  <b>upperBound</b> <i>distance above which an approximate answer is OK</i>
)
</pre>
<dd> Returns the minimum Hamming distance between the
  minterms of a function f and a reference minterm. The function is
  given as a BDD; the minterm is given as an array of integers, one
  for each variable in the manager.  Returns the minimum distance if
  it is less than the upper bound; the upper bound if the minimum
  distance is at least as large; CUDD_OUT_OF_MEM in case of failure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addHamming">Cudd_addHamming</a>
<a href="#Cudd_bddClosestCube">Cudd_bddClosestCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_NewApaNumber"></A>
DdApaNumber <I></I>
<B>Cudd_NewApaNumber</B>(
  int  <b>digits</b> <i></i>
)
</pre>
<dd> Allocates memory for an arbitrary precision
  integer. Returns a pointer to the allocated memory if successful;
  NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="Cudd_NextCube"></A>
int <I></I>
<B>Cudd_NextCube</B>(
  DdGen * <b>gen</b>, <i></i>
  int ** <b>cube</b>, <i></i>
  CUDD_VALUE_TYPE * <b>value</b> <i></i>
)
</pre>
<dd> Generates the next cube of a decision diagram onset,
  using generator gen. Returns 0 if the enumeration is completed; 1
  otherwise.
<p>

<dd> <b>Side Effects</b> The cube and its value are returned as side effects. The
  generator is modified.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_NextNode"></A>
int <I></I>
<B>Cudd_NextNode</B>(
  DdGen * <b>gen</b>, <i></i>
  DdNode ** <b>node</b> <i></i>
)
</pre>
<dd> Finds the node of a decision diagram, using generator
  gen. Returns 0 if the enumeration is completed; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The next node is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_NextPrime"></A>
int <I></I>
<B>Cudd_NextPrime</B>(
  DdGen * <b>gen</b>, <i></i>
  int ** <b>cube</b> <i></i>
)
</pre>
<dd> Generates the next cube of a Boolean function,
  using generator gen. Returns 0 if the enumeration is completed; 1
  otherwise.
<p>

<dd> <b>Side Effects</b> The cube and is returned as side effects. The
  generator is modified.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachPrime">Cudd_ForeachPrime</a>
<a href="#Cudd_FirstPrime">Cudd_FirstPrime</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_NodeReadIndex"></A>
unsigned int <I></I>
<B>Cudd_NodeReadIndex</B>(
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Returns the index of the node. The node pointer can be
  either regular or complemented.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadIndex">Cudd_ReadIndex</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_OutOfMem"></A>
void <I></I>
<B>Cudd_OutOfMem</B>(
  long  <b>size</b> <i>size of the allocation that failed</i>
)
</pre>
<dd> Warns that a memory allocation failed.
  This function can be used as replacement of MMout_of_memory to prevent
  the safe_mem functions of the util package from exiting when malloc
  returns NULL. One possible use is in case of discretionary allocations;
  for instance, the allocation of memory to enlarge the computed table.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_OverApprox"></A>
DdNode * <I></I>
<B>Cudd_OverApprox</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is
  identical to the underapproximation procedure except for the fact that it
  works on the complement of the given function. Extracting the subset
  of the complement function is equivalent to extracting the superset
  of the function.
  Returns a pointer to the BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory. The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation.  The optimal number
  should be as close as possible to the size of the support of f.
  However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023.  If numVars is
  larger than 1023, it will overflow. If a 0 parameter is passed then
  the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Prime"></A>
unsigned int <I></I>
<B>Cudd_Prime</B>(
  unsigned int  <b>p</b> <i></i>
)
</pre>
<dd> Returns the next prime &gt;= p.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrintDebug"></A>
int <I></I>
<B>Cudd_PrintDebug</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>pr</b> <i></i>
)
</pre>
<dd> Prints to the standard output a DD and its statistics.
  The statistics include the number of nodes, the number of leaves, and
  the number of minterms. (The number of minterms is the number of
  assignments to the variables that cause the function to be different
  from the logical zero (for BDDs) and from the background value (for
  ADDs.) The statistics are printed if pr &gt; 0. Specifically:
  <ul>
  <li> pr = 0 : prints nothing
  <li> pr = 1 : prints counts of nodes and minterms
  <li> pr = 2 : prints counts + disjoint sum of product
  <li> pr = 3 : prints counts + list of nodes
  <li> pr &gt; 3 : prints counts + disjoint sum of product + list of nodes
  </ul>
  For the purpose of counting the number of minterms, the function is
  supposed to depend on n variables. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DagSize">Cudd_DagSize</a>
<a href="#Cudd_CountLeaves">Cudd_CountLeaves</a>
<a href="#Cudd_CountMinterm">Cudd_CountMinterm</a>
<a href="#Cudd_PrintMinterm">Cudd_PrintMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrintInfo"></A>
int <I></I>
<B>Cudd_PrintInfo</B>(
  DdManager * <b>dd</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints out statistics and settings for a CUDD manager.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrintLinear"></A>
int <I></I>
<B>Cudd_PrintLinear</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prints the linear transform matrix. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrintMinterm"></A>
int <I></I>
<B>Cudd_PrintMinterm</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Prints a disjoint sum of product cover for the function
  rooted at node. Each product corresponds to a path from node to a
  leaf node different from the logical zero, and different from the
  background value. Uses the package default output file.  Returns 1
  if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
<a href="#Cudd_bddPrintCover">Cudd_bddPrintCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrintTwoLiteralClauses"></A>
int <I></I>
<B>Cudd_PrintTwoLiteralClauses</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  char ** <b>names</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints the one- and two-literal clauses. Returns 1 if
  successful; 0 otherwise.  The argument "names" can be NULL, in which case
  the variable indices are printed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FindTwoLiteralClauses">Cudd_FindTwoLiteralClauses</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrintVersion"></A>
void <I></I>
<B>Cudd_PrintVersion</B>(
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints the package version number.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_PrioritySelect"></A>
DdNode * <I></I>
<B>Cudd_PrioritySelect</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>R</b>, <i>BDD of the relation</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b>, <i>array of y variables</i>
  DdNode ** <b>z</b>, <i>array of z variables (optional: may be NULL)</i>
  DdNode * <b>Pi</b>, <i>BDD of the priority function (optional: may be NULL)</i>
  int  <b>n</b>, <i>size of x, y, and z</i>
  DD_PRFP  <b>Pifunc</b> <i>function used to build Pi if it is NULL</i>
)
</pre>
<dd> Selects pairs from a relation R(x,y) (given as a BDD)
  in such a way that a given x appears in one pair only. Uses a
  priority function to determine which y should be paired to a given x.
  Cudd_PrioritySelect returns a pointer to
  the selected function if successful; NULL otherwise.
  Three of the arguments--x, y, and z--are vectors of BDD variables.
  The first two are the variables on which R depends. The third vectore
  is a vector of auxiliary variables, used during the computation. This
  vector is optional. If a NULL value is passed instead,
  Cudd_PrioritySelect will create the working variables on the fly.
  The sizes of x and y (and z if it is not NULL) should equal n.
  The priority function Pi can be passed as a BDD, or can be built by
  Cudd_PrioritySelect. If NULL is passed instead of a DdNode *,
  parameter Pifunc is used by Cudd_PrioritySelect to build a BDD for the
  priority function. (Pifunc is a pointer to a C function.) If Pi is not
  NULL, then Pifunc is ignored. Pifunc should have the same interface as
  the standard priority functions (e.g., Cudd_Dxygtdxz).
  Cudd_PrioritySelect and Cudd_CProjection can sometimes be used
  interchangeably. Specifically, calling Cudd_PrioritySelect with
  Cudd_Xgty as Pifunc produces the same result as calling
  Cudd_CProjection with the all-zero minterm as reference minterm.
  However, depending on the application, one or the other may be
  preferable:
  <ul>
  <li> When extracting representatives from an equivalence relation,
  Cudd_CProjection has the advantage of nor requiring the auxiliary
  variables.
  <li> When computing matchings in general bipartite graphs,
  Cudd_PrioritySelect normally obtains better results because it can use
  more powerful matching schemes (e.g., Cudd_Dxygtdxz).
  </ul>
<p>

<dd> <b>Side Effects</b> If called with z == NULL, will create new variables in
  the manager.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
<a href="#Cudd_Xgty">Cudd_Xgty</a>
<a href="#Cudd_bddAdjPermuteX">Cudd_bddAdjPermuteX</a>
<a href="#Cudd_CProjection">Cudd_CProjection</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Quit"></A>
void <I></I>
<B>Cudd_Quit</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Deletes resources associated with a DD manager and
  resets the global statistical counters. (Otherwise, another manaqger
  subsequently created would inherit the stats of this one.)
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Init">Cudd_Init</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInit.c"TARGET="ABSTRACT"><CODE>cuddInit.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Random"></A>
long <I></I>
<B>Cudd_Random</B>(
   <b></b> <i></i>
)
</pre>
<dd> Portable number generator based on ran2 from "Numerical
  Recipes in C." It is a long period (> 2 * 10^18) random number generator
  of L'Ecuyer with Bays-Durham shuffle. Returns a long integer uniformly
  distributed between 0 and 2147483561 (inclusive of the endpoint values).
  The random generator can be explicitly initialized by calling
  Cudd_Srandom. If no explicit initialization is performed, then the
  seed 1 is assumed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Srandom">Cudd_Srandom</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadArcviolation"></A>
int <I></I>
<B>Cudd_ReadArcviolation</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the current value of the arcviolation
  parameter. This parameter is used in group sifting to decide how
  many arcs into <code>y</code> not coming from <code>x</code> are
  tolerable when checking for aggregation due to extended
  symmetry. The value should be between 0 and 100. A small value
  causes fewer variables to be aggregated. The default value is 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetArcviolation">Cudd_SetArcviolation</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadBackground"></A>
DdNode * <I></I>
<B>Cudd_ReadBackground</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the background constant of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadCacheHits"></A>
double <I></I>
<B>Cudd_ReadCacheHits</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of cache hits.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadCacheLookUps">Cudd_ReadCacheLookUps</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadCacheLookUps"></A>
double <I></I>
<B>Cudd_ReadCacheLookUps</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of cache look-ups.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadCacheHits">Cudd_ReadCacheHits</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadCacheSlots"></A>
unsigned int <I></I>
<B>Cudd_ReadCacheSlots</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the number of slots in the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadCacheUsedSlots">Cudd_ReadCacheUsedSlots</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadCacheUsedSlots"></A>
double <I></I>
<B>Cudd_ReadCacheUsedSlots</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the fraction of used slots in the cache. The unused
  slots are those in which no valid data is stored. Garbage collection,
  variable reordering, and cache resizing may cause used slots to become
  unused.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadCacheSlots">Cudd_ReadCacheSlots</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadDead"></A>
unsigned int <I></I>
<B>Cudd_ReadDead</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of dead nodes in the unique table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadKeys">Cudd_ReadKeys</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadEpsilon"></A>
CUDD_VALUE_TYPE <I></I>
<B>Cudd_ReadEpsilon</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the epsilon parameter of the manager. The epsilon
  parameter control the comparison between floating point numbers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetEpsilon">Cudd_SetEpsilon</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadErrorCode"></A>
Cudd_ErrorType <I></I>
<B>Cudd_ReadErrorCode</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the code of the last error. The error codes are
  defined in cudd.h.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ClearErrorCode">Cudd_ClearErrorCode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadGarbageCollectionTime"></A>
long <I></I>
<B>Cudd_ReadGarbageCollectionTime</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of milliseconds spent doing garbage
  collection since the manager was initialized.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadGarbageCollections">Cudd_ReadGarbageCollections</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadGarbageCollections"></A>
int <I></I>
<B>Cudd_ReadGarbageCollections</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of times garbage collection has
  occurred in the manager. The number includes both the calls from
  reordering procedures and those caused by requests to create new
  nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadGarbageCollectionTime">Cudd_ReadGarbageCollectionTime</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadGroupcheck"></A>
Cudd_AggregationType <I></I>
<B>Cudd_ReadGroupcheck</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the groupcheck parameter of the manager. The
  groupcheck parameter determines the aggregation criterion in group
  sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetGroupcheck">Cudd_SetGroupcheck</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadInvPermZdd"></A>
int <I></I>
<B>Cudd_ReadInvPermZdd</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the index of the ZDD variable currently in the
  i-th position of the order. If the index is CUDD_CONST_INDEX, returns
  CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
<a href="#Cudd_ReadInvPermZdd">Cudd_ReadInvPermZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadInvPerm"></A>
int <I></I>
<B>Cudd_ReadInvPerm</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the index of the variable currently in the i-th
  position of the order. If the index is CUDD_CONST_INDEX, returns
  CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
<a href="#Cudd_ReadInvPermZdd">Cudd_ReadInvPermZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadIthClause"></A>
int <I></I>
<B>Cudd_ReadIthClause</B>(
  DdTlcInfo * <b>tlc</b>, <i></i>
  int  <b>i</b>, <i></i>
  DdHalfWord * <b>var1</b>, <i></i>
  DdHalfWord * <b>var2</b>, <i></i>
  int * <b>phase1</b>, <i></i>
  int * <b>phase2</b> <i></i>
)
</pre>
<dd> Accesses the i-th clause of a DD given the clause set which
  must be already computed.  Returns 1 if successful; 0 if i is out of range,
  or in case of error.
<p>

<dd> <b>Side Effects</b> the four components of a clause are returned as side effects.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FindTwoLiteralClauses">Cudd_FindTwoLiteralClauses</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadKeys"></A>
unsigned int <I></I>
<B>Cudd_ReadKeys</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the total number of nodes currently in the unique
  table, including the dead nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadDead">Cudd_ReadDead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadLinear"></A>
int <I></I>
<B>Cudd_ReadLinear</B>(
  DdManager * <b>table</b>, <i>CUDD manager</i>
  int  <b>x</b>, <i>row index</i>
  int  <b>y</b> <i>column index</i>
)
</pre>
<dd> Reads an entry of the linear transform matrix.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadLogicZero"></A>
DdNode * <I></I>
<B>Cudd_ReadLogicZero</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the zero constant of the manager. The logic zero
  constant is the complement of the one constant, and is distinct from
  the arithmetic zero.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadOne">Cudd_ReadOne</a>
<a href="#Cudd_ReadZero">Cudd_ReadZero</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadLooseUpTo"></A>
unsigned int <I></I>
<B>Cudd_ReadLooseUpTo</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the looseUpTo parameter of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetLooseUpTo">Cudd_SetLooseUpTo</a>
<a href="#Cudd_ReadMinHit">Cudd_ReadMinHit</a>
<a href="#Cudd_ReadMinDead">Cudd_ReadMinDead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMaxCacheHard"></A>
unsigned int <I></I>
<B>Cudd_ReadMaxCacheHard</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maxCacheHard parameter of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetMaxCacheHard">Cudd_SetMaxCacheHard</a>
<a href="#Cudd_ReadMaxCache">Cudd_ReadMaxCache</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMaxCache"></A>
unsigned int <I></I>
<B>Cudd_ReadMaxCache</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the soft limit for the cache size. The soft limit
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxCache">Cudd_ReadMaxCache</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMaxGrowthAlternate"></A>
double <I></I>
<B>Cudd_ReadMaxGrowthAlternate</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maxGrowthAlt parameter of the manager.  This
  parameter is analogous to the maxGrowth paramter, and is used every
  given number of reorderings instead of maxGrowth.  The number of
  reorderings is set with Cudd_SetReorderingCycle.  If the number of
  reorderings is 0 (default) maxGrowthAlt is never used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxGrowth">Cudd_ReadMaxGrowth</a>
<a href="#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
<a href="#Cudd_SetReorderingCycle">Cudd_SetReorderingCycle</a>
<a href="#Cudd_ReadReorderingCycle">Cudd_ReadReorderingCycle</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMaxGrowth"></A>
double <I></I>
<B>Cudd_ReadMaxGrowth</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maxGrowth parameter of the manager.  This
  parameter determines how much the number of nodes can grow during
  sifting of a variable.  Overall, sifting never increases the size of
  the decision diagrams.  This parameter only refers to intermediate
  results.  A lower value will speed up sifting, possibly at the
  expense of quality.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetMaxGrowth">Cudd_SetMaxGrowth</a>
<a href="#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMaxLive"></A>
unsigned int <I></I>
<B>Cudd_ReadMaxLive</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maximum allowed number of live nodes. When this
  number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetMaxLive">Cudd_SetMaxLive</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMaxMemory"></A>
unsigned long <I></I>
<B>Cudd_ReadMaxMemory</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the maximum allowed memory. When this
  number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetMaxMemory">Cudd_SetMaxMemory</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMemoryInUse"></A>
unsigned long <I></I>
<B>Cudd_ReadMemoryInUse</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the memory in use by the manager measured in bytes.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMinDead"></A>
unsigned int <I></I>
<B>Cudd_ReadMinDead</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the minDead parameter of the manager. The minDead
  parameter is used by the package to decide whether to collect garbage
  or resize a subtable of the unique table when the subtable becomes
  too full. The application can indirectly control the value of minDead
  by setting the looseUpTo parameter.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadDead">Cudd_ReadDead</a>
<a href="#Cudd_ReadLooseUpTo">Cudd_ReadLooseUpTo</a>
<a href="#Cudd_SetLooseUpTo">Cudd_SetLooseUpTo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMinHit"></A>
unsigned int <I></I>
<B>Cudd_ReadMinHit</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the hit rate that causes resizinig of the computed
  table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetMinHit">Cudd_SetMinHit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadMinusInfinity"></A>
DdNode * <I></I>
<B>Cudd_ReadMinusInfinity</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the minus-infinity constant from the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadNextReordering"></A>
unsigned int <I></I>
<B>Cudd_ReadNextReordering</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the threshold for the next dynamic reordering.
  The threshold is in terms of number of nodes and is in effect only
  if reordering is enabled. The count does not include the dead nodes,
  unless the countDead parameter of the manager has been changed from
  its default setting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetNextReordering">Cudd_SetNextReordering</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadNodeCount"></A>
long <I></I>
<B>Cudd_ReadNodeCount</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the number of live nodes in BDDs and ADDs. This
  number does not include the isolated projection functions and the
  unused constants. These nodes that are not counted are not part of
  the DDs manipulated by the application.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPeakNodeCount">Cudd_ReadPeakNodeCount</a>
<a href="#Cudd_zddReadNodeCount">Cudd_zddReadNodeCount</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadNodesDropped"></A>
double <I></I>
<B>Cudd_ReadNodesDropped</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of nodes killed by dereferencing if the
  keeping of this statistic is enabled; -1 otherwise. This statistic is
  enabled only if the package is compiled with DD_STATS defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadNodesFreed">Cudd_ReadNodesFreed</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadNodesFreed"></A>
double <I></I>
<B>Cudd_ReadNodesFreed</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of nodes returned to the free list if the
  keeping of this statistic is enabled; -1 otherwise. This statistic is
  enabled only if the package is compiled with DD_STATS defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadNodesDropped">Cudd_ReadNodesDropped</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadNumberXovers"></A>
int <I></I>
<B>Cudd_ReadNumberXovers</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the current number of crossovers used by the
  genetic algorithm for variable reordering. A larger number of crossovers will
  cause the genetic algorithm to take more time, but will generally
  produce better results. The default value is 0, in which case the
  package uses three times the number of variables as number of crossovers,
  with a maximum of 60.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetNumberXovers">Cudd_SetNumberXovers</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadOne"></A>
DdNode * <I></I>
<B>Cudd_ReadOne</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the one constant of the manager. The one
  constant is common to ADDs and BDDs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadZero">Cudd_ReadZero</a>
<a href="#Cudd_ReadLogicZero">Cudd_ReadLogicZero</a>
<a href="#Cudd_ReadZddOne">Cudd_ReadZddOne</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadPeakLiveNodeCount"></A>
int <I></I>
<B>Cudd_ReadPeakLiveNodeCount</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the peak number of live nodes. This count is kept
  only if CUDD is compiled with DD_STATS defined. If DD_STATS is not
  defined, this function returns -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadNodeCount">Cudd_ReadNodeCount</a>
<a href="#Cudd_PrintInfo">Cudd_PrintInfo</a>
<a href="#Cudd_ReadPeakNodeCount">Cudd_ReadPeakNodeCount</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadPeakNodeCount"></A>
long <I></I>
<B>Cudd_ReadPeakNodeCount</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the peak number of nodes. This number includes
  node on the free list. At the peak, the number of nodes on the free
  list is guaranteed to be less than DD_MEM_CHUNK.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadNodeCount">Cudd_ReadNodeCount</a>
<a href="#Cudd_PrintInfo">Cudd_PrintInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadPermZdd"></A>
int <I></I>
<B>Cudd_ReadPermZdd</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the current position of the i-th ZDD variable
  in the order. If the index is CUDD_CONST_INDEX, returns
  CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns
  -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadInvPermZdd">Cudd_ReadInvPermZdd</a>
<a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadPerm"></A>
int <I></I>
<B>Cudd_ReadPerm</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the current position of the i-th variable in
  the order. If the index is CUDD_CONST_INDEX, returns
  CUDD_CONST_INDEX; otherwise, if the index is out of bounds returns
  -1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadInvPerm">Cudd_ReadInvPerm</a>
<a href="#Cudd_ReadPermZdd">Cudd_ReadPermZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadPlusInfinity"></A>
DdNode * <I></I>
<B>Cudd_ReadPlusInfinity</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the plus-infinity constant from the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadPopulationSize"></A>
int <I></I>
<B>Cudd_ReadPopulationSize</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the current size of the population used by the
  genetic algorithm for variable reordering. A larger population size will
  cause the genetic algorithm to take more time, but will generally
  produce better results. The default value is 0, in which case the
  package uses three times the number of variables as population size,
  with a maximum of 120.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetPopulationSize">Cudd_SetPopulationSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadRecomb"></A>
int <I></I>
<B>Cudd_ReadRecomb</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the current value of the recombination
  parameter used in group sifting. A larger (positive) value makes the
  aggregation of variables due to the second difference criterion more
  likely. A smaller (negative) value makes aggregation less likely.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetRecomb">Cudd_SetRecomb</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadRecursiveCalls"></A>
double <I></I>
<B>Cudd_ReadRecursiveCalls</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of recursive calls if the package is
  compiled with DD_COUNT defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadReorderingCycle"></A>
int <I></I>
<B>Cudd_ReadReorderingCycle</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the reordCycle parameter of the manager.  This
  parameter determines how often the alternate threshold on maximum
  growth is used in reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
<a href="#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
<a href="#Cudd_SetReorderingCycle">Cudd_SetReorderingCycle</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadReorderingTime"></A>
long <I></I>
<B>Cudd_ReadReorderingTime</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of milliseconds spent reordering
  variables since the manager was initialized. The time spent in collecting
  garbage before reordering is included.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadReorderings">Cudd_ReadReorderings</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadReorderings"></A>
int <I></I>
<B>Cudd_ReadReorderings</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of times reordering has occurred in the
  manager. The number includes both the calls to Cudd_ReduceHeap from
  the application program and those automatically performed by the
  package. However, calls that do not even initiate reordering are not
  counted. A call may not initiate reordering if there are fewer than
  minsize live nodes in the manager, or if CUDD_REORDER_NONE is specified
  as reordering method. The calls to Cudd_ShuffleHeap are not counted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
<a href="#Cudd_ReadReorderingTime">Cudd_ReadReorderingTime</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadSiftMaxSwap"></A>
int <I></I>
<B>Cudd_ReadSiftMaxSwap</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the siftMaxSwap parameter of the manager. This
  parameter gives the maximum number of swaps that will be attempted
  for each invocation of sifting. The real number of swaps may exceed
  the set limit because the package will always complete the sifting
  of the variable that causes the limit to be reached.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadSiftMaxVar">Cudd_ReadSiftMaxVar</a>
<a href="#Cudd_SetSiftMaxSwap">Cudd_SetSiftMaxSwap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadSiftMaxVar"></A>
int <I></I>
<B>Cudd_ReadSiftMaxVar</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the siftMaxVar parameter of the manager. This
  parameter gives the maximum number of variables that will be sifted
  for each invocation of sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadSiftMaxSwap">Cudd_ReadSiftMaxSwap</a>
<a href="#Cudd_SetSiftMaxVar">Cudd_SetSiftMaxVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadSize"></A>
int <I></I>
<B>Cudd_ReadSize</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of BDD variables in existance.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadZddSize">Cudd_ReadZddSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadSlots"></A>
unsigned int <I></I>
<B>Cudd_ReadSlots</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the total number of slots of the unique table.
  This number ismainly for diagnostic purposes.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadStderr"></A>
FILE * <I></I>
<B>Cudd_ReadStderr</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the stderr of a manager. This is the file pointer to
  which messages normally going to stderr are written. It is initialized
  to stderr. Cudd_SetStderr allows the application to redirect it.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetStderr">Cudd_SetStderr</a>
<a href="#Cudd_ReadStdout">Cudd_ReadStdout</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadStdout"></A>
FILE * <I></I>
<B>Cudd_ReadStdout</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the stdout of a manager. This is the file pointer to
  which messages normally going to stdout are written. It is initialized
  to stdout. Cudd_SetStdout allows the application to redirect it.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetStdout">Cudd_SetStdout</a>
<a href="#Cudd_ReadStderr">Cudd_ReadStderr</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadSwapSteps"></A>
double <I></I>
<B>Cudd_ReadSwapSteps</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the number of elementary reordering steps.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadSymmviolation"></A>
int <I></I>
<B>Cudd_ReadSymmviolation</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the current value of the symmviolation
  parameter. This parameter is used in group sifting to decide how
  many violations to the symmetry conditions <code>f10 = f01</code> or
  <code>f11 = f00</code> are tolerable when checking for aggregation
  due to extended symmetry. The value should be between 0 and 100. A
  small value causes fewer variables to be aggregated. The default
  value is 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetSymmviolation">Cudd_SetSymmviolation</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadTree"></A>
MtrNode * <I></I>
<B>Cudd_ReadTree</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetTree">Cudd_SetTree</a>
<a href="#Cudd_FreeTree">Cudd_FreeTree</a>
<a href="#Cudd_ReadZddTree">Cudd_ReadZddTree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadUniqueLinks"></A>
double <I></I>
<B>Cudd_ReadUniqueLinks</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of links followed during look-ups in the
  unique table if the keeping of this statistic is enabled; -1 otherwise.
  If an item is found in the first position of its collision list, the
  number of links followed is taken to be 0. If it is in second position,
  the number of links is 1, and so on. This statistic is enabled only if
  the package is compiled with DD_UNIQUE_PROFILE defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadUniqueLookUps">Cudd_ReadUniqueLookUps</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadUniqueLookUps"></A>
double <I></I>
<B>Cudd_ReadUniqueLookUps</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of look-ups in the unique table if the
  keeping of this statistic is enabled; -1 otherwise. This statistic is
  enabled only if the package is compiled with DD_UNIQUE_PROFILE defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadUniqueLinks">Cudd_ReadUniqueLinks</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadUsedSlots"></A>
double <I></I>
<B>Cudd_ReadUsedSlots</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reads the fraction of used slots in the unique
  table. The unused slots are those in which no valid data is
  stored. Garbage collection, variable reordering, and subtable
  resizing may cause used slots to become unused.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadSlots">Cudd_ReadSlots</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadVars"></A>
DdNode * <I></I>
<B>Cudd_ReadVars</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the i-th element of the vars array if it falls
  within the array bounds; NULL otherwise. If i is the index of an
  existing variable, this function produces the same result as
  Cudd_bddIthVar. However, if the i-th var does not exist yet,
  Cudd_bddIthVar will create it, whereas Cudd_ReadVars will not.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIthVar">Cudd_bddIthVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadZddOne"></A>
DdNode * <I></I>
<B>Cudd_ReadZddOne</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the ZDD for the constant 1 function.
  The representation of the constant 1 function as a ZDD depends on
  how many variables it (nominally) depends on. The index of the
  topmost variable in the support is given as argument <code>i</code>.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadOne">Cudd_ReadOne</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadZddSize"></A>
int <I></I>
<B>Cudd_ReadZddSize</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the number of ZDD variables in existance.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadZddTree"></A>
MtrNode * <I></I>
<B>Cudd_ReadZddTree</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetZddTree">Cudd_SetZddTree</a>
<a href="#Cudd_FreeZddTree">Cudd_FreeZddTree</a>
<a href="#Cudd_ReadTree">Cudd_ReadTree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReadZero"></A>
DdNode * <I></I>
<B>Cudd_ReadZero</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns the zero constant of the manager. The zero
  constant is the arithmetic zero, rather than the logic zero. The
  latter is the complement of the one constant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadOne">Cudd_ReadOne</a>
<a href="#Cudd_ReadLogicZero">Cudd_ReadLogicZero</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_RecursiveDerefZdd"></A>
void <I></I>
<B>Cudd_RecursiveDerefZdd</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of ZDD node n. If n dies,
  recursively decreases the reference counts of its children.  It is
  used to dispose of a ZDD that is no longer needed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Deref">Cudd_Deref</a>
<a href="#Cudd_Ref">Cudd_Ref</a>
<a href="#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_RecursiveDeref"></A>
void <I></I>
<B>Cudd_RecursiveDeref</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Decreases the reference count of node n. If n dies,
  recursively decreases the reference counts of its children.  It is
  used to dispose of a DD that is no longer needed.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Deref">Cudd_Deref</a>
<a href="#Cudd_Ref">Cudd_Ref</a>
<a href="#Cudd_RecursiveDerefZdd">Cudd_RecursiveDerefZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReduceHeap"></A>
int <I></I>
<B>Cudd_ReduceHeap</B>(
  DdManager * <b>table</b>, <i>DD manager</i>
  Cudd_ReorderingType  <b>heuristic</b>, <i>method used for reordering</i>
  int  <b>minsize</b> <i>bound below which no reordering occurs</i>
)
</pre>
<dd> Main dynamic reordering routine.
  Calls one of the possible reordering procedures:
  <ul>
  <li>Swapping
  <li>Sifting
  <li>Symmetric Sifting
  <li>Group Sifting
  <li>Window Permutation
  <li>Simulated Annealing
  <li>Genetic Algorithm
  <li>Dynamic Programming (exact)
  </ul>

  For sifting, symmetric sifting, group sifting, and window
  permutation it is possible to request reordering to convergence.<p>

  The core of all methods is the reordering procedure
  cuddSwapInPlace() which swaps two adjacent variables and is based
  on Rudell's paper.
  Returns 1 in case of success; 0 otherwise. In the case of symmetric
  sifting (with and without convergence) returns 1 plus the number of
  symmetric variables, in case of success.
<p>

<dd> <b>Side Effects</b> Changes the variable order for all diagrams and clears
  the cache.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Ref"></A>
void <I></I>
<B>Cudd_Ref</B>(
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Increases the reference count of a node, if it is not
  saturated.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RecursiveDeref">Cudd_RecursiveDeref</a>
<a href="#Cudd_Deref">Cudd_Deref</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="Cudd_RemapOverApprox"></A>
DdNode * <I></I>
<B>Cudd_RemapOverApprox</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is
  identical to the underapproximation procedure except for the fact that it
  works on the complement of the given function. Extracting the subset
  of the complement function is equivalent to extracting the superset
  of the function.
  Returns a pointer to the BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory. The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation.  The optimal number
  should be as close as possible to the size of the support of f.
  However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023.  If numVars is
  larger than 1023, it will overflow. If a 0 parameter is passed then
  the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="Cudd_RemapUnderApprox"></A>
DdNode * <I></I>
<B>Cudd_RemapUnderApprox</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure uses
  a remapping technique and density as the cost function.
  Returns a pointer to the BDD of the subset if
  successful. NULL if the procedure runs out of memory. The parameter
  numVars is the maximum number of variables to be used in minterm
  calculation.  The optimal number should be as close as possible to
  the size of the support of f.  However, it is safe to pass the value
  returned by Cudd_ReadSize for numVars when the number of variables
  is under 1023.  If numVars is larger than 1023, it will cause
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="#Cudd_UnderApprox">Cudd_UnderApprox</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="Cudd_RemoveHook"></A>
int <I></I>
<B>Cudd_RemoveHook</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_HFP  <b>f</b>, <i></i>
  Cudd_HookType  <b>where</b> <i></i>
)
</pre>
<dd> Removes a function from a hook. A hook is a list of
  application-provided functions called on certain occasions by the
  package. Returns 1 if successful; 0 the function was not in the list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AddHook">Cudd_AddHook</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReorderingReporting"></A>
int <I></I>
<B>Cudd_ReorderingReporting</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Returns 1 if reporting of reordering stats is enabled;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_EnableReorderingReporting">Cudd_EnableReorderingReporting</a>
<a href="#Cudd_DisableReorderingReporting">Cudd_DisableReorderingReporting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReorderingStatusZdd"></A>
int <I></I>
<B>Cudd_ReorderingStatusZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType * <b>method</b> <i></i>
)
</pre>
<dd> Reports the status of automatic dynamic reordering of
  ZDDs. Parameter method is set to the ZDD reordering method currently
  selected. Returns 1 if automatic reordering is enabled; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> Parameter method is set to the ZDD reordering method currently
  selected.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AutodynEnableZdd">Cudd_AutodynEnableZdd</a>
<a href="#Cudd_AutodynDisableZdd">Cudd_AutodynDisableZdd</a>
<a href="#Cudd_ReorderingStatus">Cudd_ReorderingStatus</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ReorderingStatus"></A>
int <I></I>
<B>Cudd_ReorderingStatus</B>(
  DdManager * <b>unique</b>, <i></i>
  Cudd_ReorderingType * <b>method</b> <i></i>
)
</pre>
<dd> Reports the status of automatic dynamic reordering of
  BDDs and ADDs. Parameter method is set to the reordering method
  currently selected. Returns 1 if automatic reordering is enabled; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> Parameter method is set to the reordering method currently
  selected.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_AutodynEnable">Cudd_AutodynEnable</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
<a href="#Cudd_ReorderingStatusZdd">Cudd_ReorderingStatusZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetArcviolation"></A>
void <I></I>
<B>Cudd_SetArcviolation</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>arcviolation</b> <i></i>
)
</pre>
<dd> Sets the value of the arcviolation
  parameter. This parameter is used in group sifting to decide how
  many arcs into <code>y</code> not coming from <code>x</code> are
  tolerable when checking for aggregation due to extended
  symmetry. The value should be between 0 and 100. A small value
  causes fewer variables to be aggregated. The default value is 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadArcviolation">Cudd_ReadArcviolation</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetBackground"></A>
void <I></I>
<B>Cudd_SetBackground</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>bck</b> <i></i>
)
</pre>
<dd> Sets the background constant of the manager. It assumes
  that the DdNode pointer bck is already referenced.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetEpsilon"></A>
void <I></I>
<B>Cudd_SetEpsilon</B>(
  DdManager * <b>dd</b>, <i></i>
  CUDD_VALUE_TYPE  <b>ep</b> <i></i>
)
</pre>
<dd> Sets the epsilon parameter of the manager to ep. The epsilon
  parameter control the comparison between floating point numbers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadEpsilon">Cudd_ReadEpsilon</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetGroupcheck"></A>
void <I></I>
<B>Cudd_SetGroupcheck</B>(
  DdManager * <b>dd</b>, <i></i>
  Cudd_AggregationType  <b>gc</b> <i></i>
)
</pre>
<dd> Sets the parameter groupcheck of the manager to gc. The
  groupcheck parameter determines the aggregation criterion in group
  sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadGroupCheck">Cudd_ReadGroupCheck</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetLooseUpTo"></A>
void <I></I>
<B>Cudd_SetLooseUpTo</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>lut</b> <i></i>
)
</pre>
<dd> Sets the looseUpTo parameter of the manager. This
  parameter of the manager controls the threshold beyond which no fast
  growth of the unique table is allowed. The threshold is given as a
  number of slots. If the value passed to this function is 0, the
  function determines a suitable value based on the available memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadLooseUpTo">Cudd_ReadLooseUpTo</a>
<a href="#Cudd_SetMinHit">Cudd_SetMinHit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetMaxCacheHard"></A>
void <I></I>
<B>Cudd_SetMaxCacheHard</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>mc</b> <i></i>
)
</pre>
<dd> Sets the maxCacheHard parameter of the manager. The
  cache cannot grow larger than maxCacheHard entries. This parameter
  allows an application to control the trade-off of memory versus
  speed. If the value passed to this function is 0, the function
  determines a suitable maximum cache size based on the available memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxCacheHard">Cudd_ReadMaxCacheHard</a>
<a href="#Cudd_SetMaxCache">Cudd_SetMaxCache</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetMaxGrowthAlternate"></A>
void <I></I>
<B>Cudd_SetMaxGrowthAlternate</B>(
  DdManager * <b>dd</b>, <i></i>
  double  <b>mg</b> <i></i>
)
</pre>
<dd> Sets the maxGrowthAlt parameter of the manager.  This
  parameter is analogous to the maxGrowth paramter, and is used every
  given number of reorderings instead of maxGrowth.  The number of
  reorderings is set with Cudd_SetReorderingCycle.  If the number of
  reorderings is 0 (default) maxGrowthAlt is never used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
<a href="#Cudd_SetMaxGrowth">Cudd_SetMaxGrowth</a>
<a href="#Cudd_SetReorderingCycle">Cudd_SetReorderingCycle</a>
<a href="#Cudd_ReadReorderingCycle">Cudd_ReadReorderingCycle</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetMaxGrowth"></A>
void <I></I>
<B>Cudd_SetMaxGrowth</B>(
  DdManager * <b>dd</b>, <i></i>
  double  <b>mg</b> <i></i>
)
</pre>
<dd> Sets the maxGrowth parameter of the manager.  This
  parameter determines how much the number of nodes can grow during
  sifting of a variable.  Overall, sifting never increases the size of
  the decision diagrams.  This parameter only refers to intermediate
  results.  A lower value will speed up sifting, possibly at the
  expense of quality.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxGrowth">Cudd_ReadMaxGrowth</a>
<a href="#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetMaxLive"></A>
void <I></I>
<B>Cudd_SetMaxLive</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>maxLive</b> <i></i>
)
</pre>
<dd> Sets the maximum allowed number of live nodes. When this
  number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxLive">Cudd_ReadMaxLive</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetMaxMemory"></A>
void <I></I>
<B>Cudd_SetMaxMemory</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned long  <b>maxMemory</b> <i></i>
)
</pre>
<dd> Sets the maximum allowed memory. When this
  number is exceeded, the package returns NULL.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxMemory">Cudd_ReadMaxMemory</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetMinHit"></A>
void <I></I>
<B>Cudd_SetMinHit</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>hr</b> <i></i>
)
</pre>
<dd> Sets the minHit parameter of the manager. This
  parameter controls the resizing of the computed table. If the hit
  rate is larger than the specified value, and the cache is not
  already too large, then its size is doubled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMinHit">Cudd_ReadMinHit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetNextReordering"></A>
void <I></I>
<B>Cudd_SetNextReordering</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>next</b> <i></i>
)
</pre>
<dd> Sets the threshold for the next dynamic reordering.
  The threshold is in terms of number of nodes and is in effect only
  if reordering is enabled. The count does not include the dead nodes,
  unless the countDead parameter of the manager has been changed from
  its default setting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadNextReordering">Cudd_ReadNextReordering</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetNumberXovers"></A>
void <I></I>
<B>Cudd_SetNumberXovers</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>numberXovers</b> <i></i>
)
</pre>
<dd> Sets the number of crossovers used by the genetic
  algorithm for variable reordering. A larger number of crossovers
  will cause the genetic algorithm to take more time, but will
  generally produce better results. The default value is 0, in which
  case the package uses three times the number of variables as number
  of crossovers, with a maximum of 60.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadNumberXovers">Cudd_ReadNumberXovers</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetPopulationSize"></A>
void <I></I>
<B>Cudd_SetPopulationSize</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>populationSize</b> <i></i>
)
</pre>
<dd> Sets the size of the population used by the
  genetic algorithm for variable reordering. A larger population size will
  cause the genetic algorithm to take more time, but will generally
  produce better results. The default value is 0, in which case the
  package uses three times the number of variables as population size,
  with a maximum of 120.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPopulationSize">Cudd_ReadPopulationSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetRecomb"></A>
void <I></I>
<B>Cudd_SetRecomb</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>recomb</b> <i></i>
)
</pre>
<dd> Sets the value of the recombination parameter used in
  group sifting. A larger (positive) value makes the aggregation of
  variables due to the second difference criterion more likely. A
  smaller (negative) value makes aggregation less likely. The default
  value is 0.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadRecomb">Cudd_ReadRecomb</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetReorderingCycle"></A>
void <I></I>
<B>Cudd_SetReorderingCycle</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>cycle</b> <i></i>
)
</pre>
<dd> Sets the reordCycle parameter of the manager.  This
  parameter determines how often the alternate threshold on maximum
  growth is used in reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadMaxGrowthAlternate">Cudd_ReadMaxGrowthAlternate</a>
<a href="#Cudd_SetMaxGrowthAlternate">Cudd_SetMaxGrowthAlternate</a>
<a href="#Cudd_ReadReorderingCycle">Cudd_ReadReorderingCycle</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetSiftMaxSwap"></A>
void <I></I>
<B>Cudd_SetSiftMaxSwap</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>sms</b> <i></i>
)
</pre>
<dd> Sets the siftMaxSwap parameter of the manager. This
  parameter gives the maximum number of swaps that will be attempted
  for each invocation of sifting. The real number of swaps may exceed
  the set limit because the package will always complete the sifting
  of the variable that causes the limit to be reached.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetSiftMaxVar">Cudd_SetSiftMaxVar</a>
<a href="#Cudd_ReadSiftMaxSwap">Cudd_ReadSiftMaxSwap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetSiftMaxVar"></A>
void <I></I>
<B>Cudd_SetSiftMaxVar</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>smv</b> <i></i>
)
</pre>
<dd> Sets the siftMaxVar parameter of the manager. This
  parameter gives the maximum number of variables that will be sifted
  for each invocation of sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SetSiftMaxSwap">Cudd_SetSiftMaxSwap</a>
<a href="#Cudd_ReadSiftMaxVar">Cudd_ReadSiftMaxVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetStderr"></A>
void <I></I>
<B>Cudd_SetStderr</B>(
  DdManager * <b>dd</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Sets the stderr of a manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadStderr">Cudd_ReadStderr</a>
<a href="#Cudd_SetStdout">Cudd_SetStdout</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetStdout"></A>
void <I></I>
<B>Cudd_SetStdout</B>(
  DdManager * <b>dd</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Sets the stdout of a manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadStdout">Cudd_ReadStdout</a>
<a href="#Cudd_SetStderr">Cudd_SetStderr</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetSymmviolation"></A>
void <I></I>
<B>Cudd_SetSymmviolation</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>symmviolation</b> <i></i>
)
</pre>
<dd> Sets the value of the symmviolation
  parameter. This parameter is used in group sifting to decide how
  many violations to the symmetry conditions <code>f10 = f01</code> or
  <code>f11 = f00</code> are tolerable when checking for aggregation
  due to extended symmetry. The value should be between 0 and 100. A
  small value causes fewer variables to be aggregated. The default
  value is 0.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadSymmviolation">Cudd_ReadSymmviolation</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetTree"></A>
void <I></I>
<B>Cudd_SetTree</B>(
  DdManager * <b>dd</b>, <i></i>
  MtrNode * <b>tree</b> <i></i>
)
</pre>
<dd> Sets the variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FreeTree">Cudd_FreeTree</a>
<a href="#Cudd_ReadTree">Cudd_ReadTree</a>
<a href="#Cudd_SetZddTree">Cudd_SetZddTree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetVarMap"></A>
int <I></I>
<B>Cudd_SetVarMap</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdNode ** <b>x</b>, <i>first array of variables</i>
  DdNode ** <b>y</b>, <i>second array of variables</i>
  int  <b>n</b> <i>length of both arrays</i>
)
</pre>
<dd> Registers with the manager a variable mapping described
  by two sets of variables.  This variable mapping is then used by
  functions like Cudd_bddVarMap.  This function is convenient for
  those applications that perform the same mapping several times.
  However, if several different permutations are used, it may be more
  efficient not to rely on the registered mapping, because changing
  mapping causes the cache to be cleared.  (The initial setting,
  however, does not clear the cache.) The two sets of variables (x and
  y) must have the same size (x and y).  The size is given by n. The
  two sets of variables are normally disjoint, but this restriction is
  not imposeded by the function. When new variables are created, the
  map is automatically extended (each new variable maps to
  itself). The typical use, however, is to wait until all variables
  are created, and then create the map.  Returns 1 if the mapping is
  successfully registered with the manager; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Modifies the manager. May clear the cache.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddVarMap">Cudd_bddVarMap</a>
<a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SetZddTree"></A>
void <I></I>
<B>Cudd_SetZddTree</B>(
  DdManager * <b>dd</b>, <i></i>
  MtrNode * <b>tree</b> <i></i>
)
</pre>
<dd> Sets the ZDD variable group tree of the manager.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FreeZddTree">Cudd_FreeZddTree</a>
<a href="#Cudd_ReadZddTree">Cudd_ReadZddTree</a>
<a href="#Cudd_SetTree">Cudd_SetTree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SharingSize"></A>
int <I></I>
<B>Cudd_SharingSize</B>(
  DdNode ** <b>nodeArray</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Counts the number of nodes in an array of DDs. Shared
  nodes are counted only once.  Returns the total number of nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DagSize">Cudd_DagSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ShortestLength"></A>
int <I></I>
<B>Cudd_ShortestLength</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>weight</b> <i></i>
)
</pre>
<dd> Find the length of the shortest path(s) in a DD. f is
  the DD we want to get the shortest path for; weight[i] is the
  weight of the THEN edge coming from the node whose index is i. All
  ELSE edges have 0 weight. Returns the length of the shortest
  path(s) if such a path is found; a large number if the function is
  identically 0, and CUDD_OUT_OF_MEM in case of failure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ShortestPath">Cudd_ShortestPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ShortestPath"></A>
DdNode * <I></I>
<B>Cudd_ShortestPath</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>weight</b>, <i></i>
  int * <b>support</b>, <i></i>
  int * <b>length</b> <i></i>
)
</pre>
<dd> Finds a shortest path in a DD. f is the DD we want to
  get the shortest path for; weight[i] is the weight of the THEN arc
  coming from the node whose index is i. If weight is NULL, then unit
  weights are assumed for all THEN arcs. All ELSE arcs have 0 weight.
  If non-NULL, both weight and support should point to arrays with at
  least as many entries as there are variables in the manager.
  Returns the shortest path as the BDD of a cube.
<p>

<dd> <b>Side Effects</b> support contains on return the true support of f.
  If support is NULL on entry, then Cudd_ShortestPath does not compute
  the true support info. length contains the length of the path.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ShortestLength">Cudd_ShortestLength</a>
<a href="#Cudd_LargestCube">Cudd_LargestCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_ShuffleHeap"></A>
int <I></I>
<B>Cudd_ShuffleHeap</B>(
  DdManager * <b>table</b>, <i>DD manager</i>
  int * <b>permutation</b> <i>required variable permutation</i>
)
</pre>
<dd> Reorders variables according to given permutation.
  The i-th entry of the permutation array contains the index of the variable
  that should be brought to the i-th level.  The size of the array should be
  equal or greater to the number of variables currently in use.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the variable order for all diagrams and clears
  the cache.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SolveEqn"></A>
DdNode * <I></I>
<B>Cudd_SolveEqn</B>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode * <b>Y</b>, <i>the cube of the y variables</i>
  DdNode ** <b>G</b>, <i>the array of solutions (return parameter)</i>
  int ** <b>yIndex</b>, <i>index of y variables</i>
  int  <b>n</b> <i>numbers of unknowns</i>
)
</pre>
<dd> Implements the solution for F(x,y) = 0. The return
  value is the consistency condition. The y variables are the unknowns
  and the remaining variables are the parameters.  Returns the
  consistency condition if successful; NULL otherwise. Cudd_SolveEqn
  allocates an array and fills it with the indices of the
  unknowns. This array is used by Cudd_VerifySol.
<p>

<dd> <b>Side Effects</b> The solution is returned in G; the indices of the y
  variables are returned in yIndex.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSolve.c"TARGET="ABSTRACT"><CODE>cuddSolve.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SplitSet"></A>
DdNode * <I></I>
<B>Cudd_SplitSet</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>S</b>, <i></i>
  DdNode ** <b>xVars</b>, <i></i>
  int  <b>n</b>, <i></i>
  double  <b>m</b> <i></i>
)
</pre>
<dd> Returns <code>m</code> minterms from a BDD whose
  support has <code>n</code> variables at most.  The procedure tries
  to create as few extra nodes as possible. The function represented
  by <code>S</code> depends on at most <code>n</code> of the variables
  in <code>xVars</code>. Returns a BDD with <code>m</code> minterms
  of the on-set of S if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Srandom"></A>
void <I></I>
<B>Cudd_Srandom</B>(
  long  <b>seed</b> <i></i>
)
</pre>
<dd> Initializer for the portable number generator based on
  ran2 in "Numerical Recipes in C." The input is the seed for the
  generator. If it is negative, its absolute value is taken as seed.
  If it is 0, then 1 is taken as seed. The initialized sets up the two
  recurrences used to generate a long-period stream, and sets up the
  shuffle table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Random">Cudd_Random</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_StdPostReordHook"></A>
int <I></I>
<B>Cudd_StdPostReordHook</B>(
  DdManager * <b>dd</b>, <i></i>
  const char * <b>str</b>, <i></i>
  void * <b>data</b> <i></i>
)
</pre>
<dd> Sample hook function to call after reordering.
  Prints on the manager's stdout final size and reordering time.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_StdPreReordHook">Cudd_StdPreReordHook</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_StdPreReordHook"></A>
int <I></I>
<B>Cudd_StdPreReordHook</B>(
  DdManager * <b>dd</b>, <i></i>
  const char * <b>str</b>, <i></i>
  void * <b>data</b> <i></i>
)
</pre>
<dd> Sample hook function to call before reordering.
  Prints on the manager's stdout reordering method and initial size.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_StdPostReordHook">Cudd_StdPostReordHook</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SubsetCompress"></A>
DdNode * <I></I>
<B>Cudd_SubsetCompress</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>BDD whose subset is sought</i>
  int  <b>nvars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the subset</i>
)
</pre>
<dd> Finds a dense subset of BDD <code>f</code>. Density is
  the ratio of number of minterms to number of nodes.  Uses several
  techniques in series. It is more expensive than other subsetting
  procedures, but often produces better results. See
  Cudd_SubsetShortPaths for a description of the threshold and nvars
  parameters.  Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetRemap">Cudd_SubsetRemap</a>
<a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SubsetHeavyBranch"></A>
DdNode * <I></I>
<B>Cudd_SubsetHeavyBranch</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the subset</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure
  builds a subset by throwing away one of the children of each node,
  starting from the root, until the result is small enough. The child
  that is eliminated from the result is the one that contributes the
  fewer minterms.  Returns a pointer to the BDD of the subset if
  successful. NULL if the procedure runs out of memory. The parameter
  numVars is the maximum number of variables to be used in minterm
  calculation and node count calculation.  The optimal number should
  be as close as possible to the size of the support of f.  However,
  it is safe to pass the value returned by Cudd_ReadSize for numVars
  when the number of variables is under 1023.  If numVars is larger
  than 1023, it will overflow. If a 0 parameter is passed then the
  procedure will compute a value which will avoid overflow but will
  cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SubsetShortPaths"></A>
DdNode * <I></I>
<B>Cudd_SubsetShortPaths</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>maximum number of nodes in the subset</i>
  int  <b>hardlimit</b> <i>flag: 1 if threshold is a hard limit</i>
)
</pre>
<dd> Extracts a dense subset from a BDD.  This procedure
  tries to preserve the shortest paths of the input BDD, because they
  give many minterms and contribute few nodes.  This procedure may
  increase the number of nodes in trying to create the subset or
  reduce the number of nodes due to recombination as compared to the
  original BDD. Hence the threshold may not be strictly adhered to. In
  practice, recombination overshadows the increase in the number of
  nodes and results in small BDDs as compared to the threshold. The
  hardlimit specifies whether threshold needs to be strictly adhered
  to. If it is set to 1, the procedure ensures that result is never
  larger than the specified limit but may be considerably less than
  the threshold.  Returns a pointer to the BDD for the subset if
  successful; NULL otherwise.  The value for numVars should be as
  close as possible to the size of the support of f for better
  efficiency. However, it is safe to pass the value returned by
  Cudd_ReadSize for numVars. If 0 is passed, then the value returned
  by Cudd_ReadSize is used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SubsetWithMaskVars"></A>
DdNode * <I></I>
<B>Cudd_SubsetWithMaskVars</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function from which to pick a cube</i>
  DdNode ** <b>vars</b>, <i>array of variables</i>
  int  <b>nvars</b>, <i>size of <code>vars</code></i>
  DdNode ** <b>maskVars</b>, <i>array of variables</i>
  int  <b>mvars</b> <i>size of <code>maskVars</code></i>
)
</pre>
<dd> Extracts a subset from a BDD in the following procedure.
  1. Compute the weight for each mask variable by counting the number of
     minterms for both positive and negative cofactors of the BDD with
     respect to each mask variable. (weight = #positive - #negative)
  2. Find a representative cube of the BDD by using the weight. From the
     top variable of the BDD, for each variable, if the weight is greater
     than 0.0, choose THEN branch, othereise ELSE branch, until meeting
     the constant 1.
  3. Quantify out the variables not in maskVars from the representative
     cube and if a variable in maskVars is don't care, replace the
     variable with a constant(1 or 0) depending on the weight.
  4. Make a subset of the BDD by multiplying with the modified cube.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SupersetCompress"></A>
DdNode * <I></I>
<B>Cudd_SupersetCompress</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>BDD whose superset is sought</i>
  int  <b>nvars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the superset</i>
)
</pre>
<dd> Finds a dense superset of BDD <code>f</code>. Density is
  the ratio of number of minterms to number of nodes.  Uses several
  techniques in series. It is more expensive than other supersetting
  procedures, but often produces better results. See
  Cudd_SupersetShortPaths for a description of the threshold and nvars
  parameters.  Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetCompress">Cudd_SubsetCompress</a>
<a href="#Cudd_SupersetRemap">Cudd_SupersetRemap</a>
<a href="#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SupersetHeavyBranch"></A>
DdNode * <I></I>
<B>Cudd_SupersetHeavyBranch</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b> <i>maximum number of nodes in the superset</i>
)
</pre>
<dd> Extracts a dense superset from a BDD. The procedure is
  identical to the subset procedure except for the fact that it
  receives the complement of the given function. Extracting the subset
  of the complement function is equivalent to extracting the superset
  of the function. This procedure builds a superset by throwing away
  one of the children of each node starting from the root of the
  complement function, until the result is small enough. The child
  that is eliminated from the result is the one that contributes the
  fewer minterms.
  Returns a pointer to the BDD of the superset if successful. NULL if
  intermediate result causes the procedure to run out of memory. The
  parameter numVars is the maximum number of variables to be used in
  minterm calculation and node count calculation.  The optimal number
  should be as close as possible to the size of the support of f.
  However, it is safe to pass the value returned by Cudd_ReadSize for
  numVars when the number of variables is under 1023.  If numVars is
  larger than 1023, it will overflow. If a 0 parameter is passed then
  the procedure will compute a value which will avoid overflow but
  will cause underflow with 2046 variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="#Cudd_SupersetShortPaths">Cudd_SupersetShortPaths</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SupersetShortPaths"></A>
DdNode * <I></I>
<B>Cudd_SupersetShortPaths</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be superset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>maximum number of nodes in the subset</i>
  int  <b>hardlimit</b> <i>flag: 1 if threshold is a hard limit</i>
)
</pre>
<dd> Extracts a dense superset from a BDD.  The procedure is
  identical to the subset procedure except for the fact that it
  receives the complement of the given function. Extracting the subset
  of the complement function is equivalent to extracting the superset
  of the function.  This procedure tries to preserve the shortest
  paths of the complement BDD, because they give many minterms and
  contribute few nodes.  This procedure may increase the number of
  nodes in trying to create the superset or reduce the number of nodes
  due to recombination as compared to the original BDD. Hence the
  threshold may not be strictly adhered to. In practice, recombination
  overshadows the increase in the number of nodes and results in small
  BDDs as compared to the threshold.  The hardlimit specifies whether
  threshold needs to be strictly adhered to. If it is set to 1, the
  procedure ensures that result is never larger than the specified
  limit but may be considerably less than the threshold. Returns a
  pointer to the BDD for the superset if successful; NULL
  otherwise. The value for numVars should be as close as possible to
  the size of the support of f for better efficiency.  However, it is
  safe to pass the value returned by Cudd_ReadSize for numVar.  If 0
  is passed, then the value returned by Cudd_ReadSize is used.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="#Cudd_SupersetHeavyBranch">Cudd_SupersetHeavyBranch</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SupportIndex"></A>
int * <I></I>
<B>Cudd_SupportIndex</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b> <i>DD whose support is sought</i>
)
</pre>
<dd> Finds the variables on which a DD depends.  Returns an
  index array of the variables if successful; NULL otherwise.  The
  size of the array equals the number of variables in the manager.
  Each entry of the array is 1 if the corresponding variable is in the
  support of the DD and 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Support">Cudd_Support</a>
<a href="#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SupportSize"></A>
int <I></I>
<B>Cudd_SupportSize</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b> <i>DD whose support size is sought</i>
)
</pre>
<dd> Counts the variables on which a DD depends.
  Returns the number of the variables if successful; CUDD_OUT_OF_MEM
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Support">Cudd_Support</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Support"></A>
DdNode * <I></I>
<B>Cudd_Support</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b> <i>DD whose support is sought</i>
)
</pre>
<dd> Finds the variables on which a DD depends.
  Returns a BDD consisting of the product of the variables if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_SymmProfile"></A>
void <I></I>
<B>Cudd_SymmProfile</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Prints statistics on symmetric variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="Cudd_TurnOffCountDead"></A>
void <I></I>
<B>Cudd_TurnOffCountDead</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Causes the dead nodes not to be counted towards
  triggering reordering. This causes less frequent reorderings. By
  default dead nodes are not counted. Therefore there is no need to
  call this function unless Cudd_TurnOnCountDead has been previously
  called.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_TurnOnCountDead">Cudd_TurnOnCountDead</a>
<a href="#Cudd_DeadAreCounted">Cudd_DeadAreCounted</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_TurnOnCountDead"></A>
void <I></I>
<B>Cudd_TurnOnCountDead</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Causes the dead nodes to be counted towards triggering
  reordering. This causes more frequent reorderings. By default dead
  nodes are not counted.
<p>

<dd> <b>Side Effects</b> Changes the manager.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_TurnOffCountDead">Cudd_TurnOffCountDead</a>
<a href="#Cudd_DeadAreCounted">Cudd_DeadAreCounted</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_UnderApprox"></A>
DdNode * <I></I>
<B>Cudd_UnderApprox</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>number of variables in the support of f</i>
  int  <b>threshold</b>, <i>when to stop approximation</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Extracts a dense subset from a BDD. This procedure uses
  a variant of Tom Shiple's underapproximation method. The main
  difference from the original method is that density is used as cost
  function.  Returns a pointer to the BDD of the subset if
  successful. NULL if the procedure runs out of memory. The parameter
  numVars is the maximum number of variables to be used in minterm
  calculation.  The optimal number should be as close as possible to
  the size of the support of f.  However, it is safe to pass the value
  returned by Cudd_ReadSize for numVars when the number of variables
  is under 1023.  If numVars is larger than 1023, it will cause
  overflow. If a 0 parameter is passed then the procedure will compute
  a value which will avoid overflow but will cause underflow with 2046
  variables or more.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
<a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
<a href="#Cudd_ReadSize">Cudd_ReadSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="Cudd_VectorSupportIndex"></A>
int * <I></I>
<B>Cudd_VectorSupportIndex</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode ** <b>F</b>, <i>array of DDs whose support is sought</i>
  int  <b>n</b> <i>size of the array</i>
)
</pre>
<dd> Finds the variables on which a set of DDs depends.
  The set must contain either BDDs and ADDs, or ZDDs.
  Returns an index array of the variables if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SupportIndex">Cudd_SupportIndex</a>
<a href="#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_VectorSupportSize"></A>
int <I></I>
<B>Cudd_VectorSupportSize</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode ** <b>F</b>, <i>array of DDs whose support is sought</i>
  int  <b>n</b> <i>size of the array</i>
)
</pre>
<dd> Counts the variables on which a set of DDs depends.
  The set must contain either BDDs and ADDs, or ZDDs.
  Returns the number of the variables if successful; CUDD_OUT_OF_MEM
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_VectorSupport">Cudd_VectorSupport</a>
<a href="#Cudd_SupportSize">Cudd_SupportSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_VectorSupport"></A>
DdNode * <I></I>
<B>Cudd_VectorSupport</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode ** <b>F</b>, <i>array of DDs whose support is sought</i>
  int  <b>n</b> <i>size of the array</i>
)
</pre>
<dd> Finds the variables on which a set of DDs depends.
  The set must contain either BDDs and ADDs, or ZDDs.
  Returns a BDD consisting of the product of the variables if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Support">Cudd_Support</a>
<a href="#Cudd_ClassifySupport">Cudd_ClassifySupport</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_VerifySol"></A>
DdNode * <I></I>
<B>Cudd_VerifySol</B>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int * <b>yIndex</b>, <i>index of y variables</i>
  int  <b>n</b> <i>numbers of unknowns</i>
)
</pre>
<dd> Checks the solution of F(x,y) = 0. This procedure 
  substitutes the solution components for the unknowns of F and returns 
  the resulting BDD for F.
<p>

<dd> <b>Side Effects</b> Frees the memory pointed by yIndex.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SolveEqn">Cudd_SolveEqn</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSolve.c"TARGET="ABSTRACT"><CODE>cuddSolve.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Xeqy"></A>
DdNode * <I></I>
<B>Cudd_Xeqy</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates a BDD for the function x==y.
  Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and
  y[0] y[1] ...  y[N-1], with 0 the most significant bit.
  The BDD is built bottom-up.
  It has 3*N-1 internal nodes, if the variables are ordered as follows:
  x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addXeqy">Cudd_addXeqy</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_Xgty"></A>
DdNode * <I></I>
<B>Cudd_Xgty</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  DdNode ** <b>z</b>, <i>array of z variables: unused</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates a BDD for the function x &gt; y.
  Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and
  y[0] y[1] ...  y[N-1], with 0 the most significant bit.
  The BDD is built bottom-up.
  It has 3*N-1 internal nodes, if the variables are ordered as follows:
  x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
  Argument z is not used by Cudd_Xgty: it is included to make it
  call-compatible to Cudd_Dxygtdxz and Cudd_Dxygtdyz.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
<a href="#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addAgreement"></A>
DdNode * <I></I>
<B>Cudd_addAgreement</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Returns NULL if not a terminal case; f op g otherwise,
  where f op g is f if f==g; background if f!=g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addApply"></A>
DdNode * <I></I>
<B>Cudd_addApply</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_AOP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Applies op to the corresponding discriminants of f and g.
  Returns a pointer to the result if succssful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addMonadicApply">Cudd_addMonadicApply</a>
<a href="#Cudd_addPlus">Cudd_addPlus</a>
<a href="#Cudd_addTimes">Cudd_addTimes</a>
<a href="#Cudd_addThreshold">Cudd_addThreshold</a>
<a href="#Cudd_addSetNZ">Cudd_addSetNZ</a>
<a href="#Cudd_addDivide">Cudd_addDivide</a>
<a href="#Cudd_addMinus">Cudd_addMinus</a>
<a href="#Cudd_addMinimum">Cudd_addMinimum</a>
<a href="#Cudd_addMaximum">Cudd_addMaximum</a>
<a href="#Cudd_addOneZeroMaximum">Cudd_addOneZeroMaximum</a>
<a href="#Cudd_addDiff">Cudd_addDiff</a>
<a href="#Cudd_addAgreement">Cudd_addAgreement</a>
<a href="#Cudd_addOr">Cudd_addOr</a>
<a href="#Cudd_addNand">Cudd_addNand</a>
<a href="#Cudd_addNor">Cudd_addNor</a>
<a href="#Cudd_addXor">Cudd_addXor</a>
<a href="#Cudd_addXnor">Cudd_addXnor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addBddInterval"></A>
DdNode * <I></I>
<B>Cudd_addBddInterval</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE  <b>lower</b>, <i></i>
  CUDD_VALUE_TYPE  <b>upper</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all
  discriminants greater than or equal to lower and less than or equal to
  upper with 1, and all other discriminants with 0. Returns a pointer to
  the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
<a href="#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
<a href="#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="#Cudd_BddToAdd">Cudd_BddToAdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addBddIthBit"></A>
DdNode * <I></I>
<B>Cudd_addBddIthBit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>bit</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all
  discriminants whose i-th bit is equal to 1 with 1, and all other
  discriminants with 0. The i-th bit refers to the integer
  representation of the leaf value. If the value is has a fractional
  part, it is ignored. Repeated calls to this procedure allow one to
  transform an integer-valued ADD into an array of BDDs, one for each
  bit of the leaf values. Returns a pointer to the resulting BDD if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="#Cudd_BddToAdd">Cudd_BddToAdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addBddPattern"></A>
DdNode * <I></I>
<B>Cudd_addBddPattern</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all
  discriminants different from 0 with 1. Returns a pointer to the
  resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_BddToAdd">Cudd_BddToAdd</a>
<a href="#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
<a href="#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addBddStrictThreshold"></A>
DdNode * <I></I>
<B>Cudd_addBddStrictThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all
  discriminants STRICTLY greater than value with 1, and all other
  discriminants with 0. Returns a pointer to the resulting BDD if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="#Cudd_BddToAdd">Cudd_BddToAdd</a>
<a href="#Cudd_addBddThreshold">Cudd_addBddThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addBddThreshold"></A>
DdNode * <I></I>
<B>Cudd_addBddThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Converts an ADD to a BDD by replacing all
  discriminants greater than or equal to value with 1, and all other
  discriminants with 0. Returns a pointer to the resulting BDD if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addBddInterval">Cudd_addBddInterval</a>
<a href="#Cudd_addBddPattern">Cudd_addBddPattern</a>
<a href="#Cudd_BddToAdd">Cudd_BddToAdd</a>
<a href="#Cudd_addBddStrictThreshold">Cudd_addBddStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addCmpl"></A>
DdNode * <I></I>
<B>Cudd_addCmpl</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Computes the complement of an ADD a la C language: The
  complement of 0 is 1 and the complement of everything else is 0.
  Returns a pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addNegate">Cudd_addNegate</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addCompose"></A>
DdNode * <I></I>
<B>Cudd_addCompose</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int  <b>v</b> <i></i>
)
</pre>
<dd> Substitutes g for x_v in the ADD for f. v is the index of the
  variable to be substituted. g must be a 0-1 ADD. Cudd_bddCompose passes
  the corresponding projection function to the recursive procedure, so
  that the cache may be used.  Returns the composed ADD if successful;
  NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCompose">Cudd_bddCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addComputeCube"></A>
DdNode * <I></I>
<B>Cudd_addComputeCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>vars</b>, <i></i>
  int * <b>phase</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Computes the cube of an array of ADD variables.  If
  non-null, the phase argument indicates which literal of each
  variable should appear in the cube. If phase[i] is nonzero, then the
  positive literal is used. If phase is NULL, the cube is positive unate.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddComputeCube">Cudd_bddComputeCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addConstrain"></A>
DdNode * <I></I>
<B>Cudd_addConstrain</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Computes f constrain c (f @ c), for f an ADD and c a 0-1
  ADD.  List of special cases:
    <ul>
    <li> F @ 0 = 0
    <li> F @ 1 = F
    <li> 0 @ c = 0
    <li> 1 @ c = 1
    <li> F @ F = 1
    </ul>
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addConst"></A>
DdNode * <I></I>
<B>Cudd_addConst</B>(
  DdManager * <b>dd</b>, <i></i>
  CUDD_VALUE_TYPE  <b>c</b> <i></i>
)
</pre>
<dd> Retrieves the ADD for constant c if it already
  exists, or creates a new ADD.  Returns a pointer to the
  ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="#Cudd_addIthVar">Cudd_addIthVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addDiff"></A>
DdNode * <I></I>
<B>Cudd_addDiff</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Returns NULL if not a terminal case; f op g otherwise,
  where f op g is plusinfinity if f=g; min(f,g) if f!=g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addDivide"></A>
DdNode * <I></I>
<B>Cudd_addDivide</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point division. Returns NULL if not
  a terminal case; f / g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addEvalConst"></A>
DdNode * <I></I>
<B>Cudd_addEvalConst</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Checks whether ADD g is constant whenever ADD f is 1.  f
  must be a 0-1 ADD.  Returns a pointer to the resulting ADD (which may
  or may not be constant) or DD_NON_CONSTANT. If f is identically 0,
  the check is assumed to be successful, and the background value is
  returned. No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="#Cudd_addLeq">Cudd_addLeq</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addExistAbstract"></A>
DdNode * <I></I>
<B>Cudd_addExistAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Abstracts all the variables in cube from f by summing
  over all possible values taken by the variables. Returns the
  abstracted ADD.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addUnivAbstract">Cudd_addUnivAbstract</a>
<a href="#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="#Cudd_addOrAbstract">Cudd_addOrAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addFindMax"></A>
DdNode * <I></I>
<B>Cudd_addFindMax</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns a pointer to a constant ADD.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddFind.c"TARGET="ABSTRACT"><CODE>cuddAddFind.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addFindMin"></A>
DdNode * <I></I>
<B>Cudd_addFindMin</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns a pointer to a constant ADD.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddFind.c"TARGET="ABSTRACT"><CODE>cuddAddFind.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addGeneralVectorCompose"></A>
DdNode * <I></I>
<B>Cudd_addGeneralVectorCompose</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vectorOn</b>, <i></i>
  DdNode ** <b>vectorOff</b> <i></i>
)
</pre>
<dd> Given a vector of ADDs, creates a new ADD by substituting the
  ADDs for the variables of the ADD f. vectorOn contains ADDs to be substituted
  for the x_v and vectorOff the ADDs to be substituted for x_v'. There should
  be an entry in vector for each variable in the manager.  If no substitution
  is sought for a given variable, the corresponding projection function should
  be specified in the vector.  This function implements simultaneous
  composition.  Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addVectorCompose">Cudd_addVectorCompose</a>
<a href="#Cudd_addNonSimCompose">Cudd_addNonSimCompose</a>
<a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#Cudd_addCompose">Cudd_addCompose</a>
<a href="#Cudd_bddVectorCompose">Cudd_bddVectorCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addHamming"></A>
DdNode * <I></I>
<B>Cudd_addHamming</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>xVars</b>, <i></i>
  DdNode ** <b>yVars</b>, <i></i>
  int  <b>nVars</b> <i></i>
)
</pre>
<dd> Computes the Hamming distance ADD. Returns an ADD that
  gives the Hamming distance between its two arguments if successful;
  NULL otherwise. The two vectors xVars and yVars identify the variables
  that form the two arguments.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addHarwell"></A>
int <I></I>
<B>Cudd_addHarwell</B>(
  FILE * <b>fp</b>, <i>pointer to the input file</i>
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode ** <b>E</b>, <i>characteristic function of the graph</i>
  DdNode *** <b>x</b>, <i>array of row variables</i>
  DdNode *** <b>y</b>, <i>array of column variables</i>
  DdNode *** <b>xn</b>, <i>array of complemented row variables</i>
  DdNode *** <b>yn_</b>, <i>array of complemented column variables</i>
  int * <b>nx</b>, <i>number or row variables</i>
  int * <b>ny</b>, <i>number or column variables</i>
  int * <b>m</b>, <i>number of rows</i>
  int * <b>n</b>, <i>number of columns</i>
  int  <b>bx</b>, <i>first index of row variables</i>
  int  <b>sx</b>, <i>step of row variables</i>
  int  <b>by</b>, <i>first index of column variables</i>
  int  <b>sy</b>, <i>step of column variables</i>
  int  <b>pr</b> <i>verbosity level</i>
)
</pre>
<dd> Reads in a matrix in the format of the Harwell-Boeing
  benchmark suite. The variables are ordered as follows:
  <blockquote>
  x[0] y[0] x[1] y[1] ...
  </blockquote>
  0 is the most significant bit.  On input, nx and ny hold the numbers
  of row and column variables already in existence. On output, they
  hold the numbers of row and column variables actually used by the
  matrix.  m and n are set to the numbers of rows and columns of the
  matrix.  Their values on input are immaterial.  Returns 1 on
  success; 0 otherwise. The ADD for the sparse matrix is returned in
  E, and its reference count is > 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addRead">Cudd_addRead</a>
<a href="#Cudd_bddRead">Cudd_bddRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddHarwell.c"TARGET="ABSTRACT"><CODE>cuddHarwell.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addIteConstant"></A>
DdNode * <I></I>
<B>Cudd_addIteConstant</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITEconstant for ADDs.  f must be a 0-1 ADD.
  Returns a pointer to the resulting ADD (which may or may not be
  constant) or DD_NON_CONSTANT. No new nodes are created. This function
  can be used, for instance, to check that g has a constant value
  (specified by h) whenever f is 1. If the constant value is unknown,
  then one should use Cudd_addEvalConst.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addIte">Cudd_addIte</a>
<a href="#Cudd_addEvalConst">Cudd_addEvalConst</a>
<a href="#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addIte"></A>
DdNode * <I></I>
<B>Cudd_addIte</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITE(f,g,h). This procedure assumes that f is
  a 0-1 ADD.  Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addIthBit"></A>
DdNode * <I></I>
<B>Cudd_addIthBit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>bit</b> <i></i>
)
</pre>
<dd> Produces an ADD from another ADD by replacing all
  discriminants whose i-th bit is equal to 1 with 1, and all other
  discriminants with 0. The i-th bit refers to the integer
  representation of the leaf value. If the value is has a fractional
  part, it is ignored. Repeated calls to this procedure allow one to
  transform an integer-valued ADD into an array of ADDs, one for each
  bit of the leaf values. Returns a pointer to the resulting ADD if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addBddIthBit">Cudd_addBddIthBit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddFind.c"TARGET="ABSTRACT"><CODE>cuddAddFind.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addIthVar"></A>
DdNode * <I></I>
<B>Cudd_addIthVar</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Retrieves the ADD variable with index i if it already
  exists, or creates a new ADD variable.  Returns a pointer to the
  variable if successful; NULL otherwise.  An ADD variable differs from
  a BDD variable because it points to the arithmetic zero, instead of
  having a complement pointer to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="#Cudd_addConst">Cudd_addConst</a>
<a href="#Cudd_addNewVarAtLevel">Cudd_addNewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addLeq"></A>
int <I></I>
<B>Cudd_addLeq</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns 1 if f is less than or equal to g; 0 otherwise.
  No new nodes are created. This procedure works for arbitrary ADDs.
  For 0-1 ADDs Cudd_addEvalConst is more efficient.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addIteConstant">Cudd_addIteConstant</a>
<a href="#Cudd_addEvalConst">Cudd_addEvalConst</a>
<a href="#Cudd_bddLeq">Cudd_bddLeq</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addLog"></A>
DdNode * <I></I>
<B>Cudd_addLog</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Natural logarithm of an ADDs. Returns NULL
  if not a terminal case; log(f) otherwise.  The discriminants of f must
  be positive double's.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addMonadicApply">Cudd_addMonadicApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addMatrixMultiply"></A>
DdNode * <I></I>
<B>Cudd_addMatrixMultiply</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>A</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  DdNode ** <b>z</b>, <i></i>
  int  <b>nz</b> <i></i>
)
</pre>
<dd> Calculates the product of two matrices, A and B,
  represented as ADDs. This procedure implements the quasiring multiplication
  algorithm.  A is assumed to depend on variables x (rows) and z
  (columns).  B is assumed to depend on variables z (rows) and y
  (columns).  The product of A and B then depends on x (rows) and y
  (columns).  Only the z variables have to be explicitly identified;
  they are the "summation" variables.  Returns a pointer to the
  result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addTimesPlus">Cudd_addTimesPlus</a>
<a href="#Cudd_addTriangle">Cudd_addTriangle</a>
<a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addMaximum"></A>
DdNode * <I></I>
<B>Cudd_addMaximum</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point max for Cudd_addApply.
  Returns NULL if not a terminal case; max(f,g) otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addMinimum"></A>
DdNode * <I></I>
<B>Cudd_addMinimum</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point min for Cudd_addApply.
  Returns NULL if not a terminal case; min(f,g) otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addMinus"></A>
DdNode * <I></I>
<B>Cudd_addMinus</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point subtraction. Returns NULL if
  not a terminal case; f - g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addMonadicApply"></A>
DdNode * <I></I>
<B>Cudd_addMonadicApply</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_MAOP  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Applies op to the discriminants of f.
  Returns a pointer to the result if succssful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_addLog">Cudd_addLog</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addNand"></A>
DdNode * <I></I>
<B>Cudd_addNand</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> NAND of two 0-1 ADDs. Returns NULL
  if not a terminal case; f NAND g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addNegate"></A>
DdNode * <I></I>
<B>Cudd_addNegate</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Computes the additive inverse of an ADD. Returns a pointer
  to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addCmpl">Cudd_addCmpl</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddNeg.c"TARGET="ABSTRACT"><CODE>cuddAddNeg.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addNewVarAtLevel"></A>
DdNode * <I></I>
<B>Cudd_addNewVarAtLevel</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Creates a new ADD variable.  The new variable has an
  index equal to the largest previous index plus 1 and is positioned at
  the specified level in the order.  Returns a pointer to the new
  variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="#Cudd_addIthVar">Cudd_addIthVar</a>
<a href="#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addNewVar"></A>
DdNode * <I></I>
<B>Cudd_addNewVar</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Creates a new ADD variable.  The new variable has an
  index equal to the largest previous index plus 1.  Returns a
  pointer to the new variable if successful; NULL otherwise.
  An ADD variable differs from a BDD variable because it points to the
  arithmetic zero, instead of having a complement pointer to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="#Cudd_addIthVar">Cudd_addIthVar</a>
<a href="#Cudd_addConst">Cudd_addConst</a>
<a href="#Cudd_addNewVarAtLevel">Cudd_addNewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addNonSimCompose"></A>
DdNode * <I></I>
<B>Cudd_addNonSimCompose</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b> <i></i>
)
</pre>
<dd> Given a vector of 0-1 ADDs, creates a new ADD by
  substituting the 0-1 ADDs for the variables of the ADD f.  There
  should be an entry in vector for each variable in the manager.
  This function implements non-simultaneous composition. If any of the
  functions being composed depends on any of the variables being
  substituted, then the result depends on the order of composition,
  which in turn depends on the variable order: The variables farther from
  the roots in the order are substituted first.
  Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addVectorCompose">Cudd_addVectorCompose</a>
<a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#Cudd_addCompose">Cudd_addCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addNor"></A>
DdNode * <I></I>
<B>Cudd_addNor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> NOR of two 0-1 ADDs. Returns NULL
  if not a terminal case; f NOR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addOneZeroMaximum"></A>
DdNode * <I></I>
<B>Cudd_addOneZeroMaximum</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Returns 1 if f &gt; g and 0 otherwise. Used in
  conjunction with Cudd_addApply. Returns NULL if not a terminal
  case.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addOrAbstract"></A>
DdNode * <I></I>
<B>Cudd_addOrAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Abstracts all the variables in cube from the 0-1 ADD f
  by taking the disjunction over all possible values taken by the
  variables.  Returns the abstracted ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addUnivAbstract">Cudd_addUnivAbstract</a>
<a href="#Cudd_addExistAbstract">Cudd_addExistAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addOr"></A>
DdNode * <I></I>
<B>Cudd_addOr</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Disjunction of two 0-1 ADDs. Returns NULL
  if not a terminal case; f OR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addOuterSum"></A>
DdNode * <I></I>
<B>Cudd_addOuterSum</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>M</b>, <i></i>
  DdNode * <b>r</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Takes the pointwise minimum of a matrix and the outer
  sum of two vectors.  This procedure is used in the Floyd-Warshall
  all-pair shortest path algorithm.  Returns a pointer to the result if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addPermute"></A>
DdNode * <I></I>
<B>Cudd_addPermute</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int * <b>permut</b> <i></i>
)
</pre>
<dd> Given a permutation in array permut, creates a new ADD
  with permuted variables. There should be an entry in array permut
  for each variable in the manager. The i-th entry of permut holds the
  index of the variable that is to substitute the i-th
  variable. Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#Cudd_addSwapVariables">Cudd_addSwapVariables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addPlus"></A>
DdNode * <I></I>
<B>Cudd_addPlus</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point addition. Returns NULL if not
  a terminal case; f+g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addRead"></A>
int <I></I>
<B>Cudd_addRead</B>(
  FILE * <b>fp</b>, <i>input file pointer</i>
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode ** <b>E</b>, <i>characteristic function of the graph</i>
  DdNode *** <b>x</b>, <i>array of row variables</i>
  DdNode *** <b>y</b>, <i>array of column variables</i>
  DdNode *** <b>xn</b>, <i>array of complemented row variables</i>
  DdNode *** <b>yn_</b>, <i>array of complemented column variables</i>
  int * <b>nx</b>, <i>number or row variables</i>
  int * <b>ny</b>, <i>number or column variables</i>
  int * <b>m</b>, <i>number of rows</i>
  int * <b>n</b>, <i>number of columns</i>
  int  <b>bx</b>, <i>first index of row variables</i>
  int  <b>sx</b>, <i>step of row variables</i>
  int  <b>by</b>, <i>first index of column variables</i>
  int  <b>sy</b> <i>step of column variables</i>
)
</pre>
<dd> Reads in a sparse matrix specified in a simple format.
  The first line of the input contains the numbers of rows and columns.
  The remaining lines contain the elements of the matrix, one per line.
  Given a background value
  (specified by the background field of the manager), only the values
  different from it are explicitly listed.  Each foreground element is
  described by two integers, i.e., the row and column number, and a
  real number, i.e., the value.<p>
  Cudd_addRead produces an ADD that depends on two sets of variables: x
  and y.  The x variables (x[0] ... x[nx-1]) encode the row index and
  the y variables (y[0] ... y[ny-1]) encode the column index.
  x[0] and y[0] are the most significant bits in the indices.
  The variables may already exist or may be created by the function.
  The index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.<p>
  On input, nx and ny hold the numbers
  of row and column variables already in existence. On output, they
  hold the numbers of row and column variables actually used by the
  matrix. When Cudd_addRead creates the variable arrays,
  the index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.
  When some variables already exist Cudd_addRead expects the indices
  of the existing x variables to be bx+i*sx, and the indices of the
  existing y variables to be by+i*sy.<p>
  m and n are set to the numbers of rows and columns of the
  matrix.  Their values on input are immaterial.
  The ADD for the
  sparse matrix is returned in E, and its reference count is > 0.
  Cudd_addRead returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> nx and ny are set to the numbers of row and column
  variables. m and n are set to the numbers of rows and columns. x and y
  are possibly extended to represent the array of row and column
  variables. Similarly for xn and yn_, which hold on return from
  Cudd_addRead the complements of the row and column variables.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addHarwell">Cudd_addHarwell</a>
<a href="#Cudd_bddRead">Cudd_bddRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRead.c"TARGET="ABSTRACT"><CODE>cuddRead.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addResidue"></A>
DdNode * <I></I>
<B>Cudd_addResidue</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of bits</i>
  int  <b>m</b>, <i>modulus</i>
  int  <b>options</b>, <i>options</i>
  int  <b>top</b> <i>index of top variable</i>
)
</pre>
<dd> Builds an ADD for the residue modulo m of an n-bit
  number. The modulus must be at least 2, and the number of bits at
  least 1. Parameter options specifies whether the MSB should be on top
  or the LSB; and whther the number whose residue is computed is in
  two's complement notation or not. The macro CUDD_RESIDUE_DEFAULT
  specifies LSB on top and unsigned number. The macro CUDD_RESIDUE_MSB
  specifies MSB on top, and the macro CUDD_RESIDUE_TC specifies two's
  complement residue. To request MSB on top and two's complement residue
  simultaneously, one can OR the two macros:
  CUDD_RESIDUE_MSB | CUDD_RESIDUE_TC.
  Cudd_addResidue returns a pointer to the resulting ADD if successful;
  NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddWalsh.c"TARGET="ABSTRACT"><CODE>cuddAddWalsh.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addRestrict"></A>
DdNode * <I></I>
<B>Cudd_addRestrict</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> ADD restrict according to Coudert and Madre's algorithm
  (ICCAD90). Returns the restricted ADD if successful; otherwise NULL.
  If application of restrict results in an ADD larger than the input
  ADD, the input ADD is returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addConstrain">Cudd_addConstrain</a>
<a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addRoundOff"></A>
DdNode * <I></I>
<B>Cudd_addRoundOff</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>N</b> <i></i>
)
</pre>
<dd> Rounds off the discriminants of an ADD. The discriminants are
  rounded off to N digits after the decimal. Returns a pointer to the result
  ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddNeg.c"TARGET="ABSTRACT"><CODE>cuddAddNeg.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addScalarInverse"></A>
DdNode * <I></I>
<B>Cudd_addScalarInverse</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>epsilon</b> <i></i>
)
</pre>
<dd> Computes an n ADD where the discriminants are the
  multiplicative inverses of the corresponding discriminants of the
  argument ADD.  Returns a pointer to the resulting ADD in case of
  success. Returns NULL if any discriminants smaller than epsilon is
  encountered.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddInv.c"TARGET="ABSTRACT"><CODE>cuddAddInv.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addSetNZ"></A>
DdNode * <I></I>
<B>Cudd_addSetNZ</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> This operator sets f to the value of g wherever g != 0.
  Returns NULL if not a terminal case; f op g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addSwapVariables"></A>
DdNode * <I></I>
<B>Cudd_addSwapVariables</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Swaps two sets of variables of the same size (x and y) in
  the ADD f.  The size is given by n. The two sets of variables are
  assumed to be disjoint. Returns a pointer to the resulting ADD if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addThreshold"></A>
DdNode * <I></I>
<B>Cudd_addThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Threshold operator for Apply (f if f &gt;=g; 0 if f&lt;g).
  Returns NULL if not a terminal case; f op g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addTimesPlus"></A>
DdNode * <I></I>
<B>Cudd_addTimesPlus</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>A</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  DdNode ** <b>z</b>, <i></i>
  int  <b>nz</b> <i></i>
)
</pre>
<dd> Calculates the product of two matrices, A and B,
  represented as ADDs, using the CMU matrix by matrix multiplication
  procedure by Clarke et al..  Matrix A has x's as row variables and z's
  as column variables, while matrix B has z's as row variables and y's
  as column variables. Returns the pointer to the result if successful;
  NULL otherwise. The resulting matrix has x's as row variables and y's
  as column variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addMatrixMultiply">Cudd_addMatrixMultiply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addTimes"></A>
DdNode * <I></I>
<B>Cudd_addTimes</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> Integer and floating point multiplication. Returns NULL
  if not a terminal case; f * g otherwise.  This function can be used also
  to take the AND of two 0-1 ADDs.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addTriangle"></A>
DdNode * <I></I>
<B>Cudd_addTriangle</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode ** <b>z</b>, <i></i>
  int  <b>nz</b> <i></i>
)
</pre>
<dd> Implements the semiring multiplication algorithm used in
  the triangulation step for the shortest path computation.  f
  is assumed to depend on variables x (rows) and z (columns).  g is
  assumed to depend on variables z (rows) and y (columns).  The product
  of f and g then depends on x (rows) and y (columns).  Only the z
  variables have to be explicitly identified; they are the
  "abstraction" variables.  Returns a pointer to the result if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addMatrixMultiply">Cudd_addMatrixMultiply</a>
<a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addUnivAbstract"></A>
DdNode * <I></I>
<B>Cudd_addUnivAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Abstracts all the variables in cube from f by taking
  the product over all possible values taken by the variable. Returns
  the abstracted ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addExistAbstract">Cudd_addExistAbstract</a>
<a href="#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
<a href="#Cudd_addOrAbstract">Cudd_addOrAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addVectorCompose"></A>
DdNode * <I></I>
<B>Cudd_addVectorCompose</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b> <i></i>
)
</pre>
<dd> Given a vector of 0-1 ADDs, creates a new ADD by
  substituting the 0-1 ADDs for the variables of the ADD f.  There
  should be an entry in vector for each variable in the manager.
  If no substitution is sought for a given variable, the corresponding
  projection function should be specified in the vector.
  This function implements simultaneous composition.
  Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addNonSimCompose">Cudd_addNonSimCompose</a>
<a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#Cudd_addCompose">Cudd_addCompose</a>
<a href="#Cudd_bddVectorCompose">Cudd_bddVectorCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addWalsh"></A>
DdNode * <I></I>
<B>Cudd_addWalsh</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Generates a Walsh matrix in ADD form. Returns a pointer
  to the matrixi if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddWalsh.c"TARGET="ABSTRACT"><CODE>cuddAddWalsh.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addXeqy"></A>
DdNode * <I></I>
<B>Cudd_addXeqy</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x and y variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  DdNode ** <b>y</b> <i>array of y variables</i>
)
</pre>
<dd> This function generates an ADD for the function x==y.
  Both x and y are N-bit numbers, x[0] x[1] ... x[N-1] and
  y[0] y[1] ...  y[N-1], with 0 the most significant bit.
  The ADD is built bottom-up.
  It has 3*N-1 internal nodes, if the variables are ordered as follows:
  x[0] y[0] x[1] y[1] ... x[N-1] y[N-1].
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Xeqy">Cudd_Xeqy</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addXnor"></A>
DdNode * <I></I>
<B>Cudd_addXnor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> XNOR of two 0-1 ADDs. Returns NULL
  if not a terminal case; f XNOR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_addXor"></A>
DdNode * <I></I>
<B>Cudd_addXor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>f</b>, <i></i>
  DdNode ** <b>g</b> <i></i>
)
</pre>
<dd> XOR of two 0-1 ADDs. Returns NULL
  if not a terminal case; f XOR g otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addApply">Cudd_addApply</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddAdjPermuteX"></A>
DdNode * <I></I>
<B>Cudd_bddAdjPermuteX</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Rearranges a set of variables in the BDD B. The size of
  the set is given by n. This procedure is intended for the
  `randomization' of the priority functions. Returns a pointer to the
  BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
<a href="#Cudd_Dxygtdxz">Cudd_Dxygtdxz</a>
<a href="#Cudd_Dxygtdyz">Cudd_Dxygtdyz</a>
<a href="#Cudd_PrioritySelect">Cudd_PrioritySelect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddAndAbstractLimit"></A>
DdNode * <I></I>
<B>Cudd_bddAndAbstractLimit</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  unsigned int  <b>limit</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.
  Returns a pointer to the result is successful; NULL otherwise.
  In particular, if the number of new nodes created exceeds
  <code>limit</code>, this function returns NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAndAbs.c"TARGET="ABSTRACT"><CODE>cuddAndAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddAndAbstract"></A>
DdNode * <I></I>
<B>Cudd_bddAndAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.
  Returns a pointer to the result is successful; NULL otherwise.
  Cudd_bddAndAbstract implements the semiring matrix multiplication
  algorithm for the boolean semiring.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addMatrixMultiply">Cudd_addMatrixMultiply</a>
<a href="#Cudd_addTriangle">Cudd_addTriangle</a>
<a href="#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAndAbs.c"TARGET="ABSTRACT"><CODE>cuddAndAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddAndLimit"></A>
DdNode * <I></I>
<B>Cudd_bddAndLimit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  unsigned int  <b>limit</b> <i></i>
)
</pre>
<dd> Computes the conjunction of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up or more new nodes than <code>limit</code> are
  required.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddAnd"></A>
DdNode * <I></I>
<B>Cudd_bddAnd</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the conjunction of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
<a href="#Cudd_bddIntersect">Cudd_bddIntersect</a>
<a href="#Cudd_bddOr">Cudd_bddOr</a>
<a href="#Cudd_bddNand">Cudd_bddNand</a>
<a href="#Cudd_bddNor">Cudd_bddNor</a>
<a href="#Cudd_bddXor">Cudd_bddXor</a>
<a href="#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddApproxConjDecomp"></A>
int <I></I>
<B>Cudd_bddApproxConjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the first factor</i>
)
</pre>
<dd> Performs two-way conjunctive decomposition of a
  BDD. This procedure owes its name to the use of supersetting to
  obtain an initial factor of the given function. Returns the number
  of conjuncts produced, that is, 2 if successful; 1 if no meaningful
  decomposition was found; 0 otherwise. The conjuncts produced by this
  procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
<a href="#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
<a href="#Cudd_RemapOverApprox">Cudd_RemapOverApprox</a>
<a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
<a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddApproxDisjDecomp"></A>
int <I></I>
<B>Cudd_bddApproxDisjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD.
  Returns the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise. The
  disjuncts produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
<a href="#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddBindVar"></A>
int <I></I>
<B>Cudd_bddBindVar</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> This function sets a flag to prevent sifting of a
  variable.  Returns 1 if successful; 0 otherwise (i.e., invalid
  variable index).
<p>

<dd> <b>Side Effects</b> Changes the "bindVar" flag in DdSubtable.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddUnbindVar">Cudd_bddUnbindVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddBooleanDiff"></A>
DdNode * <I></I>
<B>Cudd_bddBooleanDiff</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Computes the boolean difference of f with respect to the
  variable with index x.  Returns the BDD of the boolean difference if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddCharToVect"></A>
DdNode ** <I></I>
<B>Cudd_bddCharToVect</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Computes a vector of BDDs whose image equals a non-zero
  function.
  The result depends on the variable order. The i-th component of the vector
  depends only on the first i variables in the order.  Each BDD in the vector
  is not larger than the BDD of the given characteristic function.  This
  function is based on the description of char-to-vect in "Verification of
  Sequential Machines Using Boolean Functional Vectors" by O. Coudert, C.
  Berthet and J. C. Madre.
  Returns a pointer to an array containing the result if successful; NULL
  otherwise. The size of the array equals the number of variables in the
  manager. The components of the solution have their reference counts 
  already incremented (unlike the results of most other functions in 
  the package).
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddClippingAndAbstract"></A>
DdNode * <I></I>
<B>Cudd_bddClippingAndAbstract</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  DdNode * <b>cube</b>, <i>cube of variables to be abstracted</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g and
  simultaneously abstracts the variables in cube. The variables are
  existentially abstracted. Returns a pointer to the resulting BDD if
  successful; NULL if the intermediate result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
<a href="#Cudd_bddClippingAnd">Cudd_bddClippingAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddClippingAnd"></A>
DdNode * <I></I>
<B>Cudd_bddClippingAnd</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddClosestCube"></A>
DdNode * <I></I>
<B>Cudd_bddClosestCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int * <b>distance</b> <i></i>
)
</pre>
<dd> Finds a cube of f at minimum Hamming distance from the
  minterms of g.  All the minterms of the cube are at the minimum
  distance.  If the distance is 0, the cube belongs to the
  intersection of f and g.  Returns the cube if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> The distance is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MinHammingDist">Cudd_MinHammingDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddCompose"></A>
DdNode * <I></I>
<B>Cudd_bddCompose</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int  <b>v</b> <i></i>
)
</pre>
<dd> Substitutes g for x_v in the BDD for f. v is the index of the
  variable to be substituted. Cudd_bddCompose passes the corresponding
  projection function to the recursive procedure, so that the cache may
  be used.  Returns the composed BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addCompose">Cudd_addCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddComputeCube"></A>
DdNode * <I></I>
<B>Cudd_bddComputeCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>vars</b>, <i></i>
  int * <b>phase</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Computes the cube of an array of BDD variables. If
  non-null, the phase argument indicates which literal of each
  variable should appear in the cube. If phase[i] is nonzero, then the
  positive literal is used. If phase is NULL, the cube is positive unate.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addComputeCube">Cudd_addComputeCube</a>
<a href="#Cudd_IndicesToCube">Cudd_IndicesToCube</a>
<a href="#Cudd_CubeArrayToBdd">Cudd_CubeArrayToBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddConstrainDecomp"></A>
DdNode ** <I></I>
<B>Cudd_bddConstrainDecomp</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> BDD conjunctive decomposition as in McMillan's CAV96
  paper.  The decomposition is canonical only for a given variable
  order. If canonicity is required, variable ordering must be disabled
  after the decomposition has been computed. Returns an array with one
  entry for each BDD variable in the manager if successful; otherwise
  NULL. The components of the solution have their reference counts
  already incremented (unlike the results of most other functions in
  the package.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddConstrain"></A>
DdNode * <I></I>
<B>Cudd_bddConstrain</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Computes f constrain c (f @ c).
  Uses a canonical form: (f' @ c) = ( f @ c)'.  (Note: this is not true
  for c.)  List of special cases:
    <ul>
    <li> f @ 0 = 0
    <li> f @ 1 = f
    <li> 0 @ c = 0
    <li> 1 @ c = 1
    <li> f @ f = 1
    <li> f @ f'= 0
    </ul>
  Returns a pointer to the result if successful; NULL otherwise. Note that if
  F=(f1,...,fn) and reordering takes place while computing F @ c, then the
  image restriction property (Img(F,c) = Img(F @ c)) is lost.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
<a href="#Cudd_addConstrain">Cudd_addConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddCorrelationWeights"></A>
double <I></I>
<B>Cudd_bddCorrelationWeights</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  double * <b>prob</b> <i></i>
)
</pre>
<dd> Computes the correlation of f and g for given input
  probabilities. On input, prob[i] is supposed to contain the
  probability of the i-th input variable to be 1.
  If f == g, their correlation is 1. If f == g', their
  correlation is 0.  Returns the probability that f and g have the same
  value. If it runs out of memory, returns (double)CUDD_OUT_OF_MEM. The
  correlation of f and the constant one gives the probability of f.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCorrelation">Cudd_bddCorrelation</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddCorrelation"></A>
double <I></I>
<B>Cudd_bddCorrelation</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the correlation of f and g. If f == g, their
  correlation is 1. If f == g', their correlation is 0.  Returns the
  fraction of minterms in the ON-set of the EXNOR of f and g.  If it
  runs out of memory, returns (double)CUDD_OUT_OF_MEM.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCorrelationWeights">Cudd_bddCorrelationWeights</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddExistAbstract"></A>
DdNode * <I></I>
<B>Cudd_bddExistAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Existentially abstracts all the variables in cube from f.
  Returns the abstracted BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
<a href="#Cudd_addExistAbstract">Cudd_addExistAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddGenConjDecomp"></A>
int <I></I>
<B>Cudd_bddGenConjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the array of conjuncts</i>
)
</pre>
<dd> Performs two-way conjunctive decomposition of a
  BDD. This procedure owes its name to the fact tht it generalizes the
  decomposition based on the cofactors with respect to one
  variable. Returns the number of conjuncts produced, that is, 2 if
  successful; 1 if no meaningful decomposition was found; 0
  otherwise. The conjuncts produced by this procedure tend to be
  balanced.
<p>

<dd> <b>Side Effects</b> The two factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
<a href="#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
<a href="#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddGenDisjDecomp"></A>
int <I></I>
<B>Cudd_bddGenDisjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD.
  Returns the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise. The
  disjuncts produced by this procedure tend to be balanced.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIntersect"></A>
DdNode * <I></I>
<B>Cudd_bddIntersect</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first operand</i>
  DdNode * <b>g</b> <i>second operand</i>
)
</pre>
<dd> Computes a function included in the intersection of f and
  g. (That is, a witness that the intersection is not empty.)
  Cudd_bddIntersect tries to build as few new nodes as possible. If the
  only result of interest is whether f and g intersect,
  Cudd_bddLeq should be used instead.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddInterval"></A>
DdNode * <I></I>
<B>Cudd_bddInterval</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>N</b>, <i>number of x variables</i>
  DdNode ** <b>x</b>, <i>array of x variables</i>
  unsigned int  <b>lowerB</b>, <i>lower bound</i>
  unsigned int  <b>upperB</b> <i>upper bound</i>
)
</pre>
<dd> This function generates a BDD for the function
  lowerB &le; x &le; upperB, where x is an N-bit number,
  x[0] x[1] ... x[N-1], with 0 the most significant bit (important!).
  The number of variables N should be sufficient to represent the bounds;
  otherwise, the bounds are truncated to their N least significant bits.
  Two BDDs are built bottom-up for lowerB &le; x and x &le; upperB, and they
  are finally conjoined.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Xgty">Cudd_Xgty</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsNsVar"></A>
int <I></I>
<B>Cudd_bddIsNsVar</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is next state.  Returns 1 if
  the variable's type is present state; 0 if the variable exists but is
  not a present state; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetNsVar">Cudd_bddSetNsVar</a>
<a href="#Cudd_bddIsPiVar">Cudd_bddIsPiVar</a>
<a href="#Cudd_bddIsPsVar">Cudd_bddIsPsVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsPiVar"></A>
int <I></I>
<B>Cudd_bddIsPiVar</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Checks whether a variable is primary input.  Returns 1 if
  the variable's type is primary input; 0 if the variable exists but is
  not a primary input; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetPiVar">Cudd_bddSetPiVar</a>
<a href="#Cudd_bddIsPsVar">Cudd_bddIsPsVar</a>
<a href="#Cudd_bddIsNsVar">Cudd_bddIsNsVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsPsVar"></A>
int <I></I>
<B>Cudd_bddIsPsVar</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is present state.  Returns 1 if
  the variable's type is present state; 0 if the variable exists but is
  not a present state; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetPsVar">Cudd_bddSetPsVar</a>
<a href="#Cudd_bddIsPiVar">Cudd_bddIsPiVar</a>
<a href="#Cudd_bddIsNsVar">Cudd_bddIsNsVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsVarEssential"></A>
int <I></I>
<B>Cudd_bddIsVarEssential</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>id</b>, <i></i>
  int  <b>phase</b> <i></i>
)
</pre>
<dd> Determines whether a given variable is essential with a
  given phase in a BDD. Uses Cudd_bddIteConstant. Returns 1 if phase == 1
  and f-->x_id, or if phase == 0 and f-->x_id'.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FindEssential">Cudd_FindEssential</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsVarHardGroup"></A>
int <I></I>
<B>Cudd_bddIsVarHardGroup</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is set to be in a hard group.  This
  function is used for lazy sifting.  Returns 1 if the variable is marked
  to be in a hard group; 0 if the variable exists, but it is not marked to be
  in a hard group; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetVarHardGroup">Cudd_bddSetVarHardGroup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsVarToBeGrouped"></A>
int <I></I>
<B>Cudd_bddIsVarToBeGrouped</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is set to be grouped. This
  function is used for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsVarToBeUngrouped"></A>
int <I></I>
<B>Cudd_bddIsVarToBeUngrouped</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variable is set to be ungrouped. This
  function is used for lazy sifting.  Returns 1 if the variable is marked
  to be ungrouped; 0 if the variable exists, but it is not marked to be
  ungrouped; -1 if the variable does not exist.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetVarToBeUngrouped">Cudd_bddSetVarToBeUngrouped</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIsop"></A>
DdNode	* <I></I>
<B>Cudd_bddIsop</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b> <i></i>
)
</pre>
<dd> Computes a BDD in the interval between L and U with a
  simple sum-of-produuct cover. This procedure is similar to
  Cudd_zddIsop, but it does not return the ZDD for the cover. Returns
  a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddIsop">Cudd_zddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIteConstant"></A>
DdNode * <I></I>
<B>Cudd_bddIteConstant</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITEconstant(f,g,h). Returns a pointer to the
  resulting BDD (which may or may not be constant) or DD_NON_CONSTANT.
  No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_bddIntersect">Cudd_bddIntersect</a>
<a href="#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="#Cudd_addIteConstant">Cudd_addIteConstant</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIterConjDecomp"></A>
int <I></I>
<B>Cudd_bddIterConjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the array of conjuncts</i>
)
</pre>
<dd> Performs two-way conjunctive decomposition of a
  BDD. This procedure owes its name to the iterated use of
  supersetting to obtain a factor of the given function. Returns the
  number of conjuncts produced, that is, 2 if successful; 1 if no
  meaningful decomposition was found; 0 otherwise. The conjuncts
  produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
<a href="#Cudd_RemapOverApprox">Cudd_RemapOverApprox</a>
<a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
<a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIterDisjDecomp"></A>
int <I></I>
<B>Cudd_bddIterDisjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD.
  Returns the number of disjuncts produced, that is, 2 if successful;
  1 if no meaningful decomposition was found; 0 otherwise. The
  disjuncts produced by this procedure tend to be imbalanced.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
<a href="#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
<a href="#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIte"></A>
DdNode * <I></I>
<B>Cudd_bddIte</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements ITE(f,g,h). Returns a pointer to the
  resulting BDD if successful; NULL if the intermediate result blows
  up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addIte">Cudd_addIte</a>
<a href="#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
<a href="#Cudd_bddIntersect">Cudd_bddIntersect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddIthVar"></A>
DdNode * <I></I>
<B>Cudd_bddIthVar</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Retrieves the BDD variable with index i if it already
  exists, or creates a new BDD variable.  Returns a pointer to the
  variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="#Cudd_addIthVar">Cudd_addIthVar</a>
<a href="#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
<a href="#Cudd_ReadVars">Cudd_ReadVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddLICompaction"></A>
DdNode * <I></I>
<B>Cudd_bddLICompaction</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be minimized</i>
  DdNode * <b>c</b> <i>constraint (care set)</i>
)
</pre>
<dd> Performs safe minimization of a BDD. Given the BDD
  <code>f</code> of a function to be minimized and a BDD
  <code>c</code> representing the care set, Cudd_bddLICompaction
  produces the BDD of a function that agrees with <code>f</code>
  wherever <code>c</code> is 1.  Safe minimization means that the size
  of the result is guaranteed not to exceed the size of
  <code>f</code>. This function is based on the DAC97 paper by Hong et
  al..  Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddLeqUnless"></A>
int <I></I>
<B>Cudd_bddLeqUnless</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>D</b> <i></i>
)
</pre>
<dd> Tells whether f is less than of equal to G unless D is
  1.  f, g, and D are BDDs.  The function returns 1 if f is less than
  of equal to G, and 0 otherwise.  No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_EquivDC">Cudd_EquivDC</a>
<a href="#Cudd_bddLeq">Cudd_bddLeq</a>
<a href="#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddLeq"></A>
int <I></I>
<B>Cudd_bddLeq</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns 1 if f is less than or equal to g; 0 otherwise.
  No new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIteConstant">Cudd_bddIteConstant</a>
<a href="#Cudd_addEvalConst">Cudd_addEvalConst</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddLiteralSetIntersection"></A>
DdNode * <I></I>
<B>Cudd_bddLiteralSetIntersection</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the intesection of two sets of literals
  represented as BDDs. Each set is represented as a cube of the
  literals in the set. The empty set is represented by the constant 1.
  No variable can be simultaneously present in both phases in a set.
  Returns a pointer to the BDD representing the intersected sets, if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLiteral.c"TARGET="ABSTRACT"><CODE>cuddLiteral.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddMakePrime"></A>
DdNode * <I></I>
<B>Cudd_bddMakePrime</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>cube</b>, <i>cube to be expanded</i>
  DdNode * <b>f</b> <i>function of which the cube is to be made a prime</i>
)
</pre>
<dd> Expands cube to a prime implicant of f. Returns the prime
  if successful; NULL otherwise.  In particular, NULL is returned if cube
  is not a real cube or is not an implicant of f.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddMinimize"></A>
DdNode * <I></I>
<B>Cudd_bddMinimize</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Finds a small BDD that agrees with <code>f</code> over
  <code>c</code>.  Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
<a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
<a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddNPAnd"></A>
DdNode * <I></I>
<B>Cudd_bddNPAnd</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes f non-polluting-and g.  The non-polluting AND
  of f and g is a hybrid of AND and Restrict.  From Restrict, this
  operation takes the idea of existentially quantifying the top
  variable of the second operand if it does not appear in the first.
  Therefore, the variables that appear in the result also appear in f.
  For the rest, the function behaves like AND.  Since the two operands
  play different roles, non-polluting AND is not commutative.

  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddNand"></A>
DdNode * <I></I>
<B>Cudd_bddNand</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the NAND of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="#Cudd_bddOr">Cudd_bddOr</a>
<a href="#Cudd_bddNor">Cudd_bddNor</a>
<a href="#Cudd_bddXor">Cudd_bddXor</a>
<a href="#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddNewVarAtLevel"></A>
DdNode * <I></I>
<B>Cudd_bddNewVarAtLevel</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Creates a new BDD variable.  The new variable has an
  index equal to the largest previous index plus 1 and is positioned at
  the specified level in the order.  Returns a pointer to the new
  variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="#Cudd_addNewVarAtLevel">Cudd_addNewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddNewVar"></A>
DdNode * <I></I>
<B>Cudd_bddNewVar</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Creates a new BDD variable.  The new variable has an
  index equal to the largest previous index plus 1.  Returns a
  pointer to the new variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addNewVar">Cudd_addNewVar</a>
<a href="#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddNor"></A>
DdNode * <I></I>
<B>Cudd_bddNor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the NOR of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="#Cudd_bddOr">Cudd_bddOr</a>
<a href="#Cudd_bddNand">Cudd_bddNand</a>
<a href="#Cudd_bddXor">Cudd_bddXor</a>
<a href="#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddOr"></A>
DdNode * <I></I>
<B>Cudd_bddOr</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the disjunction of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="#Cudd_bddNand">Cudd_bddNand</a>
<a href="#Cudd_bddNor">Cudd_bddNor</a>
<a href="#Cudd_bddXor">Cudd_bddXor</a>
<a href="#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddPermute"></A>
DdNode * <I></I>
<B>Cudd_bddPermute</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int * <b>permut</b> <i></i>
)
</pre>
<dd> Given a permutation in array permut, creates a new BDD
  with permuted variables. There should be an entry in array permut
  for each variable in the manager. The i-th entry of permut holds the
  index of the variable that is to substitute the i-th variable.
  Returns a pointer to the resulting BDD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddPickArbitraryMinterms"></A>
DdNode ** <I></I>
<B>Cudd_bddPickArbitraryMinterms</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function from which to pick k minterms</i>
  DdNode ** <b>vars</b>, <i>array of variables</i>
  int  <b>n</b>, <i>size of <code>vars</code></i>
  int  <b>k</b> <i>number of minterms to find</i>
)
</pre>
<dd> Picks k on-set minterms evenly distributed from given DD.
  The minterms are in terms of <code>vars</code>. The array
  <code>vars</code> should contain at least all variables in the
  support of <code>f</code>; if this condition is not met the minterms
  built by this procedure may not be contained in
  <code>f</code>. Builds an array of BDDs for the minterms and returns a
  pointer to it if successful; NULL otherwise. There are three reasons
  why the procedure may fail:
  <ul>
  <li> It may run out of memory;
  <li> the function <code>f</code> may be the constant 0;
  <li> the minterms may not be contained in <code>f</code>.
  </ul>
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPickOneMinterm">Cudd_bddPickOneMinterm</a>
<a href="#Cudd_bddPickOneCube">Cudd_bddPickOneCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddPickOneCube"></A>
int <I></I>
<B>Cudd_bddPickOneCube</B>(
  DdManager * <b>ddm</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  char * <b>string</b> <i></i>
)
</pre>
<dd> Picks one on-set cube randomly from the given DD. The
  cube is written into an array of characters.  The array must have at
  least as many entries as there are variables. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPickOneMinterm">Cudd_bddPickOneMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddPickOneMinterm"></A>
DdNode * <I></I>
<B>Cudd_bddPickOneMinterm</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function from which to pick one minterm</i>
  DdNode ** <b>vars</b>, <i>array of variables</i>
  int  <b>n</b> <i>size of <code>vars</code></i>
)
</pre>
<dd> Picks one on-set minterm randomly from the given
  DD. The minterm is in terms of <code>vars</code>. The array
  <code>vars</code> should contain at least all variables in the
  support of <code>f</code>; if this condition is not met the minterm
  built by this procedure may not be contained in
  <code>f</code>. Builds a BDD for the minterm and returns a pointer
  to it if successful; NULL otherwise. There are three reasons why the
  procedure may fail:
  <ul>
  <li> It may run out of memory;
  <li> the function <code>f</code> may be the constant 0;
  <li> the minterm may not be contained in <code>f</code>.
  </ul>
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPickOneCube">Cudd_bddPickOneCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddPrintCover"></A>
int <I></I>
<B>Cudd_bddPrintCover</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b> <i></i>
)
</pre>
<dd> Prints a sum of product cover for an incompletely
  specified function given by a lower bound and an upper bound.  Each
  product is a prime implicant obtained by expanding the product
  corresponding to a path from node to the constant one.  Uses the
  package default output file.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintMinterm">Cudd_PrintMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddReadPairIndex"></A>
int <I></I>
<B>Cudd_bddReadPairIndex</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Reads a corresponding pair index for a given index.
  These pair indices are present and next state variable.  Returns the
  corresponding variable index if the variable exists; -1 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetPairIndex">Cudd_bddSetPairIndex</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddRead"></A>
int <I></I>
<B>Cudd_bddRead</B>(
  FILE * <b>fp</b>, <i>input file pointer</i>
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode ** <b>E</b>, <i>characteristic function of the graph</i>
  DdNode *** <b>x</b>, <i>array of row variables</i>
  DdNode *** <b>y</b>, <i>array of column variables</i>
  int * <b>nx</b>, <i>number or row variables</i>
  int * <b>ny</b>, <i>number or column variables</i>
  int * <b>m</b>, <i>number of rows</i>
  int * <b>n</b>, <i>number of columns</i>
  int  <b>bx</b>, <i>first index of row variables</i>
  int  <b>sx</b>, <i>step of row variables</i>
  int  <b>by</b>, <i>first index of column variables</i>
  int  <b>sy</b> <i>step of column variables</i>
)
</pre>
<dd> Reads in a graph (without labels) given as an adjacency
  matrix.  The first line of the input contains the numbers of rows and
  columns of the adjacency matrix. The remaining lines contain the arcs
  of the graph, one per line. Each arc is described by two integers,
  i.e., the row and column number, or the indices of the two endpoints.
  Cudd_bddRead produces a BDD that depends on two sets of variables: x
  and y.  The x variables (x[0] ... x[nx-1]) encode
  the row index and the y variables (y[0] ... y[ny-1]) encode the
  column index. x[0] and y[0] are the most significant bits in the
  indices.
  The variables may already exist or may be created by the function.
  The index of x[i] is bx+i*sx, and the index of y[i] is by+i*sy.<p>
  On input, nx and ny hold the numbers of row and column variables already
  in existence. On output, they hold the numbers of row and column
  variables actually used by the matrix. When Cudd_bddRead creates the
  variable arrays, the index of x[i] is bx+i*sx, and the index of
  y[i] is by+i*sy. When some variables already exist, Cudd_bddRead
  expects the indices of the existing x variables to be bx+i*sx, and the
  indices of the existing y variables to be by+i*sy.<p>
  m and n are set to the numbers of rows and columns of the
  matrix.  Their values on input are immaterial.  The BDD for the graph
  is returned in E, and its reference count is > 0. Cudd_bddRead returns
  1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> nx and ny are set to the numbers of row and column
  variables. m and n are set to the numbers of rows and columns. x and y
  are possibly extended to represent the array of row and column
  variables.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addHarwell">Cudd_addHarwell</a>
<a href="#Cudd_addRead">Cudd_addRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRead.c"TARGET="ABSTRACT"><CODE>cuddRead.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddRealignDisable"></A>
void <I></I>
<B>Cudd_bddRealignDisable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables realignment of ZDD order to BDD order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
<a href="#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddRealignEnable"></A>
void <I></I>
<B>Cudd_bddRealignEnable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Enables realignment of the BDD variable order to the
  ZDD variable order after the ZDDs have been reordered.  The
  number of ZDD variables must be a multiple of the number of BDD
  variables for realignment to make sense. If this condition is not met,
  Cudd_zddReduceHeap will return 0. Let <code>M</code> be the
  ratio of the two numbers. For the purpose of realignment, the ZDD
  variables from <code>M*i</code> to <code>(M+1)*i-1</code> are
  reagarded as corresponding to BDD variable <code>i</code>. Realignment
  is initially disabled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
<a href="#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
<a href="#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
<a href="#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
<a href="#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddRealignmentEnabled"></A>
int <I></I>
<B>Cudd_bddRealignmentEnabled</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Returns 1 if the realignment of BDD order to ZDD order is
  enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
<a href="#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddResetVarToBeGrouped"></A>
int <I></I>
<B>Cudd_bddResetVarToBeGrouped</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Resets a variable not to be grouped.  This function is
  used for lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetVarToBeGrouped">Cudd_bddSetVarToBeGrouped</a>
<a href="#Cudd_bddSetVarHardGroup">Cudd_bddSetVarHardGroup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddRestrict"></A>
DdNode * <I></I>
<B>Cudd_bddRestrict</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> BDD restrict according to Coudert and Madre's algorithm
  (ICCAD90). Returns the restricted BDD if successful; otherwise NULL.
  If application of restrict results in a BDD larger than the input
  BDD, the input BDD is returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
<a href="#Cudd_addRestrict">Cudd_addRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetNsVar"></A>
int <I></I>
<B>Cudd_bddSetNsVar</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Sets a variable type to next state.  The variable type is
  used by lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetPiVar">Cudd_bddSetPiVar</a>
<a href="#Cudd_bddSetPsVar">Cudd_bddSetPsVar</a>
<a href="#Cudd_bddIsNsVar">Cudd_bddIsNsVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetPairIndex"></A>
int <I></I>
<B>Cudd_bddSetPairIndex</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b>, <i>variable index</i>
  int  <b>pairIndex</b> <i>corresponding variable index</i>
)
</pre>
<dd> Sets a corresponding pair index for a given index.
  These pair indices are present and next state variable.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddReadPairIndex">Cudd_bddReadPairIndex</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetPiVar"></A>
int <I></I>
<B>Cudd_bddSetPiVar</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Sets a variable type to primary input.  The variable type is
  used by lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetPsVar">Cudd_bddSetPsVar</a>
<a href="#Cudd_bddSetNsVar">Cudd_bddSetNsVar</a>
<a href="#Cudd_bddIsPiVar">Cudd_bddIsPiVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetPsVar"></A>
int <I></I>
<B>Cudd_bddSetPsVar</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> Sets a variable type to present state.  The variable type is
  used by lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetPiVar">Cudd_bddSetPiVar</a>
<a href="#Cudd_bddSetNsVar">Cudd_bddSetNsVar</a>
<a href="#Cudd_bddIsPsVar">Cudd_bddIsPsVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetVarHardGroup"></A>
int <I></I>
<B>Cudd_bddSetVarHardGroup</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to be a hard group.  This function is used
  for lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetVarToBeGrouped">Cudd_bddSetVarToBeGrouped</a>
<a href="#Cudd_bddResetVarToBeGrouped">Cudd_bddResetVarToBeGrouped</a>
<a href="#Cudd_bddIsVarHardGroup">Cudd_bddIsVarHardGroup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetVarToBeGrouped"></A>
int <I></I>
<B>Cudd_bddSetVarToBeGrouped</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to be grouped. This function is used for
  lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSetVarHardGroup">Cudd_bddSetVarHardGroup</a>
<a href="#Cudd_bddResetVarToBeGrouped">Cudd_bddResetVarToBeGrouped</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSetVarToBeUngrouped"></A>
int <I></I>
<B>Cudd_bddSetVarToBeUngrouped</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to be ungrouped. This function is used
  for lazy sifting.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> modifies the manager
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIsVarToBeUngrouped">Cudd_bddIsVarToBeUngrouped</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSqueeze"></A>
DdNode * <I></I>
<B>Cudd_bddSqueeze</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>l</b>, <i>lower bound</i>
  DdNode * <b>u</b> <i>upper bound</i>
)
</pre>
<dd> Finds a small BDD in a function interval. Given BDDs
  <code>l</code> and <code>u</code>, representing the lower bound and
  upper bound of a function interval, Cudd_bddSqueeze produces the BDD
  of a function within the interval with a small BDD.  Returns a
  pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
<a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddSwapVariables"></A>
DdNode * <I></I>
<B>Cudd_bddSwapVariables</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Swaps two sets of variables of the same size (x and y)
  in the BDD f. The size is given by n. The two sets of variables are
  assumed to be disjoint.  Returns a pointer to the resulting BDD if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#Cudd_addSwapVariables">Cudd_addSwapVariables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddTransfer"></A>
DdNode * <I></I>
<B>Cudd_bddTransfer</B>(
  DdManager * <b>ddSource</b>, <i></i>
  DdManager * <b>ddDestination</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD from a manager to another one. The orders of the
  variables in the two managers may be different. Returns a
  pointer to the BDD in the destination manager if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddUnbindVar"></A>
int <I></I>
<B>Cudd_bddUnbindVar</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> This function resets the flag that prevents the sifting
  of a variable. In successive variable reorderings, the variable will
  NOT be skipped, that is, sifted.  Initially all variables can be
  sifted. It is necessary to call this function only to re-enable
  sifting after a call to Cudd_bddBindVar. Returns 1 if successful; 0
  otherwise (i.e., invalid variable index).
<p>

<dd> <b>Side Effects</b> Changes the "bindVar" flag in DdSubtable.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddBindVar">Cudd_bddBindVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddUnivAbstract"></A>
DdNode * <I></I>
<B>Cudd_bddUnivAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Universally abstracts all the variables in cube from f.
  Returns the abstracted BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="#Cudd_addUnivAbstract">Cudd_addUnivAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddVarConjDecomp"></A>
int <I></I>
<B>Cudd_bddVarConjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>conjuncts</b> <i>address of the array of conjuncts</i>
)
</pre>
<dd> Conjunctively decomposes one BDD according to a
  variable.  If <code>f</code> is the function of the BDD and
  <code>x</code> is the variable, the decomposition is
  <code>(f+x)(f+x')</code>.  The variable is chosen so as to balance
  the sizes of the two conjuncts and to keep them small.  Returns the
  number of conjuncts produced, that is, 2 if successful; 1 if no
  meaningful decomposition was found; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The two factors are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the conjuncts are already
  referenced. If the function returns 0, the array for the conjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddVarDisjDecomp">Cudd_bddVarDisjDecomp</a>
<a href="#Cudd_bddGenConjDecomp">Cudd_bddGenConjDecomp</a>
<a href="#Cudd_bddApproxConjDecomp">Cudd_bddApproxConjDecomp</a>
<a href="#Cudd_bddIterConjDecomp">Cudd_bddIterConjDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddVarDisjDecomp"></A>
int <I></I>
<B>Cudd_bddVarDisjDecomp</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be decomposed</i>
  DdNode *** <b>disjuncts</b> <i>address of the array of the disjuncts</i>
)
</pre>
<dd> Performs two-way disjunctive decomposition of a BDD
  according to a variable. If <code>f</code> is the function of the
  BDD and <code>x</code> is the variable, the decomposition is
  <code>f*x + f*x'</code>.  The variable is chosen so as to balance
  the sizes of the two disjuncts and to keep them small.  Returns the
  number of disjuncts produced, that is, 2 if successful; 1 if no
  meaningful decomposition was found; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The two disjuncts are returned in an array as side effects.
  The array is allocated by this function. It is the caller's responsibility
  to free it. On successful completion, the disjuncts are already
  referenced. If the function returns 0, the array for the disjuncts is
  not allocated. If the function returns 1, the only factor equals the
  function to be decomposed.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddVarConjDecomp">Cudd_bddVarConjDecomp</a>
<a href="#Cudd_bddApproxDisjDecomp">Cudd_bddApproxDisjDecomp</a>
<a href="#Cudd_bddIterDisjDecomp">Cudd_bddIterDisjDecomp</a>
<a href="#Cudd_bddGenDisjDecomp">Cudd_bddGenDisjDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddVarIsBound"></A>
int <I></I>
<B>Cudd_bddVarIsBound</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>index</b> <i>variable index</i>
)
</pre>
<dd> This function returns 1 if a variable is enabled for
  sifting.  Initially all variables can be sifted. This function returns
  0 only if there has been a previous call to Cudd_bddBindVar for that
  variable not followed by a call to Cudd_bddUnbindVar. The function returns
  0 also in the case in which the index of the variable is out of bounds.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddBindVar">Cudd_bddBindVar</a>
<a href="#Cudd_bddUnbindVar">Cudd_bddUnbindVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddVarIsDependent"></A>
int <I></I>
<B>Cudd_bddVarIsDependent</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>var</b> <i>variable</i>
)
</pre>
<dd> Checks whether a variable is dependent on others in a
  function.  Returns 1 if the variable is dependent; 0 otherwise. No
  new nodes are created.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddVarMap"></A>
DdNode * <I></I>
<B>Cudd_bddVarMap</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdNode * <b>f</b> <i>function in which to remap variables</i>
)
</pre>
<dd> Remaps the variables of a BDD using the default
  variable map.  A typical use of this function is to swap two sets of
  variables.  The variable map must be registered with Cudd_SetVarMap.
  Returns a pointer to the resulting BDD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#Cudd_bddSwapVariables">Cudd_bddSwapVariables</a>
<a href="#Cudd_SetVarMap">Cudd_SetVarMap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddVectorCompose"></A>
DdNode * <I></I>
<B>Cudd_bddVectorCompose</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b> <i></i>
)
</pre>
<dd> Given a vector of BDDs, creates a new BDD by
  substituting the BDDs for the variables of the BDD f.  There
  should be an entry in vector for each variable in the manager.
  If no substitution is sought for a given variable, the corresponding
  projection function should be specified in the vector.
  This function implements simultaneous composition.
  Returns a pointer to the resulting BDD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#Cudd_bddCompose">Cudd_bddCompose</a>
<a href="#Cudd_addVectorCompose">Cudd_addVectorCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddXnor"></A>
DdNode * <I></I>
<B>Cudd_bddXnor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the exclusive NOR of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="#Cudd_bddOr">Cudd_bddOr</a>
<a href="#Cudd_bddNand">Cudd_bddNand</a>
<a href="#Cudd_bddNor">Cudd_bddNor</a>
<a href="#Cudd_bddXor">Cudd_bddXor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddXorExistAbstract"></A>
DdNode * <I></I>
<B>Cudd_bddXorExistAbstract</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the exclusive OR of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.  Returns a
  pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
<a href="#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_bddXor"></A>
DdNode * <I></I>
<B>Cudd_bddXor</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the exclusive OR of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIte">Cudd_bddIte</a>
<a href="#Cudd_addApply">Cudd_addApply</a>
<a href="#Cudd_bddAnd">Cudd_bddAnd</a>
<a href="#Cudd_bddOr">Cudd_bddOr</a>
<a href="#Cudd_bddNand">Cudd_bddNand</a>
<a href="#Cudd_bddNor">Cudd_bddNor</a>
<a href="#Cudd_bddXnor">Cudd_bddXnor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="Cudd_tlcInfoFree"></A>
void <I></I>
<B>Cudd_tlcInfoFree</B>(
  DdTlcInfo * <b>t</b> <i></i>
)
</pre>
<dd> Frees a DdTlcInfo Structure as well as the memory pointed
  by it.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddChange"></A>
DdNode * <I></I>
<B>Cudd_zddChange</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Substitutes a variable with its complement in a ZDD.
  returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddComplement"></A>
DdNode	* <I></I>
<B>Cudd_zddComplement</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes a complement cover for a ZDD node. For lack of a
  better method, we first extract the function BDD from the ZDD cover,
  then make the complement of the ZDD cover from the complement of the
  BDD node by using ISOP. Returns a pointer to the resulting cover if
  successful; NULL otherwise. The result depends on current variable
  order.
<p>

<dd> <b>Side Effects</b> The result depends on current variable order.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddCountDouble"></A>
double <I></I>
<B>Cudd_zddCountDouble</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of a ZDD. The result is
  returned as a double. If the procedure runs out of memory, it
  returns (double) CUDD_OUT_OF_MEM. This procedure is used in
  Cudd_zddCountMinterm.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddCountMinterm">Cudd_zddCountMinterm</a>
<a href="#Cudd_zddCount">Cudd_zddCount</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddCountMinterm"></A>
double <I></I>
<B>Cudd_zddCountMinterm</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>path</b> <i></i>
)
</pre>
<dd> Counts the number of minterms of the ZDD rooted at
  <code>node</code>. This procedure takes a parameter
  <code>path</code> that specifies how many variables are in the
  support of the function. If the procedure runs out of memory, it
  returns (double) CUDD_OUT_OF_MEM.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddCountDouble">Cudd_zddCountDouble</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddMisc.c"TARGET="ABSTRACT"><CODE>cuddZddMisc.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddCount"></A>
int <I></I>
<B>Cudd_zddCount</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b> <i></i>
)
</pre>
<dd> Returns an integer representing the number of minterms
  in a ZDD.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddCountDouble">Cudd_zddCountDouble</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddCoverPathToString"></A>
char * <I></I>
<B>Cudd_zddCoverPathToString</B>(
  DdManager * <b>zdd</b>, <i>DD manager</i>
  int * <b>path</b>, <i>path of ZDD representing a cover</i>
  char * <b>str</b> <i>pointer to string to use if != NULL</i>
)
</pre>
<dd> Converts a path of a ZDD representing a cover to a
  string.  The string represents an implicant of the cover.  The path
  is typically produced by Cudd_zddForeachPath.  Returns a pointer to
  the string if successful; NULL otherwise.  If the str input is NULL,
  it allocates a new string.  The string passed to this function must
  have enough room for all variables and for the terminator.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddForeachPath">Cudd_zddForeachPath</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddDagSize"></A>
int <I></I>
<B>Cudd_zddDagSize</B>(
  DdNode * <b>p_node</b> <i></i>
)
</pre>
<dd> Counts the number of nodes in a ZDD. This function
  duplicates Cudd_DagSize and is only retained for compatibility.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DagSize">Cudd_DagSize</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddMisc.c"TARGET="ABSTRACT"><CODE>cuddZddMisc.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddDiffConst"></A>
DdNode * <I></I>
<B>Cudd_zddDiffConst</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Inclusion test for ZDDs (P implies Q). No new nodes are
  generated by this procedure. Returns empty if true;
  a valid pointer different from empty or DD_NON_CONSTANT otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDiff">Cudd_zddDiff</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddDiff"></A>
DdNode * <I></I>
<B>Cudd_zddDiff</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Computes the difference of two ZDDs. Returns a pointer to the
  result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDiffConst">Cudd_zddDiffConst</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddDivideF"></A>
DdNode	* <I></I>
<B>Cudd_zddDivideF</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Modified version of Cudd_zddDivide. This function may
  disappear in future releases.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddDivide"></A>
DdNode	* <I></I>
<B>Cudd_zddDivide</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the quotient of two unate covers represented
  by ZDDs.  Unate covers use one ZDD variable for each BDD
  variable. Returns a pointer to the resulting ZDD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddDumpDot"></A>
int <I></I>
<B>Cudd_zddDumpDot</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  int  <b>n</b>, <i>number of output nodes to be dumped</i>
  DdNode ** <b>f</b>, <i>array of output nodes to be dumped</i>
  char ** <b>inames</b>, <i>array of input names (or NULL)</i>
  char ** <b>onames</b>, <i>array of output names (or NULL)</i>
  FILE * <b>fp</b> <i>pointer to the dump file</i>
)
</pre>
<dd> Writes a file representing the argument ZDDs in a format
  suitable for the graph drawing program dot.
  It returns 1 in case of success; 0 otherwise (e.g., out-of-memory,
  file system full).
  Cudd_zddDumpDot does not close the file: This is the caller
  responsibility. Cudd_zddDumpDot uses a minimal unique subset of the
  hexadecimal address of a node as name for it.
  If the argument inames is non-null, it is assumed to hold the pointers
  to the names of the inputs. Similarly for onames.
  Cudd_zddDumpDot uses the following convention to draw arcs:
    <ul>
    <li> solid line: THEN arcs;
    <li> dashed line: ELSE arcs.
    </ul>
  The dot options are chosen so that the drawing fits on a letter-size
  sheet.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpDot">Cudd_DumpDot</a>
<a href="#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddFirstPath"></A>
DdGen * <I></I>
<B>Cudd_zddFirstPath</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int ** <b>path</b> <i></i>
)
</pre>
<dd> Defines an iterator on the paths of a ZDD
  and finds its first path. Returns a generator that contains the
  information necessary to continue the enumeration if successful; NULL
  otherwise.<p>
  A path is represented as an array of literals, which are integers in
  {0, 1, 2}; 0 represents an else arc out of a node, 1 represents a then arc
  out of a node, and 2 stands for the absence of a node.
  The size of the array equals the number of variables in the manager at
  the time Cudd_zddFirstCube is called.<p>
  The paths that end in the empty terminal are not enumerated.
<p>

<dd> <b>Side Effects</b> The first path is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddForeachPath">Cudd_zddForeachPath</a>
<a href="#Cudd_zddNextPath">Cudd_zddNextPath</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddIntersect"></A>
DdNode * <I></I>
<B>Cudd_zddIntersect</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Computes the intersection of two ZDDs. Returns a pointer to
  the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddIsop"></A>
DdNode	* <I></I>
<B>Cudd_zddIsop</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b>, <i></i>
  DdNode ** <b>zdd_I</b> <i></i>
)
</pre>
<dd> Computes an irredundant sum of products (ISOP) in ZDD
  form from BDDs. The two BDDs L and U represent the lower bound and
  the upper bound, respectively, of the function. The ISOP uses two
  ZDD variables for each BDD variable: One for the positive literal,
  and one for the negative literal. These two variables should be
  adjacent in the ZDD order. The two ZDD variables corresponding to
  BDD variable <code>i</code> should have indices <code>2i</code> and
  <code>2i+1</code>.  The result of this procedure depends on the
  variable order. If successful, Cudd_zddIsop returns the BDD for
  the function chosen from the interval. The ZDD representing the
  irredundant cover is returned as a side effect in zdd_I. In case of
  failure, NULL is returned.
<p>

<dd> <b>Side Effects</b> zdd_I holds the pointer to the ZDD for the ISOP on
  successful return.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIsop">Cudd_bddIsop</a>
<a href="#Cudd_zddVarsFromBddVars">Cudd_zddVarsFromBddVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddIte"></A>
DdNode * <I></I>
<B>Cudd_zddIte</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Computes the ITE of three ZDDs. Returns a pointer to the
  result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddIthVar"></A>
DdNode * <I></I>
<B>Cudd_zddIthVar</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Retrieves the ZDD variable with index i if it already
  exists, or creates a new ZDD variable.  Returns a pointer to the
  variable if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="#Cudd_addIthVar">Cudd_addIthVar</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddNextPath"></A>
int <I></I>
<B>Cudd_zddNextPath</B>(
  DdGen * <b>gen</b>, <i></i>
  int ** <b>path</b> <i></i>
)
</pre>
<dd> Generates the next path of a ZDD onset,
  using generator gen. Returns 0 if the enumeration is completed; 1
  otherwise.
<p>

<dd> <b>Side Effects</b> The path is returned as a side effect. The
  generator is modified.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddForeachPath">Cudd_zddForeachPath</a>
<a href="#Cudd_zddFirstPath">Cudd_zddFirstPath</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddPortFromBdd"></A>
DdNode * <I></I>
<B>Cudd_zddPortFromBdd</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b> <i></i>
)
</pre>
<dd> Converts a BDD into a ZDD. This function assumes that
  there is a one-to-one correspondence between the BDD variables and the
  ZDD variables, and that the variable order is the same for both types
  of variables. These conditions are established if the ZDD variables
  are created by one call to Cudd_zddVarsFromBddVars with multiplicity =
  1. Returns a pointer to the resulting ZDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddVarsFromBddVars">Cudd_zddVarsFromBddVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddPort.c"TARGET="ABSTRACT"><CODE>cuddZddPort.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddPortToBdd"></A>
DdNode * <I></I>
<B>Cudd_zddPortToBdd</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Converts a ZDD into a BDD. Returns a pointer to the resulting
  ZDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddPortFromBdd">Cudd_zddPortFromBdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddPort.c"TARGET="ABSTRACT"><CODE>cuddZddPort.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddPrintCover"></A>
int <I></I>
<B>Cudd_zddPrintCover</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Prints a sum of products from a ZDD representing a cover.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddPrintMinterm">Cudd_zddPrintMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddPrintDebug"></A>
int <I></I>
<B>Cudd_zddPrintDebug</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>pr</b> <i></i>
)
</pre>
<dd> Prints to the standard output a DD and its statistics.
  The statistics include the number of nodes and the number of minterms.
  (The number of minterms is also the number of combinations in the set.)
  The statistics are printed if pr &gt; 0.  Specifically:
  <ul>
  <li> pr = 0 : prints nothing
  <li> pr = 1 : prints counts of nodes and minterms
  <li> pr = 2 : prints counts + disjoint sum of products
  <li> pr = 3 : prints counts + list of nodes
  <li> pr &gt; 3 : prints counts + disjoint sum of products + list of nodes
  </ul>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddPrintMinterm"></A>
int <I></I>
<B>Cudd_zddPrintMinterm</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Prints a disjoint sum of product form for a ZDD. Returns 1
  if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
<a href="#Cudd_zddPrintCover">Cudd_zddPrintCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddPrintSubtable"></A>
void <I></I>
<B>Cudd_zddPrintSubtable</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prints the ZDD table for debugging purposes.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddMisc.c"TARGET="ABSTRACT"><CODE>cuddZddMisc.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddProduct"></A>
DdNode	* <I></I>
<B>Cudd_zddProduct</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the product of two covers represented by
  ZDDs. The result is also a ZDD. Returns a pointer to the result if
  successful; NULL otherwise.  The covers on which Cudd_zddProduct
  operates use two ZDD variables for each function variable (one ZDD
  variable for each literal of the variable). Those two ZDD variables
  should be adjacent in the order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddUnateProduct">Cudd_zddUnateProduct</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddReadNodeCount"></A>
long <I></I>
<B>Cudd_zddReadNodeCount</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Reports the number of nodes in ZDDs. This
  number always includes the two constants 1 and 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPeakNodeCount">Cudd_ReadPeakNodeCount</a>
<a href="#Cudd_ReadNodeCount">Cudd_ReadNodeCount</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddRealignDisable"></A>
void <I></I>
<B>Cudd_zddRealignDisable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Disables realignment of ZDD order to BDD order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
<a href="#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddRealignEnable"></A>
void <I></I>
<B>Cudd_zddRealignEnable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Enables realignment of the ZDD variable order to the
  BDD variable order after the BDDs and ADDs have been reordered.  The
  number of ZDD variables must be a multiple of the number of BDD
  variables for realignment to make sense. If this condition is not met,
  Cudd_ReduceHeap will return 0. Let <code>M</code> be the
  ratio of the two numbers. For the purpose of realignment, the ZDD
  variables from <code>M*i</code> to <code>(M+1)*i-1</code> are
  reagarded as corresponding to BDD variable <code>i</code>. Realignment
  is initially disabled.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
<a href="#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
<a href="#Cudd_zddRealignmentEnabled">Cudd_zddRealignmentEnabled</a>
<a href="#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
<a href="#Cudd_bddRealignmentEnabled">Cudd_bddRealignmentEnabled</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddRealignmentEnabled"></A>
int <I></I>
<B>Cudd_zddRealignmentEnabled</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Returns 1 if the realignment of ZDD order to BDD order is
  enabled; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddRealignEnable">Cudd_zddRealignEnable</a>
<a href="#Cudd_zddRealignDisable">Cudd_zddRealignDisable</a>
<a href="#Cudd_bddRealignEnable">Cudd_bddRealignEnable</a>
<a href="#Cudd_bddRealignDisable">Cudd_bddRealignDisable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddReduceHeap"></A>
int <I></I>
<B>Cudd_zddReduceHeap</B>(
  DdManager * <b>table</b>, <i>DD manager</i>
  Cudd_ReorderingType  <b>heuristic</b>, <i>method used for reordering</i>
  int  <b>minsize</b> <i>bound below which no reordering occurs</i>
)
</pre>
<dd> Main dynamic reordering routine for ZDDs.
  Calls one of the possible reordering procedures:
  <ul>
  <li>Swapping
  <li>Sifting
  <li>Symmetric Sifting
  </ul>

  For sifting and symmetric sifting it is possible to request reordering
  to convergence.<p>

  The core of all methods is the reordering procedure
  cuddZddSwapInPlace() which swaps two adjacent variables.
  Returns 1 in case of success; 0 otherwise. In the case of symmetric
  sifting (with and without convergence) returns 1 plus the number of
  symmetric variables, in case of success.
<p>

<dd> <b>Side Effects</b> Changes the variable order for all ZDDs and clears
  the cache.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddShuffleHeap"></A>
int <I></I>
<B>Cudd_zddShuffleHeap</B>(
  DdManager * <b>table</b>, <i>DD manager</i>
  int * <b>permutation</b> <i>required variable permutation</i>
)
</pre>
<dd> Reorders ZDD variables according to given permutation.
  The i-th entry of the permutation array contains the index of the variable
  that should be brought to the i-th level.  The size of the array should be
  equal or greater to the number of variables currently in use.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable order for all diagrams and clears
  the cache.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddSubset0"></A>
DdNode * <I></I>
<B>Cudd_zddSubset0</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the negative cofactor of a ZDD w.r.t. a
  variable. In terms of combinations, the result is the set of all
  combinations in which the variable is negated. Returns a pointer to
  the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddSubset1">Cudd_zddSubset1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddSubset1"></A>
DdNode * <I></I>
<B>Cudd_zddSubset1</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the positive cofactor of a ZDD w.r.t. a
  variable. In terms of combinations, the result is the set of all
  combinations in which the variable is asserted. Returns a pointer to
  the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddSubset0">Cudd_zddSubset0</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddSymmProfile"></A>
void <I></I>
<B>Cudd_zddSymmProfile</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Prints statistics on symmetric ZDD variables.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddUnateProduct"></A>
DdNode	* <I></I>
<B>Cudd_zddUnateProduct</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Computes the product of two unate covers represented as
  ZDDs. Unate covers use one ZDD variable for each BDD
  variable. Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddProduct">Cudd_zddProduct</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddUnion"></A>
DdNode * <I></I>
<B>Cudd_zddUnion</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Computes the union of two ZDDs. Returns a pointer to the
  result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddVarsFromBddVars"></A>
int <I></I>
<B>Cudd_zddVarsFromBddVars</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  int  <b>multiplicity</b> <i>how many ZDD variables are created for each BDD variable</i>
)
</pre>
<dd> Creates one or more ZDD variables for each BDD
  variable.  If some ZDD variables already exist, only the missing
  variables are created.  Parameter multiplicity allows the caller to
  control how many variables are created for each BDD variable in
  existence. For instance, if ZDDs are used to represent covers, two
  ZDD variables are required for each BDD variable.  The order of the
  BDD variables is transferred to the ZDD variables. If a variable
  group tree exists for the BDD variables, a corresponding ZDD
  variable group tree is created by expanding the BDD variable
  tree. In any case, the ZDD variables derived from the same BDD
  variable are merged in a ZDD variable group. If a ZDD variable group
  tree exists, it is freed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddNewVar">Cudd_bddNewVar</a>
<a href="#Cudd_bddIthVar">Cudd_bddIthVar</a>
<a href="#Cudd_bddNewVarAtLevel">Cudd_bddNewVarAtLevel</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddWeakDivF"></A>
DdNode	* <I></I>
<B>Cudd_zddWeakDivF</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Modified version of Cudd_zddWeakDiv. This function may
  disappear in future releases.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="Cudd_zddWeakDiv"></A>
DdNode	* <I></I>
<B>Cudd_zddWeakDiv</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Applies weak division to two ZDDs representing two
  covers. Returns a pointer to the ZDD representing the result if
  successful; NULL otherwise. The result of weak division depends on
  the variable order. The covers on which Cudd_zddWeakDiv operates use
  two ZDD variables for each function variable (one ZDD variable for
  each literal of the variable). Those two ZDD variables should be
  adjacent in the order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDivide">Cudd_zddDivide</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="MarkCacheCleanUp"></A>
static enum st_retval <I></I>
<B>MarkCacheCleanUp</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees memory associated with computed table of
  cuddBddLICMarkEdges. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="MarkCacheCompare"></A>
static int <I></I>
<B>MarkCacheCompare</B>(
  const char * <b>ptr1</b>, <i></i>
  const char * <b>ptr2</b> <i></i>
)
</pre>
<dd> Comparison function for the computed table of
  cuddBddLICMarkEdges. Returns 0 if the two nodes of the key are equal; 1
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="MarkCacheHash"></A>
static int <I></I>
<B>MarkCacheHash</B>(
  char * <b>ptr</b>, <i></i>
  int  <b>modulus</b> <i></i>
)
</pre>
<dd> Hash function for the computed table of
  cuddBddLICMarkEdges.  Returns the bucket number.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="PMX"></A>
static int <I></I>
<B>PMX</B>(
  int  <b>maxvar</b> <i></i>
)
</pre>
<dd> Performs the crossover between two randomly chosen
  parents, and creates two children, x1 and x2. Uses the Partially
  Matched Crossover operator.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="PairInTables"></A>
static int <I></I>
<B>PairInTables</B>(
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  st_table * <b>ghTable</b> <i></i>
)
</pre>
<dd> .Check whether the given pair is in the tables.  gTable
  and hTable are combined.
  absence in both is indicated by 0,
  presence in gTable is indicated by 1,
  presence in hTable by 2 and
  presence in both by 3.
  The values returned by this function are PAIR_ST,
  PAIR_CR, G_ST, G_CR, H_ST, H_CR, BOTH_G, BOTH_H, NONE.
  PAIR_ST implies g in gTable and h in hTable
  PAIR_CR implies g in hTable and h in gTable
  G_ST implies g in gTable and h not in any table
  G_CR implies g in hTable and h not in any table
  H_ST implies h in hTable and g not in any table
  H_CR implies h in gTable and g not in any table
  BOTH_G implies both in gTable
  BOTH_H implies both in hTable
  NONE implies none in table;
<p>

<dd> <b>See Also</b> <code><a href="#CheckTablesCacheAndReturn">CheckTablesCacheAndReturn</a>
<a href="#CheckInTables">CheckInTables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="PickOnePair"></A>
static Conjuncts * <I></I>
<B>PickOnePair</B>(
  DdNode * <b>node</b>, <i></i>
  DdNode * <b>g1</b>, <i></i>
  DdNode * <b>h1</b>, <i></i>
  DdNode * <b>g2</b>, <i></i>
  DdNode * <b>h2</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b> <i></i>
)
</pre>
<dd> Check the tables for the existence of pair and return
  one combination, store in cache. The pair that has more pointers to
  it is picked. An approximation of the number of local pointers is
  made by taking the reference count of the pairs sent.
<p>

<dd> <b>See Also</b> <code><a href="#ZeroCase">ZeroCase</a>
<a href="#BuildConjuncts">BuildConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="RAbuildSubset"></A>
static DdNode * <I></I>
<B>RAbuildSubset</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  ApproxInfo * <b>info</b> <i>node info</i>
)
</pre>
<dd> Builds the subset BDDfor cuddRemapUnderApprox.  Based
  on the info table, performs remapping or replacement at selected
  nodes. Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRemapUnderApprox">cuddRemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="RAmarkNodes"></A>
static int <I></I>
<B>RAmarkNodes</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be analyzed</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>threshold</b>, <i>when to stop approximating</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Marks nodes for remapping. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRemapUnderApprox">cuddRemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="ResizeCountMintermPages"></A>
static void <I></I>
<B>ResizeCountMintermPages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the minterm
  counts.  The procedure  moves the counter to the next page when the
  end of the page is reached and allocates new pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of minterm pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="ResizeCountNodePages"></A>
static void <I></I>
<B>ResizeCountNodePages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the node counts.
  The procedure  moves the counter to the next page when the end of
  the page is reached and allocates new pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="ResizeNodeDataPages"></A>
static void <I></I>
<B>ResizeNodeDataPages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the node data
  The procedure  moves the counter to the next page when the end of
  the page is reached and allocates new pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="ResizeNodeDistPages"></A>
static void <I></I>
<B>ResizeNodeDistPages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store the distances
  related to each node. The procedure  moves the counter to the
  next page when the end of the page is reached and allocates new
  pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of  pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="ResizeQueuePages"></A>
static void <I></I>
<B>ResizeQueuePages</B>(
   <b></b> <i></i>
)
</pre>
<dd> Resize the number of pages allocated to store nodes in the BFS
  traversal of the Bdd. The procedure  moves the counter to the
  next page when the end of the page is reached and allocates new
  pages when necessary.
<p>

<dd> <b>Side Effects</b> Changes the size of pages, page, page index, maximum
  number of pages freeing stuff in case of memory out.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="StoreNodes"></A>
static void <I></I>
<B>StoreNodes</B>(
  st_table * <b>storeTable</b>, <i></i>
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> rocedure to recursively store nodes that are retained in the subset.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#StoreNodes">StoreNodes</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountMintermAux"></A>
static double <I></I>
<B>SubsetCountMintermAux</B>(
  DdNode * <b>node</b>, <i>function to analyze</i>
  double  <b>max</b>, <i>number of minterms of constant 1</i>
  st_table * <b>table</b> <i>visitedTable table</i>
)
</pre>
<dd> Recursively counts minterms of each node in the DAG.
  Similar to the cuddCountMintermAux which recursively counts the
  number of minterms for the dag rooted at each node in terms of the
  total number of variables (max). This procedure creates the node
  data structure and stores the minterm count as part of the node
  data structure.
<p>

<dd> <b>Side Effects</b> Creates structures of type node quality and fills the st_table
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountMinterm">SubsetCountMinterm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountMinterm"></A>
static st_table * <I></I>
<B>SubsetCountMinterm</B>(
  DdNode * <b>node</b>, <i>function to be analyzed</i>
  int  <b>nvars</b> <i>number of variables node depends on</i>
)
</pre>
<dd> Counts minterms of each node in the DAG. Similar to the
  Cudd_CountMinterm procedure except this returns the minterm count for
  all the nodes in the bdd in an st_table.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountMintermAux">SubsetCountMintermAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountNodesAux"></A>
static int <I></I>
<B>SubsetCountNodesAux</B>(
  DdNode * <b>node</b>, <i>current node</i>
  st_table * <b>table</b>, <i>table to update node count, also serves as visited table.</i>
  double  <b>max</b> <i>maximum number of variables</i>
)
</pre>
<dd> Recursively counts the number of nodes under the dag.
  Also counts the number of nodes under the lighter child of
  this node. . Note that the same dag may be the lighter child of two
  different nodes and have different counts. As with the minterm counts,
  the node counts are stored in pages to be space efficient and the
  address for these node counts are stored in an st_table associated
  to each node.
<p>

<dd> <b>Side Effects</b> Updates the node data table with node counts
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountNodes">SubsetCountNodes</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="SubsetCountNodes"></A>
static int <I></I>
<B>SubsetCountNodes</B>(
  DdNode * <b>node</b>, <i>function to be analyzed</i>
  st_table * <b>table</b>, <i>node quality table</i>
  int  <b>nvars</b> <i>number of variables node depends on</i>
)
</pre>
<dd> Counts the nodes under the current node and its lighter
  child. Calls a recursive procedure to count the number of nodes of
  a DAG rooted at a particular node and the number of nodes taken by its
  lighter child.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#SubsetCountNodesAux">SubsetCountNodesAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="UAbuildSubset"></A>
static DdNode * <I></I>
<B>UAbuildSubset</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  ApproxInfo * <b>info</b> <i>node info</i>
)
</pre>
<dd> Builds the subset BDD. Based on the info table,
  replaces selected nodes by zero. Returns a pointer to the result if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="UAmarkNodes"></A>
static int <I></I>
<B>UAmarkNodes</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be analyzed</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>threshold</b>, <i>when to stop approximating</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Marks nodes for replacement by zero. Returns 1 if successful;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="ZeroCase"></A>
static Conjuncts * <I></I>
<B>ZeroCase</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  Conjuncts * <b>factorsNv</b>, <i></i>
  st_table * <b>ghTable</b>, <i></i>
  st_table * <b>cacheTable</b>, <i></i>
  int  <b>switched</b> <i></i>
)
</pre>
<dd> If one child is zero, do explicitly what Restrict does or better.
  First separate a variable and its child in the base case. In case of a cube
  times a function, separate the cube and function. As a last resort, look in
  tables.
<p>

<dd> <b>Side Effects</b> Frees the BDDs in factorsNv. factorsNv itself is not freed
  because it is freed above.
<p>

<dd> <b>See Also</b> <code><a href="#BuildConjuncts">BuildConjuncts</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="addBddDoInterval"></A>
static DdNode * <I></I>
<B>addBddDoInterval</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddInterval.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#addBddDoThreshold">addBddDoThreshold</a>
<a href="#addBddDoStrictThreshold">addBddDoStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addBddDoIthBit"></A>
static DdNode * <I></I>
<B>addBddDoIthBit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>index</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddIthBit.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addBddDoStrictThreshold"></A>
static DdNode * <I></I>
<B>addBddDoStrictThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>val</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddStrictThreshold.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#addBddDoThreshold">addBddDoThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addBddDoThreshold"></A>
static DdNode * <I></I>
<B>addBddDoThreshold</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>val</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddThreshold.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#addBddDoStrictThreshold">addBddDoStrictThreshold</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="addCheckPositiveCube"></A>
static int <I></I>
<B>addCheckPositiveCube</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Checks whether cube is an ADD representing the product of
  positive literals. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="addDoIthBit"></A>
static DdNode * <I></I>
<B>addDoIthBit</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>index</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addIthBit.
  Returns a pointer to the BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddFind.c"TARGET="ABSTRACT"><CODE>cuddAddFind.c</CODE></A>

<dt><pre>
<A NAME="addMMRecur"></A>
static DdNode * <I></I>
<B>addMMRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>A</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  int  <b>topP</b>, <i></i>
  int * <b>vars</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addMatrixMultiply.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="addMultiplicityGroups"></A>
static int <I></I>
<B>addMultiplicityGroups</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  MtrNode * <b>treenode</b>, <i>current tree node</i>
  int  <b>multiplicity</b>, <i>how many ZDD vars per BDD var</i>
  char * <b>vmask</b>, <i>variable pairs for which a group has been already built</i>
  char * <b>lmask</b> <i>levels for which a group has already been built</i>
)
</pre>
<dd> Adds multiplicity groups to a ZDD variable group tree.
  Returns 1 if successful; 0 otherwise. This function creates the groups
  for set of ZDD variables (whose cardinality is given by parameter
  multiplicity) that are created for each BDD variable in
  Cudd_zddVarsFromBddVars. The crux of the matter is to determine the index
  each new group. (The index of the first variable in the group.)
  We first build all the groups for the children of a node, and then deal
  with the ZDD variables that are directly attached to the node. The problem
  for these is that the tree itself does not provide information on their
  position inside the group. While we deal with the children of the node,
  therefore, we keep track of all the positions they occupy. The remaining
  positions in the tree can be freely used. Also, we keep track of all the
  variables placed in the children. All the remaining variables are directly
  attached to the group. We can then place any pair of variables not yet
  grouped in any pair of available positions in the node.
<p>

<dd> <b>Side Effects</b> Changes the variable group tree.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddVarsFromBddVars">Cudd_zddVarsFromBddVars</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="addTriangleRecur"></A>
static DdNode * <I></I>
<B>addTriangleRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int * <b>vars</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addTriangle. Returns
  a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="addVarToConst"></A>
static void <I></I>
<B>addVarToConst</B>(
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  DdNode * <b>one</b>, <i></i>
  DdNode * <b>zero</b> <i></i>
)
</pre>
<dd> Replaces variables with constants if possible (part of
  canonical form).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="addWalshInt"></A>
static DdNode * <I></I>
<B>addWalshInt</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>x</b>, <i></i>
  DdNode ** <b>y</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Generates a Walsh matrix in ADD form. Returns a pointer
  to the matrixi if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddWalsh.c"TARGET="ABSTRACT"><CODE>cuddAddWalsh.c</CODE></A>

<dt><pre>
<A NAME="array_compare"></A>
static int <I></I>
<B>array_compare</B>(
  const char * <b>array1</b>, <i></i>
  const char * <b>array2</b> <i></i>
)
</pre>
<dd> Comparison function for the computed table. Returns 0 if
  the two arrays are equal; 1 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="array_hash"></A>
static int <I></I>
<B>array_hash</B>(
  char * <b>array</b>, <i></i>
  int  <b>modulus</b> <i></i>
)
</pre>
<dd> Hash function for the computed table. Returns the bucket
  number.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="bddAnnotateMintermCount"></A>
static double <I></I>
<B>bddAnnotateMintermCount</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  double  <b>max</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Annotates every node in the BDD node with its minterm count.
  In this function, every node and the minterm count represented by it are
  stored in a hash table.
<p>

<dd> <b>Side Effects</b> Fills up 'table' with the pair <node,minterm_count>.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="bddCheckPositiveCube"></A>
static int <I></I>
<B>bddCheckPositiveCube</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="bddCorrelationAux"></A>
static double <I></I>
<B>bddCorrelationAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCorrelation.
  Returns the fraction of minterms in the ON-set of the EXNOR of f and
  g.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddCorrelationWeightsAux">bddCorrelationWeightsAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="bddCorrelationWeightsAux"></A>
static double <I></I>
<B>bddCorrelationWeightsAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  double * <b>prob</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCorrelationWeigths.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddCorrelationAux">bddCorrelationAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddCorr.c"TARGET="ABSTRACT"><CODE>cuddBddCorr.c</CODE></A>

<dt><pre>
<A NAME="bddFixTree"></A>
static void <I></I>
<B>bddFixTree</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Fixes the BDD variable group tree after a
  shuffle. Assumes that the order of the variables in a terminal node
  has not been changed.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="bddVarToCanonicalSimple"></A>
static int <I></I>
<B>bddVarToCanonicalSimple</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>fp</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  unsigned int * <b>topfp</b>, <i></i>
  unsigned int * <b>topgp</b>, <i></i>
  unsigned int * <b>tophp</b> <i></i>
)
</pre>
<dd> Makes sure the first two pointers are regular.  This
  mat require the complementation of the result, which is signaled by
  returning 1 instead of 0.  This function is simpler than the general
  case because it assumes that no two arguments are the same or
  complementary, and no argument is constant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddVarToConst">bddVarToConst</a>
<a href="#bddVarToCanonical">bddVarToCanonical</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="bddVarToCanonical"></A>
static int <I></I>
<B>bddVarToCanonical</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode ** <b>fp</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  unsigned int * <b>topfp</b>, <i></i>
  unsigned int * <b>topgp</b>, <i></i>
  unsigned int * <b>tophp</b> <i></i>
)
</pre>
<dd> Reduces 2 variable expressions to canonical form.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddVarToConst">bddVarToConst</a>
<a href="#bddVarToCanonicalSimple">bddVarToCanonicalSimple</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="bddVarToConst"></A>
static void <I></I>
<B>bddVarToConst</B>(
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  DdNode * <b>one</b> <i></i>
)
</pre>
<dd> This function performs part of the transformation to
  standard form by replacing variables with constants if possible.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bddVarToCanonical">bddVarToCanonical</a>
<a href="#bddVarToCanonicalSimple">bddVarToCanonicalSimple</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="beforep"></A>
static int <I></I>
<B>beforep</B>(
  DdHalfWord  <b>var1a</b>, <i></i>
  short  <b>phase1a</b>, <i></i>
  DdHalfWord  <b>var1b</b>, <i></i>
  short  <b>phase1b</b>, <i></i>
  DdHalfWord  <b>var2a</b>, <i></i>
  short  <b>phase2a</b>, <i></i>
  DdHalfWord  <b>var2b</b>, <i></i>
  short  <b>phase2b</b> <i></i>
)
</pre>
<dd> Returns true iff the first argument precedes the second
  in the clause order.  A clause precedes another if its first lieral
  precedes the first literal of the other, or if the first literals
  are the same, and its second literal precedes the second literal of
  the other clause.  A literal precedes another if it has a higher
  index, of if it has the same index, but it has lower phase.  Phase 0
  is the positive phase, and it is lower than Phase 1 (negative
  phase).
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#equalp">equalp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorAlloc"></A>
static BitVector * <I></I>
<B>bitVectorAlloc</B>(
  int  <b>size</b> <i></i>
)
</pre>
<dd> Allocates a bit vector.  The parameter size gives the
  number of bits.  This procedure allocates enough long's to hold the
  specified number of bits.  Returns a pointer to the allocated vector
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorClear">bitVectorClear</a>
<a href="#bitVectorFree">bitVectorFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorClear"></A>
static void <I></I>
<B>bitVectorClear</B>(
  BitVector * <b>vector</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Clears a bit vector.  The parameter size gives the
  number of bits.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorAlloc">bitVectorAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorFree"></A>
static void <I></I>
<B>bitVectorFree</B>(
  BitVector * <b>vector</b> <i></i>
)
</pre>
<dd> Frees a bit vector.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorAlloc">bitVectorAlloc</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorRead"></A>
static short <I></I>
<B>bitVectorRead</B>(
  BitVector * <b>vector</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Returns the i-th entry of a bit vector.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorSet">bitVectorSet</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="bitVectorSet"></A>
static void <I></I>
<B>bitVectorSet</B>(
  BitVector * <b>vector</b>, <i></i>
  int  <b>i</b>, <i></i>
  short  <b>val</b> <i></i>
)
</pre>
<dd> Sets the i-th entry of a bit vector to a value.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#bitVectorRead">bitVectorRead</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="build_dd"></A>
static int <I></I>
<B>build_dd</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>num</b>, <i>the index of the individual to be built</i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Builds a DD from a given order.  This procedure also
  sifts the final order and inserts into the array the size in nodes
  of the result. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="checkSymmInfo"></A>
static int <I></I>
<B>checkSymmInfo</B>(
  DdManager * <b>table</b>, <i></i>
  DdHalfWord * <b>symmInfo</b>, <i></i>
  int  <b>index</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Returns 1 if a variable is the one with the highest index
  among those belonging to a symmetry group that are in the top part of
  the BDD.  The top part is given by level.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#initSymmInfo">initSymmInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="computeClausesWithUniverse"></A>
static DdTlcInfo * <I></I>
<B>computeClausesWithUniverse</B>(
  DdTlcInfo * <b>Cres</b>, <i>list of clauses for child</i>
  DdHalfWord  <b>label</b>, <i>variable labeling the current node</i>
  short  <b>phase</b> <i>0 if E child is zero; 1 if T child is zero</i>
)
</pre>
<dd> Computes the two-literal clauses for a node with a zero
  child, given the clauses for its other child and the label of the
  node.  Returns a pointer to a TclInfo structure if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#computeClauses">computeClauses</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="computeClauses"></A>
static DdTlcInfo * <I></I>
<B>computeClauses</B>(
  DdTlcInfo * <b>Tres</b>, <i>list of clauses for T child</i>
  DdTlcInfo * <b>Eres</b>, <i>list of clauses for E child</i>
  DdHalfWord  <b>label</b>, <i>variable labeling the current node</i>
  int  <b>size</b> <i>number of variables in the manager</i>
)
</pre>
<dd> Computes the two-literal clauses for a node given the
  clauses for its children and the label of the node.  Returns a
  pointer to a TclInfo structure if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#computeClausesWithUniverse">computeClausesWithUniverse</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="computeLB"></A>
static int <I></I>
<B>computeLB</B>(
  DdManager * <b>table</b>, <i>manager</i>
  DdHalfWord * <b>order</b>, <i>optimal order for the subset</i>
  int  <b>roots</b>, <i>roots between lower and upper</i>
  int  <b>cost</b>, <i>minimum cost for the subset</i>
  int  <b>lower</b>, <i>lower level to be reordered</i>
  int  <b>upper</b>, <i>upper level to be reordered</i>
  int  <b>level</b> <i>offset for the current top bottom var</i>
)
</pre>
<dd> Computes a lower bound on the size of a BDD from the
  following factors:
  <ul>
  <li> size of the lower part of it;
  <li> size of the part of the upper part not subjected to reordering;
  <li> number of roots in the part of the BDD subjected to reordering;
  <li> variable in the support of the roots in the upper part of the
       BDD subjected to reordering.
  <ul/>
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="computeSavings"></A>
static int <I></I>
<B>computeSavings</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>skip</b>, <i></i>
  ApproxInfo * <b>info</b>, <i></i>
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Counts the nodes that would be eliminated if a given
  node were replaced by zero. This procedure uses a queue passed by
  the caller for efficiency: since the queue is left empty at the
  endof the search, it can be reused as is by the next search. Returns
  the count (always striclty positive) if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="copyOrder"></A>
static void <I></I>
<B>copyOrder</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Copies the current variable order to array.
  At the same time inverts the permutation.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="createResult"></A>
static DdNode * <I></I>
<B>createResult</B>(
  DdManager * <b>dd</b>, <i></i>
  unsigned int  <b>index</b>, <i></i>
  unsigned int  <b>phase</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  CUDD_VALUE_TYPE  <b>distance</b> <i></i>
)
</pre>
<dd> Builds a result for cache storage.  Returns a pointer
  to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddClosestCube">cuddBddClosestCube</a>
separateCube
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddAddApplyRecur"></A>
DdNode * <I></I>
<B>cuddAddApplyRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_AOP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addApply. Returns a
  pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAddMonadicApplyRecur">cuddAddMonadicApplyRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="cuddAddBddDoPattern"></A>
DdNode * <I></I>
<B>cuddAddBddDoPattern</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_addBddPattern. Returns a
  pointer to the resulting BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="cuddAddCmplRecur"></A>
DdNode * <I></I>
<B>cuddAddCmplRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addCmpl. Returns a
  pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addCmpl">Cudd_addCmpl</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddAddComposeRecur"></A>
DdNode * <I></I>
<B>cuddAddComposeRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>proj</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addCompose.
  Returns the composed BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addCompose">Cudd_addCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddConstrainRecur"></A>
DdNode * <I></I>
<B>cuddAddConstrainRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addConstrain.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addConstrain">Cudd_addConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddAddExistAbstractRecur"></A>
DdNode * <I></I>
<B>cuddAddExistAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addExistAbstract.
  Returns the ADD obtained by abstracting the variables of cube from f,
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddAddGeneralVectorComposeRecur"></A>
static DdNode * <I></I>
<B>cuddAddGeneralVectorComposeRecur</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>f</b>, <i>ADD in which to compose</i>
  DdNode ** <b>vectorOn</b>, <i>functions to substitute for x_i</i>
  DdNode ** <b>vectorOff</b>, <i>functions to substitute for x_i'</i>
  int  <b>deepest</b> <i>depth of deepest substitution</i>
)
</pre>
<dd> Performs the recursive step of Cudd_addGeneralVectorCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddIteRecur"></A>
DdNode * <I></I>
<B>cuddAddIteRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addIte(f,g,h).
  Returns a pointer to the resulting ADD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addIte">Cudd_addIte</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddIte.c"TARGET="ABSTRACT"><CODE>cuddAddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddAddMonadicApplyRecur"></A>
DdNode * <I></I>
<B>cuddAddMonadicApplyRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DD_MAOP  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addMonadicApply. Returns a
  pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAddApplyRecur">cuddAddApplyRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddApply.c"TARGET="ABSTRACT"><CODE>cuddAddApply.c</CODE></A>

<dt><pre>
<A NAME="cuddAddNegateRecur"></A>
DdNode * <I></I>
<B>cuddAddNegateRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addNegate.
  Returns a pointer to the result.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddNeg.c"TARGET="ABSTRACT"><CODE>cuddAddNeg.c</CODE></A>

<dt><pre>
<A NAME="cuddAddNonSimComposeRecur"></A>
static DdNode * <I></I>
<B>cuddAddNonSimComposeRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>vector</b>, <i></i>
  DdNode * <b>key</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  int  <b>lastsub</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addNonSimCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddOrAbstractRecur"></A>
DdNode * <I></I>
<B>cuddAddOrAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addOrAbstract.
  Returns the ADD obtained by abstracting the variables of cube from f,
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddAddOuterSumRecur"></A>
static DdNode * <I></I>
<B>cuddAddOuterSumRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>M</b>, <i></i>
  DdNode * <b>r</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addOuterSum.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddMatMult.c"TARGET="ABSTRACT"><CODE>cuddMatMult.c</CODE></A>

<dt><pre>
<A NAME="cuddAddPermuteRecur"></A>
static DdNode * <I></I>
<B>cuddAddPermuteRecur</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>node</b>, <i>ADD to be reordered</i>
  int * <b>permut</b> <i>permutation array</i>
)
</pre>
<dd> Recursively puts the ADD in the order given in the
  array permut. Checks for trivial cases to terminate recursion, then
  splits on the children of this node.  Once the solutions for the
  children are obtained, it puts into the current position the node
  from the rest of the ADD that should be here. Then returns this ADD.
  The key here is that the node being visited is NOT put in its proper
  place by this instance, but rather is switched when its proper
  position is reached in the recursion tree.<p>
  The DdNode * that is returned is the same ADD as passed in as node,
  but in the new order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addPermute">Cudd_addPermute</a>
<a href="#cuddBddPermuteRecur">cuddBddPermuteRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAddRestrictRecur"></A>
DdNode * <I></I>
<B>cuddAddRestrictRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addRestrict.
  Returns the restricted ADD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_addRestrict">Cudd_addRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddAddRoundOffRecur"></A>
DdNode * <I></I>
<B>cuddAddRoundOffRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  double  <b>trunc</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_addRoundOff.
  Returns a pointer to the result.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddNeg.c"TARGET="ABSTRACT"><CODE>cuddAddNeg.c</CODE></A>

<dt><pre>
<A NAME="cuddAddScalarInverseRecur"></A>
DdNode * <I></I>
<B>cuddAddScalarInverseRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>epsilon</b> <i></i>
)
</pre>
<dd> Returns a pointer to the resulting ADD in case of
  success. Returns NULL if any discriminants smaller than epsilon is
  encountered.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddInv.c"TARGET="ABSTRACT"><CODE>cuddAddInv.c</CODE></A>

<dt><pre>
<A NAME="cuddAddUnivAbstractRecur"></A>
DdNode * <I></I>
<B>cuddAddUnivAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_addUnivAbstract.
  Returns the ADD obtained by abstracting the variables of cube from f,
  if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAddAbs.c"TARGET="ABSTRACT"><CODE>cuddAddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddAddVectorComposeRecur"></A>
static DdNode * <I></I>
<B>cuddAddVectorComposeRecur</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>f</b>, <i>ADD in which to compose</i>
  DdNode ** <b>vector</b>, <i>functions to substitute</i>
  int  <b>deepest</b> <i>depth of deepest substitution</i>
)
</pre>
<dd> Performs the recursive step of Cudd_addVectorCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddAllocNode"></A>
DdNode * <I></I>
<B>cuddAllocNode</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Fast storage allocation for DdNodes in the table. The
  first 4 bytes of a chunk contain a pointer to the next block; the
  rest contains DD_MEM_CHUNK spaces for DdNodes.  Returns a pointer to
  a new node if successful; NULL is memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddAnnealing"></A>
int <I></I>
<B>cuddAnnealing</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Get x, y by random selection. Choose either
  exchange or jump randomly. In case of jump, choose between jump_up
  and jump_down randomly. Do exchange or jump and get optimal case.
  Loop until there is no improvement or temperature reaches
  minimum. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="cuddApaCountMintermAux"></A>
static DdApaNumber <I></I>
<B>cuddApaCountMintermAux</B>(
  DdNode * <b>node</b>, <i></i>
  int  <b>digits</b>, <i></i>
  DdApaNumber  <b>max</b>, <i></i>
  DdApaNumber  <b>min</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_ApaCountMinterm.
  It is based on the following identity. Let |f| be the
  number of minterms of f. Then:
  <xmp>
    |f| = (|f0|+|f1|)/2
  </xmp>
  where f0 and f1 are the two cofactors of f.
  Uses the identity <code>|f'| = max - |f|</code>.
  The procedure expects the argument "node" to be a regular pointer, and
  guarantees this condition is met in the recursive calls.
  For efficiency, the result of a call is cached only if the node has
  a reference count greater than 1.
  Returns the number of minterms of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="cuddApaStCountfree"></A>
static enum st_retval <I></I>
<B>cuddApaStCountfree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts
  recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApa.c"TARGET="ABSTRACT"><CODE>cuddApa.c</CODE></A>

<dt><pre>
<A NAME="cuddBddAlignToZdd"></A>
int <I></I>
<B>cuddBddAlignToZdd</B>(
  DdManager * <b>table</b> <i>DD manager</i>
)
</pre>
<dd> Reorders BDD variables according to the order of the
  ZDD variables. This function can be called at the end of ZDD
  reordering to insure that the order of the BDD variables is
  consistent with the order of the ZDD variables. The number of ZDD
  variables must be a multiple of the number of BDD variables. Let
  <code>M</code> be the ratio of the two numbers. cuddBddAlignToZdd
  then considers the ZDD variables from <code>M*i</code> to
  <code>(M+1)*i-1</code> as corresponding to BDD variable
  <code>i</code>.  This function should be normally called from
  Cudd_zddReduceHeap, which clears the cache.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable order for all diagrams and performs
  garbage collection of the BDD unique table.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ShuffleHeap">Cudd_ShuffleHeap</a>
<a href="#Cudd_zddReduceHeap">Cudd_zddReduceHeap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddBddAndAbstractRecur"></A>
DdNode * <I></I>
<B>cuddBddAndAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the AND of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.
  Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAndAbs.c"TARGET="ABSTRACT"><CODE>cuddAndAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddAndRecur"></A>
DdNode * <I></I>
<B>cuddBddAndRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddAnd by taking
  the conjunction of two BDDs.  Returns a pointer to the result is
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAnd">Cudd_bddAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBddBooleanDiffRecur"></A>
DdNode * <I></I>
<B>cuddBddBooleanDiffRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>var</b> <i></i>
)
</pre>
<dd> Performs the recursive steps of Cudd_bddBoleanDiff.
  Returns the BDD obtained by XORing the cofactors of f with respect to
  var if successful; NULL otherwise. Exploits the fact that dF/dx =
  dF'/dx.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddCharToVect"></A>
static DdNode * <I></I>
<B>cuddBddCharToVect</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>x</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCharToVect.
  This function maintains the invariant that f is non-zero.
  Returns the i-th component of the vector if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCharToVect">Cudd_bddCharToVect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClipAndAbsRecur"></A>
static DdNode * <I></I>
<B>cuddBddClipAndAbsRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b>, <i></i>
  int  <b>distance</b>, <i></i>
  int  <b>direction</b> <i></i>
)
</pre>
<dd> Approximates the AND of two BDDs and simultaneously
  abstracts the variables in cube. The variables are existentially
  abstracted.  Returns a pointer to the result is successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClippingAndAbstract">Cudd_bddClippingAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClippingAndAbstract"></A>
DdNode * <I></I>
<B>cuddBddClippingAndAbstract</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  DdNode * <b>cube</b>, <i>cube of variables to be abstracted</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g and
  simultaneously abstracts the variables in cube. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClippingAndAbstract">Cudd_bddClippingAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClippingAndRecur"></A>
static DdNode * <I></I>
<B>cuddBddClippingAndRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  int  <b>distance</b>, <i></i>
  int  <b>direction</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddClippingAnd by taking
  the conjunction of two BDDs.  Returns a pointer to the result is
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddClippingAnd">cuddBddClippingAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClippingAnd"></A>
DdNode * <I></I>
<B>cuddBddClippingAnd</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>first conjunct</i>
  DdNode * <b>g</b>, <i>second conjunct</i>
  int  <b>maxDepth</b>, <i>maximum recursion depth</i>
  int  <b>direction</b> <i>under (0) or over (1) approximation</i>
)
</pre>
<dd> Approximates the conjunction of two BDDs f and g. Returns a
  pointer to the resulting BDD if successful; NULL if the intermediate
  result blows up.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClippingAnd">Cudd_bddClippingAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddClip.c"TARGET="ABSTRACT"><CODE>cuddClip.c</CODE></A>

<dt><pre>
<A NAME="cuddBddClosestCube"></A>
DdNode * <I></I>
<B>cuddBddClosestCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  CUDD_VALUE_TYPE  <b>bound</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddClosestCube.
  Returns the cube if succesful; NULL otherwise.  The procedure uses a
  four-way recursion to examine all four combinations of cofactors of
  <code>f</code> and <code>g</code> according to the following formula.
  <pre>
    H(f,g) = min(H(ft,gt), H(fe,ge), H(ft,ge)+1, H(fe,gt)+1)
  </pre>
  Bounding is based on the following observations.
  <ul>
  <li> If we already found two points at distance 0, there is no point in
       continuing.  Furthermore,
  <li> If F == not(G) then the best we can hope for is a minimum distance
       of 1.  If we have already found two points at distance 1, there is
       no point in continuing.  (Indeed, H(F,G) == 1 in this case.  We
       have to continue, though, to find the cube.)
  </ul>
  The variable <code>bound</code> is set at the largest value of the distance
  that we are still interested in.  Therefore, we desist when
  <pre>
    (bound == -1) and (F != not(G)) or (bound == 0) and (F == not(G)).
  </pre>
  If we were maximally aggressive in using the bound, we would always
  set the bound to the minimum distance seen thus far minus one.  That
  is, we would maintain the invariant
  <pre>
    bound < minD,
  </pre>
  except at the very beginning, when we have no value for
  <code>minD</code>.<p>

  However, we do not use <code>bound < minD</code> when examining the
  two negative cofactors, because we try to find a large cube at
  minimum distance.  To do so, we try to find a cube in the negative
  cofactors at the same or smaller distance from the cube found in the
  positive cofactors.<p>

  When we compute <code>H(ft,ge)</code> and <code>H(fe,gt)</code> we
  know that we are going to add 1 to the result of the recursive call
  to account for the difference in the splitting variable.  Therefore,
  we decrease the bound correspondingly.<p>

  Another important observation concerns the need of examining all
  four pairs of cofators only when both <code>f</code> and
  <code>g</code> depend on the top variable.<p>

  Suppose <code>gt == ge == g</code>.  (That is, <code>g</code> does
  not depend on the top variable.)  Then
  <pre>
    H(f,g) = min(H(ft,g), H(fe,g), H(ft,g)+1, H(fe,g)+1)
	   = min(H(ft,g), H(fe,g)) .
  </pre>
  Therefore, under these circumstances, we skip the two "cross" cases.<p>

  An interesting feature of this function is the scheme used for
  caching the results in the global computed table.  Since we have a
  cube and a distance, we combine them to form an ADD.  The
  combination replaces the zero child of the top node of the cube with
  the negative of the distance.  (The use of the negative is to avoid
  ambiguity with 1.)  The degenerate cases (zero and one) are treated
  specially because the distance is known (0 for one, and infinity for
  zero).
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddClosestCube">Cudd_bddClosestCube</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddBddComposeRecur"></A>
DdNode * <I></I>
<B>cuddBddComposeRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>proj</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddCompose.
  Exploits the fact that the composition of f' with g
  produces the complement of the composition of f with g to better
  utilize the cache.  Returns the composed BDD if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddCompose">Cudd_bddCompose</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddConstrainDecomp"></A>
static int <I></I>
<B>cuddBddConstrainDecomp</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>decomp</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddConstrainDecomp.
  Returns f super (i) if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrainDecomp">Cudd_bddConstrainDecomp</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddConstrainRecur"></A>
DdNode * <I></I>
<B>cuddBddConstrainRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddConstrain.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddConstrain">Cudd_bddConstrain</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddExistAbstractRecur"></A>
DdNode * <I></I>
<B>cuddBddExistAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Performs the recursive steps of Cudd_bddExistAbstract.
  Returns the BDD obtained by abstracting the variables
  of cube from f if successful; NULL otherwise. It is also used by
  Cudd_bddUnivAbstract.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddExistAbstract">Cudd_bddExistAbstract</a>
<a href="#Cudd_bddUnivAbstract">Cudd_bddUnivAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddIntersectRecur"></A>
DdNode * <I></I>
<B>cuddBddIntersectRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddIntersect.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIntersect">Cudd_bddIntersect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBddIsop"></A>
DdNode	* <I></I>
<B>cuddBddIsop</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddIsop.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddIsop">Cudd_bddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="cuddBddIteRecur"></A>
DdNode * <I></I>
<B>cuddBddIteRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddIte. Returns a
  pointer to the resulting BDD. NULL if the intermediate result blows
  up or if reordering occurs.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLICBuildResult"></A>
static DdNode * <I></I>
<B>cuddBddLICBuildResult</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>cache</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Builds the results of Cudd_bddLICompaction.
  Returns a pointer to the minimized BDD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
<a href="#cuddBddLICMarkEdges">cuddBddLICMarkEdges</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLICMarkEdges"></A>
static int <I></I>
<B>cuddBddLICMarkEdges</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  st_table * <b>cache</b> <i></i>
)
</pre>
<dd> Performs the edge marking step of Cudd_bddLICompaction.
  Returns the LUB of the markings of the two outgoing edges of <code>f</code>
  if successful; otherwise CUDD_OUT_OF_MEM.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
<a href="#cuddBddLICBuildResult">cuddBddLICBuildResult</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLICompaction"></A>
DdNode * <I></I>
<B>cuddBddLICompaction</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>function to be minimized</i>
  DdNode * <b>c</b> <i>constraint (care set)</i>
)
</pre>
<dd> Performs safe minimization of a BDD. Given the BDD
  <code>f</code> of a function to be minimized and a BDD
  <code>c</code> representing the care set, Cudd_bddLICompaction
  produces the BDD of a function that agrees with <code>f</code>
  wherever <code>c</code> is 1.  Safe minimization means that the size
  of the result is guaranteed not to exceed the size of
  <code>f</code>. This function is based on the DAC97 paper by Hong et
  al..  Returns a pointer to the result if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddLICompaction">Cudd_bddLICompaction</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddLiteralSetIntersectionRecur"></A>
DdNode * <I></I>
<B>cuddBddLiteralSetIntersectionRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of
  Cudd_bddLiteralSetIntersection. Scans the cubes for common variables,
  and checks whether they agree in phase.  Returns a pointer to the
  resulting cube if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLiteral.c"TARGET="ABSTRACT"><CODE>cuddLiteral.c</CODE></A>

<dt><pre>
<A NAME="cuddBddMakePrime"></A>
DdNode * <I></I>
<B>cuddBddMakePrime</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>cube</b>, <i>cube to be expanded</i>
  DdNode * <b>f</b> <i>function of which the cube is to be made a prime</i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddMakePrime.
  Returns the prime if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="cuddBddNPAndRecur"></A>
DdNode * <I></I>
<B>cuddBddNPAndRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddNPAnd.
  Returns a pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddNPAnd">Cudd_bddNPAnd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddPermuteRecur"></A>
static DdNode * <I></I>
<B>cuddBddPermuteRecur</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>node</b>, <i>BDD to be reordered</i>
  int * <b>permut</b> <i>permutation array</i>
)
</pre>
<dd> Recursively puts the BDD in the order given in the array permut.
  Checks for trivial cases to terminate recursion, then splits on the
  children of this node.  Once the solutions for the children are
  obtained, it puts into the current position the node from the rest of
  the BDD that should be here. Then returns this BDD.
  The key here is that the node being visited is NOT put in its proper
  place by this instance, but rather is switched when its proper position
  is reached in the recursion tree.<p>
  The DdNode * that is returned is the same BDD as passed in as node,
  but in the new order.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPermute">Cudd_bddPermute</a>
<a href="#cuddAddPermuteRecur">cuddAddPermuteRecur</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddRestrictRecur"></A>
DdNode * <I></I>
<B>cuddBddRestrictRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>c</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddRestrict.
  Returns the restricted BDD if successful; otherwise NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddRestrict">Cudd_bddRestrict</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddSqueeze"></A>
static DdNode * <I></I>
<B>cuddBddSqueeze</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>l</b>, <i></i>
  DdNode * <b>u</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddSqueeze.  This
  procedure exploits the fact that if we complement and swap the
  bounds of the interval we obtain a valid solution by taking the
  complement of the solution to the original problem. Therefore, we
  can enforce the condition that the upper bound is always regular.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddSqueeze">Cudd_bddSqueeze</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenCof.c"TARGET="ABSTRACT"><CODE>cuddGenCof.c</CODE></A>

<dt><pre>
<A NAME="cuddBddTransferRecur"></A>
static DdNode * <I></I>
<B>cuddBddTransferRecur</B>(
  DdManager * <b>ddS</b>, <i></i>
  DdManager * <b>ddD</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddTransfer.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddTransfer">cuddBddTransfer</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="cuddBddTransfer"></A>
DdNode * <I></I>
<B>cuddBddTransfer</B>(
  DdManager * <b>ddS</b>, <i></i>
  DdManager * <b>ddD</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Convert a BDD from a manager to another one. Returns a
  pointer to the BDD in the destination manager if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddTransfer">Cudd_bddTransfer</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="cuddBddVarMapRecur"></A>
static DdNode * <I></I>
<B>cuddBddVarMapRecur</B>(
  DdManager * <b>manager</b>, <i>DD manager</i>
  DdNode * <b>f</b> <i>BDD to be remapped</i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddVarMap.
  Returns a pointer to the result if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddVarMap">Cudd_bddVarMap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddVectorComposeRecur"></A>
static DdNode * <I></I>
<B>cuddBddVectorComposeRecur</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdHashTable * <b>table</b>, <i>computed table</i>
  DdNode * <b>f</b>, <i>BDD in which to compose</i>
  DdNode ** <b>vector</b>, <i>functions to be composed</i>
  int  <b>deepest</b> <i>depth of the deepest substitution</i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddVectorCompose.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="cuddBddXorExistAbstractRecur"></A>
DdNode * <I></I>
<B>cuddBddXorExistAbstractRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>cube</b> <i></i>
)
</pre>
<dd> Takes the exclusive OR of two BDDs and simultaneously abstracts
  the variables in cube. The variables are existentially abstracted.  Returns a
  pointer to the result is successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddAndAbstract">Cudd_bddAndAbstract</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddAbs.c"TARGET="ABSTRACT"><CODE>cuddBddAbs.c</CODE></A>

<dt><pre>
<A NAME="cuddBddXorRecur"></A>
DdNode * <I></I>
<B>cuddBddXorRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_bddXor by taking
  the exclusive OR of two BDDs.  Returns a pointer to the result is
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddXor">Cudd_bddXor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBddIte.c"TARGET="ABSTRACT"><CODE>cuddBddIte.c</CODE></A>

<dt><pre>
<A NAME="cuddBiasedUnderApprox"></A>
DdNode * <I></I>
<B>cuddBiasedUnderApprox</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  DdNode * <b>b</b>, <i>bias function</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  double  <b>quality1</b>, <i>minimum improvement for accepted changes when b=1</i>
  double  <b>quality0</b> <i>minimum improvement for accepted changes when b=0</i>
)
</pre>
<dd> Applies the biased remapping underappoximation algorithm.
  Proceeds in three phases:
  <ul>
  <li> collect information on each node in the BDD; this is done via DFS.
  <li> traverse the BDD in top-down fashion and compute for each node
  whether remapping increases density.
  <li> traverse the BDD via DFS and actually perform the elimination.
  </ul>
  Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_BiasedUnderApprox">Cudd_BiasedUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="cuddCProjectionRecur"></A>
DdNode * <I></I>
<B>cuddCProjectionRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>R</b>, <i></i>
  DdNode * <b>Y</b>, <i></i>
  DdNode * <b>Ysupp</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CProjection. Returns
  the projection if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CProjection">Cudd_CProjection</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheFlush"></A>
void <I></I>
<B>cuddCacheFlush</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Flushes the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheInsert1"></A>
void <I></I>
<B>cuddCacheInsert1</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with two
  operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheInsert">cuddCacheInsert</a>
<a href="#cuddCacheInsert2">cuddCacheInsert2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheInsert2"></A>
void <I></I>
<B>cuddCacheInsert2</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache for a function with two
  operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheInsert">cuddCacheInsert</a>
<a href="#cuddCacheInsert1">cuddCacheInsert1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheInsert"></A>
void <I></I>
<B>cuddCacheInsert</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  DdNode * <b>data</b> <i></i>
)
</pre>
<dd> Inserts a result in the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheInsert2">cuddCacheInsert2</a>
<a href="#cuddCacheInsert1">cuddCacheInsert1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup1Zdd"></A>
DdNode * <I></I>
<B>cuddCacheLookup1Zdd</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookupZdd">cuddCacheLookupZdd</a>
<a href="#cuddCacheLookup2Zdd">cuddCacheLookup2Zdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup1"></A>
DdNode * <I></I>
<B>cuddCacheLookup1</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP1  <b>op</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup">cuddCacheLookup</a>
<a href="#cuddCacheLookup2">cuddCacheLookup2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup2Zdd"></A>
DdNode * <I></I>
<B>cuddCacheLookup2Zdd</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookupZdd">cuddCacheLookupZdd</a>
<a href="#cuddCacheLookup1Zdd">cuddCacheLookup1Zdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup2"></A>
DdNode * <I></I>
<B>cuddCacheLookup2</B>(
  DdManager * <b>table</b>, <i></i>
  DD_CTFP  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup">cuddCacheLookup</a>
<a href="#cuddCacheLookup1">cuddCacheLookup1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookupZdd"></A>
DdNode * <I></I>
<B>cuddCacheLookupZdd</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup2Zdd">cuddCacheLookup2Zdd</a>
<a href="#cuddCacheLookup1Zdd">cuddCacheLookup1Zdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheLookup"></A>
DdNode * <I></I>
<B>cuddCacheLookup</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Returns the result if found; it returns NULL if no
  result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup2">cuddCacheLookup2</a>
<a href="#cuddCacheLookup1">cuddCacheLookup1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheProfile"></A>
int <I></I>
<B>cuddCacheProfile</B>(
  DdManager * <b>table</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Computes and prints a profile of the cache usage.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCacheResize"></A>
void <I></I>
<B>cuddCacheResize</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Resizes the cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddCheckCollisionOrdering"></A>
static int <I></I>
<B>cuddCheckCollisionOrdering</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b>, <i></i>
  int  <b>j</b> <i></i>
)
</pre>
<dd> Checks whether a collision list is ordered.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddCheckCube"></A>
int <I></I>
<B>cuddCheckCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Checks whether g is the BDD of a cube. Returns 1 in case
  of success; 0 otherwise. The constant 1 is a valid cube, but all other
  constant functions cause cuddCheckCube to return 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCof.c"TARGET="ABSTRACT"><CODE>cuddCof.c</CODE></A>

<dt><pre>
<A NAME="cuddClearDeathRow"></A>
void <I></I>
<B>cuddClearDeathRow</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Clears the death row.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="#Cudd_IterDerefBdd">Cudd_IterDerefBdd</a>
<a href="#Cudd_CheckZeroRef">Cudd_CheckZeroRef</a>
<a href="#cuddGarbageCollect">cuddGarbageCollect</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddCofactorRecur"></A>
DdNode * <I></I>
<B>cuddCofactorRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_Cofactor. Returns a
  pointer to the cofactor if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Cofactor">Cudd_Cofactor</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCof.c"TARGET="ABSTRACT"><CODE>cuddCof.c</CODE></A>

<dt><pre>
<A NAME="cuddCollectNodes"></A>
int <I></I>
<B>cuddCollectNodes</B>(
  DdNode * <b>f</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Traverses the DD f and collects all its nodes in a
  symbol table.  f is assumed to be a regular pointer and
  cuddCollectNodes guarantees this assumption in the recursive calls.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddComputeFloorLog2"></A>
int <I></I>
<B>cuddComputeFloorLog2</B>(
  unsigned int  <b>value</b> <i></i>
)
</pre>
<dd> Returns the floor of the logarithm to the base 2.
  The input value is assumed to be greater than 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddConjunctsAux"></A>
static int <I></I>
<B>cuddConjunctsAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>c1</b>, <i></i>
  DdNode ** <b>c2</b> <i></i>
)
</pre>
<dd> Procedure to compute two conjunctive factors of f and
  place in *c1 and *c2. Sets up the required data - table of distances
  from the constant and local reference count. Also minterm table.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddDecomp.c"TARGET="ABSTRACT"><CODE>cuddDecomp.c</CODE></A>

<dt><pre>
<A NAME="cuddConstantLookup"></A>
DdNode * <I></I>
<B>cuddConstantLookup</B>(
  DdManager * <b>table</b>, <i></i>
  ptruint  <b>op</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Looks up in the cache for the result of op applied to f,
  g, and h. Assumes that the calling procedure (e.g.,
  Cudd_bddIteConstant) is only interested in whether the result is
  constant or not. Returns the result if found (possibly
  DD_NON_CONSTANT); otherwise it returns NULL.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddCacheLookup">cuddCacheLookup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddDestroySubtables"></A>
int <I></I>
<B>cuddDestroySubtables</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>n</b> <i></i>
)
</pre>
<dd> Destroys the n most recently created subtables in a unique
  table.  n should be positive. The subtables should not contain any live
  nodes, except the (isolated) projection function. The projection
  functions are freed.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> The variable map used for fast variable substitution is
  destroyed if it exists. In this case the cache is also cleared.
<p>

<dd> <b>See Also</b> <code><a href="#cuddInsertSubtables">cuddInsertSubtables</a>
<a href="#Cudd_SetVarMap">Cudd_SetVarMap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddDoRebalance"></A>
static void <I></I>
<B>cuddDoRebalance</B>(
  DdNodePtr ** <b>stack</b>, <i></i>
  int  <b>stackN</b> <i></i>
)
</pre>
<dd> Rebalances a red/black tree.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddDynamicAllocNode"></A>
DdNode * <I></I>
<B>cuddDynamicAllocNode</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Dynamically allocates a Node. This procedure is similar
  to cuddAllocNode in Cudd_Table.c, but it does not attempt garbage
  collection, because during reordering there are no dead nodes.
  Returns a pointer to a new node if successful; NULL is memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAllocNode">cuddAllocNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddEstimateCofactorSimple"></A>
static int <I></I>
<B>cuddEstimateCofactorSimple</B>(
  DdNode * <b>node</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CofactorEstimateSimple.
  Returns an estimate of the number of nodes in the DD of the positive
  cofactor of node. Uses the least significant bit of the next field as
  visited flag. node is supposed to be regular; the invariant is maintained
  by this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddEstimateCofactor"></A>
static int <I></I>
<B>cuddEstimateCofactor</B>(
  DdManager * <b>dd</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>i</b>, <i></i>
  int  <b>phase</b>, <i></i>
  DdNode ** <b>ptr</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CofactorEstimate.
  Returns an estimate of the number of nodes in the DD of a
  cofactor of node. Uses the least significant bit of the next field as
  visited flag. node is supposed to be regular; the invariant is maintained
  by this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddExact"></A>
int <I></I>
<B>cuddExact</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Exact variable ordering algorithm. Finds an optimum
  order for the variables between lower and upper.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="cuddFindParent"></A>
static int <I></I>
<B>cuddFindParent</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Searches the subtables above node for a parent. Returns 1
  as soon as one parent is found. Returns 0 is the search is fruitless.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddFreeTable"></A>
void <I></I>
<B>cuddFreeTable</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Frees the resources associated to a unique table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddInitTable">cuddInitTable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddGarbageCollect"></A>
int <I></I>
<B>cuddGarbageCollect</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>clearCache</b> <i></i>
)
</pre>
<dd> Performs garbage collection on the BDD and ZDD unique tables.
  If clearCache is 0, the cache is not cleared. This should only be
  specified if the cache has been cleared right before calling
  cuddGarbageCollect. (As in the case of dynamic reordering.)
  Returns the total number of deleted nodes.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddGa"></A>
int <I></I>
<B>cuddGa</B>(
  DdManager * <b>table</b>, <i>manager</i>
  int  <b>lower</b>, <i>lowest level to be reordered</i>
  int  <b>upper</b> <i>highest level to be reorderded</i>
)
</pre>
<dd> Genetic algorithm for DD reordering.
  The two children of a crossover will be stored in
  storedd[popsize
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="cuddGetBranches"></A>
void <I></I>
<B>cuddGetBranches</B>(
  DdNode * <b>g</b>, <i></i>
  DdNode ** <b>g1</b>, <i></i>
  DdNode ** <b>g0</b> <i></i>
)
</pre>
<dd> Computes the children of g.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCof.c"TARGET="ABSTRACT"><CODE>cuddCof.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableAlloc"></A>
static DdHashItem * <I></I>
<B>cuddHashTableAlloc</B>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Fast storage allocation for items in a hash table. The
  first 4 bytes of a chunk contain a pointer to the next block; the
  rest contains DD_MEM_CHUNK spaces for hash items.  Returns a pointer to
  a new item if successful; NULL is memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAllocNode">cuddAllocNode</a>
<a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInit"></A>
DdHashTable * <I></I>
<B>cuddHashTableInit</B>(
  DdManager * <b>manager</b>, <i></i>
  unsigned int  <b>keySize</b>, <i></i>
  unsigned int  <b>initSize</b> <i></i>
)
</pre>
<dd> Initializes a hash table. Returns a pointer to the new
  table if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableQuit">cuddHashTableQuit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert1"></A>
int <I></I>
<B>cuddHashTableInsert1</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is one pointer.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert2"></A>
int <I></I>
<B>cuddHashTableInsert2</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is
  composed of two pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert3"></A>
int <I></I>
<B>cuddHashTableInsert3</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key is
  composed of three pointers. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
<a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableInsert"></A>
int <I></I>
<B>cuddHashTableInsert</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNodePtr * <b>key</b>, <i></i>
  DdNode * <b>value</b>, <i></i>
  ptrint  <b>count</b> <i></i>
)
</pre>
<dd> Inserts an item in a hash table when the key has more than
  three pointers.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>[cuddHashTableInsert1
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
<a href="#cuddHashTableLookup">cuddHashTableLookup</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup1"></A>
DdNode * <I></I>
<B>cuddHashTableLookup1</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of one pointer in a hash table.
  Returns the value associated to the key if there is an entry for the given
  key in the table; NULL otherwise. If the entry is present, its reference
  counter is decremented if not saturated. If the counter reaches 0, the
  value of the entry is dereferenced, and the entry is returned to the free
  list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="#cuddHashTableInsert1">cuddHashTableInsert1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup2"></A>
DdNode * <I></I>
<B>cuddHashTableLookup2</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of two pointer in a hash table.
  Returns the value associated to the key if there is an entry for the given
  key in the table; NULL otherwise. If the entry is present, its reference
  counter is decremented if not saturated. If the counter reaches 0, the
  value of the entry is dereferenced, and the entry is returned to the free
  list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="#cuddHashTableInsert2">cuddHashTableInsert2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup3"></A>
DdNode * <I></I>
<B>cuddHashTableLookup3</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of three pointers in a hash table.
  Returns the value associated to the key if there is an entry for the given
  key in the table; NULL otherwise. If the entry is present, its reference
  counter is decremented if not saturated. If the counter reaches 0, the
  value of the entry is dereferenced, and the entry is returned to the free
  list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup">cuddHashTableLookup</a>
<a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="#cuddHashTableInsert3">cuddHashTableInsert3</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableLookup"></A>
DdNode * <I></I>
<B>cuddHashTableLookup</B>(
  DdHashTable * <b>hash</b>, <i></i>
  DdNodePtr * <b>key</b> <i></i>
)
</pre>
<dd> Looks up a key consisting of more than three pointers
  in a hash table.  Returns the value associated to the key if there
  is an entry for the given key in the table; NULL otherwise. If the
  entry is present, its reference counter is decremented if not
  saturated. If the counter reaches 0, the value of the entry is
  dereferenced, and the entry is returned to the free list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableLookup1">cuddHashTableLookup1</a>
<a href="#cuddHashTableLookup2">cuddHashTableLookup2</a>
<a href="#cuddHashTableLookup3">cuddHashTableLookup3</a>
<a href="#cuddHashTableInsert">cuddHashTableInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableQuit"></A>
void <I></I>
<B>cuddHashTableQuit</B>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Shuts down a hash table, dereferencing all the values.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInit">cuddHashTableInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHashTableResize"></A>
static int <I></I>
<B>cuddHashTableResize</B>(
  DdHashTable * <b>hash</b> <i></i>
)
</pre>
<dd> Resizes a hash table. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddHashTableInsert">cuddHashTableInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddHeapProfile"></A>
int <I></I>
<B>cuddHeapProfile</B>(
  DdManager * <b>dd</b> <i></i>
)
</pre>
<dd> Prints to the manager's stdout the number of live nodes for each
  level of the DD heap that contains at least one live node.  It also
  prints a summary containing:
  <ul>
  <li> total number of tables;
  <li> number of tables with live nodes;
  <li> table with the largest number of live nodes;
  <li> number of nodes in that table.
  </ul>
  If more than one table contains the maximum number of live nodes,
  only the one of lowest index is reported. Returns 1 in case of success
  and 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="cuddInitCache"></A>
int <I></I>
<B>cuddInitCache</B>(
  DdManager * <b>unique</b>, <i>unique table</i>
  unsigned int  <b>cacheSize</b>, <i>initial size of the cache</i>
  unsigned int  <b>maxCacheSize</b> <i>cache size beyond which no resizing occurs</i>
)
</pre>
<dd> Initializes the computed table. It is called by
  Cudd_Init. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Init">Cudd_Init</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCache.c"TARGET="ABSTRACT"><CODE>cuddCache.c</CODE></A>

<dt><pre>
<A NAME="cuddInitInteract"></A>
int <I></I>
<B>cuddInitInteract</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Initializes the interaction matrix. The interaction
  matrix is implemented as a bit vector storing the upper triangle of
  the symmetric interaction matrix. The bit vector is kept in an array
  of long integers. The computation is based on a series of depth-first
  searches, one for each root of the DAG. Two flags are needed: The
  local visited flag uses the LSB of the then pointer. The global
  visited flag uses the LSB of the next pointer.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="cuddInitLinear"></A>
int <I></I>
<B>cuddInitLinear</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Initializes the linear transform matrix.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddInitTable"></A>
DdManager * <I></I>
<B>cuddInitTable</B>(
  unsigned int  <b>numVars</b>, <i>Initial number of BDD variables (and subtables)</i>
  unsigned int  <b>numVarsZ</b>, <i>Initial number of ZDD variables (and subtables)</i>
  unsigned int  <b>numSlots</b>, <i>Initial size of the BDD subtables</i>
  unsigned int  <b>looseUpTo</b> <i>Limit for fast table growth</i>
)
</pre>
<dd> Creates and initializes the unique table. Returns a pointer
  to the table if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Init">Cudd_Init</a>
<a href="#cuddFreeTable">cuddFreeTable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddInsertSubtables"></A>
int <I></I>
<B>cuddInsertSubtables</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>n</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Inserts n new subtables in a unique table at level.
  The number n should be positive, and level should be an existing level.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddDestroySubtables">cuddDestroySubtables</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddIsInDeathRow"></A>
int <I></I>
<B>cuddIsInDeathRow</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Checks whether a node is in the death row. Returns the
  position of the first occurrence if the node is present; -1
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="#cuddClearDeathRow">cuddClearDeathRow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueDequeue"></A>
void <I></I>
<B>cuddLevelQueueDequeue</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Remove an item from the front of a level queue.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueEnqueue"></A>
void * <I></I>
<B>cuddLevelQueueEnqueue</B>(
  DdLevelQueue * <b>queue</b>, <i>level queue</i>
  void * <b>key</b>, <i>key to be enqueued</i>
  int  <b>level</b> <i>level at which to insert</i>
)
</pre>
<dd> Inserts a new key in a level queue. A new entry is
  created in the queue only if the node is not already
  enqueued. Returns a pointer to the queue item if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueInit">cuddLevelQueueInit</a>
<a href="#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueInit"></A>
DdLevelQueue * <I></I>
<B>cuddLevelQueueInit</B>(
  int  <b>levels</b>, <i>number of levels</i>
  int  <b>itemSize</b>, <i>size of the item</i>
  int  <b>numBuckets</b> <i>initial number of hash buckets</i>
)
</pre>
<dd> Initializes a level queue. A level queue is a queue
  where inserts are based on the levels of the nodes. Within each
  level the policy is FIFO. Level queues are useful in traversing a
  BDD top-down. Queue items are kept in a free list when dequeued for
  efficiency. Returns a pointer to the new queue if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueQuit">cuddLevelQueueQuit</a>
<a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
<a href="#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLevelQueueQuit"></A>
void <I></I>
<B>cuddLevelQueueQuit</B>(
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Shuts down a level queue and releases all the
  associated memory.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueInit">cuddLevelQueueInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="cuddLinearAndSifting"></A>
int <I></I>
<B>cuddLinearAndSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> BDD reduction based on combination of sifting and linear
  transformations.  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the DD heap. At each position, linear transformation
    of the two adjacent variables is tried and is accepted if it reduces
    the size of the DD.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddLinearInPlace"></A>
int <I></I>
<B>cuddLinearInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Linearly combines two adjacent variables. Specifically,
  replaces the top variable with the exclusive nor of the two variables.
  It assumes that no dead nodes are present on entry to this
  procedure.  The procedure then guarantees that no dead nodes will be
  present when it terminates.  cuddLinearInPlace assumes that x &lt;
  y.  Returns the number of keys in the table if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> The two subtables corrresponding to variables x and y are
  modified. The global counters of the unique table are also affected.
<p>

<dd> <b>See Also</b> <code><a href="#cuddSwapInPlace">cuddSwapInPlace</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheAddToList"></A>
static void <I></I>
<B>cuddLocalCacheAddToList</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Inserts a local cache in the manager list.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheClearAll"></A>
void <I></I>
<B>cuddLocalCacheClearAll</B>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Clears the local caches of a manager.
  Used before reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheClearDead"></A>
void <I></I>
<B>cuddLocalCacheClearDead</B>(
  DdManager * <b>manager</b> <i></i>
)
</pre>
<dd> Clears the dead entries of the local caches of a manager.
  Used during garbage collection.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheInit"></A>
DdLocalCache * <I></I>
<B>cuddLocalCacheInit</B>(
  DdManager * <b>manager</b>, <i>manager</i>
  unsigned int  <b>keySize</b>, <i>size of the key (number of operands)</i>
  unsigned int  <b>cacheSize</b>, <i>Initial size of the cache</i>
  unsigned int  <b>maxCacheSize</b> <i>Size of the cache beyond which no resizing occurs</i>
)
</pre>
<dd> Initializes a computed table.  Returns a pointer the
  the new local cache in case of success; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddInitCache">cuddInitCache</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheInsert"></A>
void <I></I>
<B>cuddLocalCacheInsert</B>(
  DdLocalCache * <b>cache</b>, <i></i>
  DdNodePtr * <b>key</b>, <i></i>
  DdNode * <b>value</b> <i></i>
)
</pre>
<dd> Inserts a result in a local cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheLookup"></A>
DdNode * <I></I>
<B>cuddLocalCacheLookup</B>(
  DdLocalCache * <b>cache</b>, <i></i>
  DdNodePtr * <b>key</b> <i></i>
)
</pre>
<dd> Looks up in a local cache. Returns the result if found;
  it returns NULL if no result is found.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheProfile"></A>
int <I></I>
<B>cuddLocalCacheProfile</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Computes and prints a profile of a local cache usage.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheQuit"></A>
void <I></I>
<B>cuddLocalCacheQuit</B>(
  DdLocalCache * <b>cache</b> <i>cache to be shut down</i>
)
</pre>
<dd> Initializes the computed table. It is called by
  Cudd_Init. Returns a pointer the the new local cache in case of
  success; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLocalCacheInit">cuddLocalCacheInit</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheRemoveFromList"></A>
static void <I></I>
<B>cuddLocalCacheRemoveFromList</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Removes a local cache from the manager list.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddLocalCacheResize"></A>
static void <I></I>
<B>cuddLocalCacheResize</B>(
  DdLocalCache * <b>cache</b> <i></i>
)
</pre>
<dd> Resizes a local cache.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="cuddMakeBddFromZddCover"></A>
DdNode	* <I></I>
<B>cuddMakeBddFromZddCover</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Converts a ZDD cover to a BDD graph. If successful, it
  returns a BDD node, otherwise it returns NULL. It is a recursive
  algorithm as the following. First computes 3 cofactors of a ZDD cover;
  f1, f0 and fd. Second, compute BDDs(b1, b0 and bd) of f1, f0 and fd.
  Third, compute T=b1+bd and E=b0+bd. Fourth, compute ITE(v,T,E) where v
  is the variable which has the index of the top node of the ZDD cover.
  In this case, since the index of v can be larger than either one of T or
  one of E, cuddUniqueInterIVO is called, here IVO stands for
  independent variable ordering.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MakeBddFromZddCover">Cudd_MakeBddFromZddCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="cuddMinHammingDistRecur"></A>
static int <I></I>
<B>cuddMinHammingDistRecur</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>minterm</b>, <i></i>
  DdHashTable * <b>table</b>, <i></i>
  int  <b>upperBound</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_MinHammingDist.
  It is based on the following identity. Let H(f) be the
  minimum Hamming distance of the minterms of f from the reference
  minterm. Then:
  <xmp>
    H(f) = min(H(f0)+h0,H(f1)+h1)
  </xmp>
  where f0 and f1 are the two cofactors of f with respect to its top
  variable; h0 is 1 if the minterm assigns 1 to the top variable of f;
  h1 is 1 if the minterm assigns 0 to the top variable of f.
  The upper bound on the distance is used to bound the depth of the
  recursion.
  Returns the minimum distance unless it exceeds the upper bound or
  computation fails.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_MinHammingDist">Cudd_MinHammingDist</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="cuddNextHigh"></A>
int <I></I>
<B>cuddNextHigh</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a larger index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddNextLow">cuddNextLow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddNextLow"></A>
int <I></I>
<B>cuddNextLow</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a smaller index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddNextHigh">cuddNextHigh</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddNodeArrayRecur"></A>
static int <I></I>
<B>cuddNodeArrayRecur</B>(
  DdNode * <b>f</b>, <i></i>
  DdNodePtr * <b>table</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Performs the recursive step of cuddNodeArray.  Returns
  an the number of nodes in the DD.  Clear the least significant bit
  of the next field that was used as visited flag by
  cuddNodeArrayRecur when counting the nodes.  node is supposed to be
  regular; the invariant is maintained by this procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddNodeArray"></A>
DdNodePtr * <I></I>
<B>cuddNodeArray</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>n</b> <i></i>
)
</pre>
<dd> Traverses the DD f and collects all its nodes in an array.
  The caller should free the array returned by cuddNodeArray.
  Returns a pointer to the array of nodes in case of success; NULL
  otherwise.  The nodes are collected in reverse topological order, so
  that a node is always preceded in the array by all its descendants.
<p>

<dd> <b>Side Effects</b> The number of nodes is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FirstNode">Cudd_FirstNode</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddOrderedInsert"></A>
static void <I></I>
<B>cuddOrderedInsert</B>(
  DdNodePtr * <b>root</b>, <i></i>
  DdNodePtr  <b>node</b> <i></i>
)
</pre>
<dd> Inserts a DdNode in a red/black search tree. Nodes from
  the same "page" (defined by DD_PAGE_MASK) are linked in a LIFO list.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddOrderedThread">cuddOrderedThread</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddOrderedThread"></A>
static DdNode * <I></I>
<B>cuddOrderedThread</B>(
  DdNode * <b>root</b>, <i></i>
  DdNode * <b>list</b> <i></i>
)
</pre>
<dd> Threads all the nodes of a search tree into a linear
  list. For each node of the search tree, the "left" child, if non-null, has
  a lower address than its parent, and the "right" child, if non-null, has a
  higher address than its parent.
  The list is sorted in order of increasing addresses. The search
  tree is destroyed as a result of this operation. The last element of
  the linear list is made to point to the address passed in list. Each
  node if the search tree is a linearly-linked list of nodes from the
  same memory page (as defined in DD_PAGE_MASK). When a node is added to
  the linear list, all the elements of the linked list are added.
<p>

<dd> <b>Side Effects</b> The search tree is destroyed as a result of this operation.
<p>

<dd> <b>See Also</b> <code><a href="#cuddOrderedInsert">cuddOrderedInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddPrintNode"></A>
void <I></I>
<B>cuddPrintNode</B>(
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b> <i></i>
)
</pre>
<dd> Prints out information on a node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="cuddPrintVarGroups"></A>
void <I></I>
<B>cuddPrintVarGroups</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  MtrNode * <b>root</b>, <i>root of the group tree</i>
  int  <b>zdd</b>, <i>0: BDD; 1: ZDD</i>
  int  <b>silent</b> <i>flag to check tree syntax only</i>
)
</pre>
<dd> Prints the variable groups as a parenthesized list.
  For each group the level range that it represents is printed. After
  each group, the group's flags are printed, preceded by a `|'.  For
  each flag (except MTR_TERMINAL) a character is printed.
  <ul>
  <li>F: MTR_FIXED
  <li>N: MTR_NEWNODE
  <li>S: MTR_SOFT
  </ul>
  The second argument, silent, if different from 0, causes
  Cudd_PrintVarGroups to only check the syntax of the group tree.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="cuddP"></A>
int <I></I>
<B>cuddP</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Prints a DD to the standard output. One line per node is
  printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_PrintDebug">Cudd_PrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddReclaimZdd"></A>
void <I></I>
<B>cuddReclaimZdd</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Brings children of a dead ZDD node back.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddReclaim">cuddReclaim</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddReclaim"></A>
void <I></I>
<B>cuddReclaim</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Brings children of a dead node back.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddReclaimZdd">cuddReclaimZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddRehash"></A>
void <I></I>
<B>cuddRehash</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Doubles the size of a unique subtable and rehashes its
  contents.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddRemapUnderApprox"></A>
DdNode * <I></I>
<B>cuddRemapUnderApprox</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Applies the remapping underappoximation algorithm.
  Proceeds in three phases:
  <ul>
  <li> collect information on each node in the BDD; this is done via DFS.
  <li> traverse the BDD in top-down fashion and compute for each node
  whether remapping increases density.
  <li> traverse the BDD via DFS and actually perform the elimination.
  </ul>
  Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_RemapUnderApprox">Cudd_RemapUnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="cuddResizeLinear"></A>
int <I></I>
<B>cuddResizeLinear</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Resizes the linear transform matrix.  Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddResizeTableZdd"></A>
int <I></I>
<B>cuddResizeTableZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Increases the number of ZDD subtables in a unique table so
  that it meets or exceeds index.  When new ZDD variables are created, it
  is possible to preserve the functions unchanged, or it is possible to
  preserve the covers unchanged, but not both. cuddResizeTableZdd preserves
  the covers.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddResizeTable">ddResizeTable</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddRotateLeft"></A>
static void <I></I>
<B>cuddRotateLeft</B>(
  DdNodePtr * <b>nodeP</b> <i></i>
)
</pre>
<dd> Performs the left rotation for red/black trees.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRotateRight">cuddRotateRight</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddRotateRight"></A>
static void <I></I>
<B>cuddRotateRight</B>(
  DdNodePtr * <b>nodeP</b> <i></i>
)
</pre>
<dd> Performs the right rotation for red/black trees.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRotateLeft">cuddRotateLeft</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddSetInteract"></A>
void <I></I>
<B>cuddSetInteract</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Given a pair of variables 0 <= x < y < table->size,
  sets the corresponding bit of the interaction matrix to 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="cuddShrinkDeathRow"></A>
void <I></I>
<B>cuddShrinkDeathRow</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Shrinks the death row by a factor of four.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddClearDeathRow">cuddClearDeathRow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddShrinkSubtable"></A>
void <I></I>
<B>cuddShrinkSubtable</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Shrinks a subtable.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRehash">cuddRehash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddSifting"></A>
int <I></I>
<B>cuddSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of Rudell's sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddSlowTableGrowth"></A>
void <I></I>
<B>cuddSlowTableGrowth</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Adjusts parameters of a table to slow down its growth.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddSolveEqnRecur"></A>
DdNode * <I></I>
<B>cuddSolveEqnRecur</B>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode * <b>Y</b>, <i>the cube of remaining y variables</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int  <b>n</b>, <i>number of unknowns</i>
  int * <b>yIndex</b>, <i>array holding the y variable indices</i>
  int  <b>i</b> <i>level of recursion</i>
)
</pre>
<dd> Implements the recursive step of Cudd_SolveEqn. 
  Returns NULL if the intermediate solution blows up
  or reordering occurs. The parametric solutions are
  stored in the array G.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SolveEqn">Cudd_SolveEqn</a>
<a href="#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSolve.c"TARGET="ABSTRACT"><CODE>cuddSolve.c</CODE></A>

<dt><pre>
<A NAME="cuddSplitSetRecur"></A>
DdNode* <I></I>
<B>cuddSplitSetRecur</B>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>mtable</b>, <i></i>
  int * <b>varSeen</b>, <i></i>
  DdNode * <b>p</b>, <i></i>
  double  <b>n</b>, <i></i>
  double  <b>max</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_SplitSet. The
  procedure recursively traverses the BDD and checks to see if any
  node satisfies the minterm requirements as specified by 'n'. At any
  node X, n is compared to the number of minterms in the onset of X's
  children. If either of the child nodes have exactly n minterms, then
  that node is returned; else, if n is greater than the onset of one
  of the child nodes, that node is retained and the difference in the
  number of minterms is extracted from the other child. In case n
  minterms can be extracted from constant 1, the algorithm returns the
  result with at most log(n) nodes.
<p>

<dd> <b>Side Effects</b> The array 'varSeen' is updated at every recursive call
  to set the variables traversed by the procedure.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="cuddStCountfree"></A>
enum st_retval <I></I>
<B>cuddStCountfree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts
  recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddSubsetHeavyBranch"></A>
DdNode * <I></I>
<B>cuddSubsetHeavyBranch</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b> <i>threshold size for the subset</i>
)
</pre>
<dd> Here a subset BDD is built by throwing away one of the
  children. Starting at root, annotate each node with the number of
  minterms (in terms of the total number of variables specified -
  numVars), number of nodes taken by the DAG rooted at this node and
  number of additional nodes taken by the child that has the lesser
  minterms. The child with the lower number of minterms is thrown away
  and a dyanmic count of the nodes of the subset is kept. Once the
  threshold is reached the subset is returned to the calling
  procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetHeavyBranch">Cudd_SubsetHeavyBranch</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetHB.c"TARGET="ABSTRACT"><CODE>cuddSubsetHB.c</CODE></A>

<dt><pre>
<A NAME="cuddSubsetShortPaths"></A>
DdNode * <I></I>
<B>cuddSubsetShortPaths</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>function to be subset</i>
  int  <b>numVars</b>, <i>total number of variables in consideration</i>
  int  <b>threshold</b>, <i>maximum number of nodes allowed in the subset</i>
  int  <b>hardlimit</b> <i>flag determining whether thershold should be respected strictly</i>
)
</pre>
<dd> The outermost procedure to return a subset of the given
  BDD with the largest cubes. The path lengths are calculated, the maximum
  allowable path length is determined and the number of nodes of this
  path length that can be used to build a subset. If the threshold is
  larger than the size of the original BDD, the original BDD is
  returned.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_SubsetShortPaths">Cudd_SubsetShortPaths</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="cuddSwapInPlace"></A>
int <I></I>
<B>cuddSwapInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps two adjacent variables. It assumes that no dead
  nodes are present on entry to this procedure.  The procedure then
  guarantees that no dead nodes will be present when it terminates.
  cuddSwapInPlace assumes that x &lt; y.  Returns the number of keys in
  the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddSwapping"></A>
int <I></I>
<B>cuddSwapping</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  Cudd_ReorderingType  <b>heuristic</b> <i></i>
)
</pre>
<dd> Implementation of Plessier's algorithm that reorders
  variables by a sequence of (non-adjacent) swaps.
    <ol>
    <li> Select two variables (RANDOM or HEURISTIC).
    <li> Permute these variables.
    <li> If the nodes have decreased accept the permutation.
    <li> Otherwise reconstruct the original heap.
    <li> Loop.
    </ol>
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="cuddSymmCheck"></A>
int <I></I>
<B>cuddSymmCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for symmetry of x and y. Ignores projection
  functions, unless they are isolated. Returns 1 in case of symmetry; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="cuddSymmSiftingConv"></A>
int <I></I>
<B>cuddSymmSiftingConv</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting to convergence algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the DD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    <li> Repeat 1-4 until no further improvement.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddSymmSifting">cuddSymmSifting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="cuddSymmSifting"></A>
int <I></I>
<B>cuddSymmSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the DD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddSymmSiftingConv">cuddSymmSiftingConv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="cuddTestInteract"></A>
int <I></I>
<B>cuddTestInteract</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Given a pair of variables 0 <= x < y < table->size,
  tests whether the corresponding bit of the interaction matrix is 1.
  Returns the value of the bit.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="cuddTimesInDeathRow"></A>
int <I></I>
<B>cuddTimesInDeathRow</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Counts how many times a node is in the death row.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DelayedDerefBdd">Cudd_DelayedDerefBdd</a>
<a href="#cuddClearDeathRow">cuddClearDeathRow</a>
<a href="#cuddIsInDeathRow">cuddIsInDeathRow</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddRef.c"TARGET="ABSTRACT"><CODE>cuddRef.c</CODE></A>

<dt><pre>
<A NAME="cuddTreeSifting"></A>
int <I></I>
<B>cuddTreeSifting</B>(
  DdManager * <b>table</b>, <i>DD table</i>
  Cudd_ReorderingType  <b>method</b> <i>reordering method for the groups of leaves</i>
)
</pre>
<dd> Tree sifting algorithm. Assumes that a tree representing
  a group hierarchy is passed as a parameter. It then reorders each
  group in postorder fashion by calling ddTreeSiftingAux.  Assumes that
  no dead nodes are present.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="cuddUnderApprox"></A>
DdNode * <I></I>
<B>cuddUnderApprox</B>(
  DdManager * <b>dd</b>, <i>DD manager</i>
  DdNode * <b>f</b>, <i>current DD</i>
  int  <b>numVars</b>, <i>maximum number of variables</i>
  int  <b>threshold</b>, <i>threshold under which approximation stops</i>
  int  <b>safe</b>, <i>enforce safe approximation</i>
  double  <b>quality</b> <i>minimum improvement for accepted changes</i>
)
</pre>
<dd> Applies Tom Shiple's underappoximation algorithm. Proceeds
  in three phases:
  <ul>
  <li> collect information on each node in the BDD; this is done via DFS.
  <li> traverse the BDD in top-down fashion and compute for each node
  whether its elimination increases density.
  <li> traverse the BDD via DFS and actually perform the elimination.
  </ul>
  Returns the approximated BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_UnderApprox">Cudd_UnderApprox</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueConst"></A>
DdNode * <I></I>
<B>cuddUniqueConst</B>(
  DdManager * <b>unique</b>, <i></i>
  CUDD_VALUE_TYPE  <b>value</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of a constant node.
  If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  Returns a
  pointer to the new node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueInterIVO"></A>
DdNode * <I></I>
<B>cuddUniqueInterIVO</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInter that is independent of
  variable ordering (IVO). This function does not require parameter
  index to precede the indices of the top nodes of T and E in the
  variable order.  Returns a pointer to the result node under normal
  conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInter">cuddUniqueInter</a>
<a href="#Cudd_MakeBddFromZddCover">Cudd_MakeBddFromZddCover</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueInterZdd"></A>
DdNode * <I></I>
<B>cuddUniqueInterZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal
  ZDD node. If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  For a newly
  created node, increments the reference counts of what T and E point
  to.  Returns a pointer to the new node if successful; NULL if memory
  is exhausted or if reordering took place.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInter">cuddUniqueInter</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueInter"></A>
DdNode * <I></I>
<B>cuddUniqueInter</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal
  node. If it does not exist, it creates a new one.  Does not
  modify the reference count of whatever is returned.  A newly created
  internal node comes back with a reference count 0.  For a newly
  created node, increments the reference counts of what T and E point
  to.  Returns a pointer to the new node if successful; NULL if memory
  is exhausted or if reordering took place.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInterZdd">cuddUniqueInterZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddUniqueLookup"></A>
static DdNode * <I></I>
<B>cuddUniqueLookup</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Checks the unique table for the existence of an internal
  node. Returns a pointer to the node if it is in the table; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInter">cuddUniqueInter</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddUpdateInteractionMatrix"></A>
void <I></I>
<B>cuddUpdateInteractionMatrix</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>xindex</b>, <i></i>
  int  <b>yindex</b> <i></i>
)
</pre>
<dd> Updates the interaction matrix.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddVerifySol"></A>
DdNode * <I></I>
<B>cuddVerifySol</B>(
  DdManager * <b>bdd</b>, <i></i>
  DdNode * <b>F</b>, <i>the left-hand side of the equation</i>
  DdNode ** <b>G</b>, <i>the array of solutions</i>
  int * <b>yIndex</b>, <i>array holding the y variable indices</i>
  int  <b>n</b> <i>number of unknowns</i>
)
</pre>
<dd> Implements the recursive step of Cudd_VerifySol.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_VerifySol">Cudd_VerifySol</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSolve.c"TARGET="ABSTRACT"><CODE>cuddSolve.c</CODE></A>

<dt><pre>
<A NAME="cuddWindowReorder"></A>
int <I></I>
<B>cuddWindowReorder</B>(
  DdManager * <b>table</b>, <i>DD table</i>
  int  <b>low</b>, <i>lowest index to reorder</i>
  int  <b>high</b>, <i>highest index to reorder</i>
  Cudd_ReorderingType  <b>submethod</b> <i>window reordering option</i>
)
</pre>
<dd> Reorders by applying the method of the sliding window.
  Tries all possible permutations to the variables in a window that
  slides from low to high. The size of the window is determined by
  submethod.  Assumes that no dead nodes are present.  Returns 1 in
  case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="cuddXorLinear"></A>
static void <I></I>
<B>cuddXorLinear</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> XORs two rows of the linear transform matrix and replaces
  the first row with the result.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="cuddZddAlignToBdd"></A>
int <I></I>
<B>cuddZddAlignToBdd</B>(
  DdManager * <b>table</b> <i>DD manager</i>
)
</pre>
<dd> Reorders ZDD variables according to the order of the
  BDD variables. This function can be called at the end of BDD
  reordering to insure that the order of the ZDD variables is
  consistent with the order of the BDD variables. The number of ZDD
  variables must be a multiple of the number of BDD variables. Let
  <code>M</code> be the ratio of the two numbers. cuddZddAlignToBdd
  then considers the ZDD variables from <code>M*i</code> to
  <code>(M+1)*i-1</code> as corresponding to BDD variable
  <code>i</code>.  This function should be normally called from
  Cudd_ReduceHeap, which clears the cache.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable order for all diagrams and performs
  garbage collection of the ZDD unique table.
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddShuffleHeap">Cudd_zddShuffleHeap</a>
<a href="#Cudd_ReduceHeap">Cudd_ReduceHeap</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddChangeAux"></A>
DdNode * <I></I>
<B>cuddZddChangeAux</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddChange.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddChange"></A>
DdNode * <I></I>
<B>cuddZddChange</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Substitutes a variable with its complement in a ZDD.
  returns a pointer to the result if successful; NULL
  otherwise. cuddZddChange performs the same function as
  Cudd_zddChange, but does not restart if reordering has taken
  place. Therefore it can be called from within a recursive
  procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddChange">Cudd_zddChange</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddComplement"></A>
DdNode	* <I></I>
<B>cuddZddComplement</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Computes the complement of a ZDD node. So far, since we
  couldn't find a direct way to get the complement of a ZDD cover, we first
  convert a ZDD cover to a BDD, then make the complement of the ZDD cover
  from the complement of the BDD node by using ISOP.
<p>

<dd> <b>Side Effects</b> The result depends on current variable order.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddCountDoubleStep"></A>
static double <I></I>
<B>cuddZddCountDoubleStep</B>(
  DdNode * <b>P</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  DdNode * <b>base</b>, <i></i>
  DdNode * <b>empty</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddCountDouble.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="cuddZddCountStep"></A>
static int <I></I>
<B>cuddZddCountStep</B>(
  DdNode * <b>P</b>, <i></i>
  st_table * <b>table</b>, <i></i>
  DdNode * <b>base</b>, <i></i>
  DdNode * <b>empty</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddCount.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDagInt"></A>
static int <I></I>
<B>cuddZddDagInt</B>(
  DdNode * <b>n</b>, <i></i>
  st_table * <b>tab</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDagSize. Does
  not check for out-of-memory conditions.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddMisc.c"TARGET="ABSTRACT"><CODE>cuddZddMisc.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDiff"></A>
DdNode * <I></I>
<B>cuddZddDiff</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDiff.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDivideF"></A>
DdNode	* <I></I>
<B>cuddZddDivideF</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDivideF.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDivideF">Cudd_zddDivideF</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddDivide"></A>
DdNode	* <I></I>
<B>cuddZddDivide</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddDivide.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddDivide">Cudd_zddDivide</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddFreeUniv"></A>
void <I></I>
<B>cuddZddFreeUniv</B>(
  DdManager * <b>zdd</b> <i></i>
)
</pre>
<dd> Frees the ZDD universe.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddInitUniv">cuddZddInitUniv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInit.c"TARGET="ABSTRACT"><CODE>cuddInit.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetCofactors2"></A>
int <I></I>
<B>cuddZddGetCofactors2</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>v</b>, <i></i>
  DdNode ** <b>f1</b>, <i></i>
  DdNode ** <b>f0</b> <i></i>
)
</pre>
<dd> Computes the two-way decomposition of f w.r.t. v.
<p>

<dd> <b>Side Effects</b> The results are returned in f1 and f0.
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddGetCofactors3">cuddZddGetCofactors3</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetCofactors3"></A>
int <I></I>
<B>cuddZddGetCofactors3</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>v</b>, <i></i>
  DdNode ** <b>f1</b>, <i></i>
  DdNode ** <b>f0</b>, <i></i>
  DdNode ** <b>fd</b> <i></i>
)
</pre>
<dd> Computes the three-way decomposition of function f (represented
  by a ZDD) wit respect to variable v.  Returns 0 if successful; 1 otherwise.
<p>

<dd> <b>Side Effects</b> The results are returned in f1, f0, and fd.
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddGetCofactors2">cuddZddGetCofactors2</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNegVarIndex"></A>
int <I></I>
<B>cuddZddGetNegVarIndex</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the index of negative ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNegVarLevel"></A>
int <I></I>
<B>cuddZddGetNegVarLevel</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the level of negative ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNodeIVO"></A>
DdNode * <I></I>
<B>cuddZddGetNodeIVO</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInterZdd that is independent of
  variable ordering (IVO). This function does not require parameter
  index to precede the indices of the top nodes of g and h in the
  variable order.  Returns a pointer to the result node under normal
  conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddGetNode">cuddZddGetNode</a>
<a href="#cuddZddIsop">cuddZddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetNode"></A>
DdNode * <I></I>
<B>cuddZddGetNode</B>(
  DdManager * <b>zdd</b>, <i></i>
  int  <b>id</b>, <i></i>
  DdNode * <b>T</b>, <i></i>
  DdNode * <b>E</b> <i></i>
)
</pre>
<dd> Wrapper for cuddUniqueInterZdd, which applies the ZDD
  reduction rule. Returns a pointer to the result node under normal
  conditions; NULL if reordering occurred or memory was exhausted.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUniqueInterZdd">cuddUniqueInterZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetPosVarIndex"></A>
int <I></I>
<B>cuddZddGetPosVarIndex</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the index of positive ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddGetPosVarLevel"></A>
int <I></I>
<B>cuddZddGetPosVarLevel</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Returns the level of positive ZDD variable.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddInitUniv"></A>
int <I></I>
<B>cuddZddInitUniv</B>(
  DdManager * <b>zdd</b> <i></i>
)
</pre>
<dd> Initializes the ZDD universe. Returns 1 if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddFreeUniv">cuddZddFreeUniv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInit.c"TARGET="ABSTRACT"><CODE>cuddInit.c</CODE></A>

<dt><pre>
<A NAME="cuddZddIntersect"></A>
DdNode * <I></I>
<B>cuddZddIntersect</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIntersect.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddIsop"></A>
DdNode	* <I></I>
<B>cuddZddIsop</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>L</b>, <i></i>
  DdNode * <b>U</b>, <i></i>
  DdNode ** <b>zdd_I</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIsop.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddIsop">Cudd_zddIsop</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddIsop.c"TARGET="ABSTRACT"><CODE>cuddZddIsop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddIte"></A>
DdNode * <I></I>
<B>cuddZddIte</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  DdNode * <b>h</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddIte.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearAux"></A>
static int <I></I>
<B>cuddZddLinearAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearBackward"></A>
static int <I></I>
<B>cuddZddLinearBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>size</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearDown"></A>
static Move * <I></I>
<B>cuddZddLinearDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable down. Moves x down until either it
  reaches the bound (xHigh) or the size of the ZDD heap increases too
  much. Returns the set of moves in case of success; NULL if memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearInPlace"></A>
static int <I></I>
<B>cuddZddLinearInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Linearly combines two adjacent variables. It assumes
  that no dead nodes are present on entry to this procedure.  The
  procedure then guarantees that no dead nodes will be present when it
  terminates.  cuddZddLinearInPlace assumes that x &lt; y.  Returns the
  number of keys in the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSwapInPlace">cuddZddSwapInPlace</a>
<a href="#cuddLinearInPlace">cuddLinearInPlace</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearSifting"></A>
int <I></I>
<B>cuddZddLinearSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of the linear sifting algorithm for ZDDs.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down and applies the XOR transformation,
    remembering each time the total size of the DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddLinearUp"></A>
static Move * <I></I>
<B>cuddZddLinearUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable up applying the XOR
  transformation. Moves y up until either it reaches the bound (xLow)
  or the size of the ZDD heap increases too much.  Returns the set of
  moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddNextHigh"></A>
int <I></I>
<B>cuddZddNextHigh</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a larger index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddNextLow"></A>
int <I></I>
<B>cuddZddNextLow</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Finds the next subtable with a smaller index. Returns the
  index.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddProduct"></A>
DdNode	* <I></I>
<B>cuddZddProduct</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddProduct.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddProduct">Cudd_zddProduct</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddP"></A>
int <I></I>
<B>cuddZddP</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Prints a ZDD to the standard output. One line per node is
  printed. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddPrintDebug">Cudd_zddPrintDebug</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingAux"></A>
static int <I></I>
<B>cuddZddSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingBackward"></A>
static int <I></I>
<B>cuddZddSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingDown"></A>
static Move * <I></I>
<B>cuddZddSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Sifts a variable down. Moves x down until either it
  reaches the bound (x_high) or the size of the ZDD heap increases too
  much. Returns the set of moves in case of success; NULL if memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSiftingUp"></A>
static Move * <I></I>
<B>cuddZddSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Sifts a variable up. Moves y up until either it reaches
  the bound (x_low) or the size of the ZDD heap increases too much.
  Returns the set of moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSifting"></A>
int <I></I>
<B>cuddZddSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Implementation of Rudell's sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries
    in each unique table.
    <li> Sift the variable up and down, remembering each time the
    total size of the DD heap.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSubset0"></A>
DdNode * <I></I>
<B>cuddZddSubset0</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the negative cofactor of a ZDD w.r.t. a
  variable. In terms of combinations, the result is the set of all
  combinations in which the variable is negated. Returns a pointer to
  the result if successful; NULL otherwise. cuddZddSubset0 performs
  the same function as Cudd_zddSubset0, but does not restart if
  reordering has taken place. Therefore it can be called from within a
  recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSubset1">cuddZddSubset1</a>
<a href="#Cudd_zddSubset0">Cudd_zddSubset0</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSubset1"></A>
DdNode * <I></I>
<B>cuddZddSubset1</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  int  <b>var</b> <i></i>
)
</pre>
<dd> Computes the positive cofactor of a ZDD w.r.t. a
  variable. In terms of combinations, the result is the set of all
  combinations in which the variable is asserted. Returns a pointer to
  the result if successful; NULL otherwise. cuddZddSubset1 performs
  the same function as Cudd_zddSubset1, but does not restart if
  reordering has taken place. Therefore it can be called from within a
  recursive procedure.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSubset0">cuddZddSubset0</a>
<a href="#Cudd_zddSubset1">Cudd_zddSubset1</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSwapInPlace"></A>
int <I></I>
<B>cuddZddSwapInPlace</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps two adjacent variables. It assumes that no dead
  nodes are present on entry to this procedure.  The procedure then
  guarantees that no dead nodes will be present when it terminates.
  cuddZddSwapInPlace assumes that x &lt; y.  Returns the number of keys in
  the table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSwapping"></A>
int <I></I>
<B>cuddZddSwapping</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  Cudd_ReorderingType  <b>heuristic</b> <i></i>
)
</pre>
<dd> Implementation of Plessier's algorithm that reorders
  variables by a sequence of (non-adjacent) swaps.
    <ol>
    <li> Select two variables (RANDOM or HEURISTIC).
    <li> Permute these variables.
    <li> If the nodes have decreased accept the permutation.
    <li> Otherwise reconstruct the original heap.
    <li> Loop.
    </ol>
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmCheck"></A>
int <I></I>
<B>cuddZddSymmCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for symmetry of x and y. Ignores projection
  functions, unless they are isolated. Returns 1 in case of
  symmetry; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingAux"></A>
static int <I></I>
<B>cuddZddSymmSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b> <i></i>
)
</pre>
<dd> Given x_low <= x <= x_high moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is not part of a symmetry group. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingBackward"></A>
static int <I></I>
<B>cuddZddSymmSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingConvAux"></A>
static int <I></I>
<B>cuddZddSymmSiftingConvAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b> <i></i>
)
</pre>
<dd> Given x_low <= x <= x_high moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is either an isolated variable, or it is the bottom of
  a symmetry group. All symmetries may not have been found, because of
  exceeded growth limit. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSiftingConv"></A>
int <I></I>
<B>cuddZddSymmSiftingConv</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting to convergence algorithm for ZDDs.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the ZDD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    <li> Repeat 1-4 until no further improvement.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSymmSifting">cuddZddSymmSifting</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSifting_down"></A>
static Move * <I></I>
<B>cuddZddSymmSifting_down</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Moves x down until either it reaches the bound (x_high)
  or the size of the ZDD heap increases too much. Assumes that x is the
  bottom of a symmetry group. Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; ZDD_MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSifting_up"></A>
static Move * <I></I>
<B>cuddZddSymmSifting_up</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> Moves x up until either it reaches the bound (x_low) or
  the size of the ZDD heap increases too much. Assumes that x is the top
  of a symmetry group.  Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; ZDD_MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSifting"></A>
int <I></I>
<B>cuddZddSymmSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Symmetric sifting algorithm.
  Assumes that no dead nodes are present.
    <ol>
    <li> Order all the variables according to the number of entries in
    each unique subtable.
    <li> Sift the variable up and down, remembering each time the total
    size of the ZDD heap and grouping variables that are symmetric.
    <li> Select the best permutation.
    <li> Repeat 3 and 4 for all variables.
    </ol>
  Returns 1 plus the number of symmetric variables if successful; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddZddSymmSiftingConv">cuddZddSymmSiftingConv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddSymmSummary"></A>
static void <I></I>
<B>cuddZddSymmSummary</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  int * <b>symvars</b>, <i></i>
  int * <b>symgroups</b> <i></i>
)
</pre>
<dd> Counts numbers of symmetric variables and symmetry
  groups.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="cuddZddTreeSifting"></A>
int <I></I>
<B>cuddZddTreeSifting</B>(
  DdManager * <b>table</b>, <i>DD table</i>
  Cudd_ReorderingType  <b>method</b> <i>reordering method for the groups of leaves</i>
)
</pre>
<dd> Tree sifting algorithm for ZDDs. Assumes that a tree
  representing a group hierarchy is passed as a parameter. It then
  reorders each group in postorder fashion by calling
  zddTreeSiftingAux.  Assumes that no dead nodes are present.  Returns
  1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUnateProduct"></A>
DdNode	* <I></I>
<B>cuddZddUnateProduct</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddUnateProduct.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddUnateProduct">Cudd_zddUnateProduct</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUndoMoves"></A>
static Move* <I></I>
<B>cuddZddUndoMoves</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the ZDD heap to the
  order in effect before the moves.  Returns 1 in case of success;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddLin.c"TARGET="ABSTRACT"><CODE>cuddZddLin.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUnion"></A>
DdNode * <I></I>
<B>cuddZddUnion</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>Q</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddUnion.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="cuddZddUniqueCompare"></A>
int <I></I>
<B>cuddZddUniqueCompare</B>(
  int * <b>ptr_x</b>, <i></i>
  int * <b>ptr_y</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="cuddZddWeakDivF"></A>
DdNode	* <I></I>
<B>cuddZddWeakDivF</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddWeakDivF.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddWeakDivF">Cudd_zddWeakDivF</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="cuddZddWeakDiv"></A>
DdNode	* <I></I>
<B>cuddZddWeakDiv</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddWeakDiv.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddWeakDiv">Cudd_zddWeakDiv</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddFuncs.c"TARGET="ABSTRACT"><CODE>cuddZddFuncs.c</CODE></A>

<dt><pre>
<A NAME="ddBddToAddRecur"></A>
static DdNode * <I></I>
<B>ddBddToAddRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b> <i></i>
)
</pre>
<dd> Performs the recursive step for Cudd_BddToAdd. Returns a
  pointer to the resulting ADD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddBridge.c"TARGET="ABSTRACT"><CODE>cuddBridge.c</CODE></A>

<dt><pre>
<A NAME="ddCheckPermuation"></A>
static int <I></I>
<B>ddCheckPermuation</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>perm</b>, <i></i>
  int * <b>invperm</b> <i></i>
)
</pre>
<dd> Checks the BDD variable group tree before a shuffle.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddClearFlag"></A>
static void <I></I>
<B>ddClearFlag</B>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs a DFS from f, clearing the LSB of the next
  pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddSupportStep">ddSupportStep</a>
<a href="#ddDagInt">ddDagInt</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddClearGlobal"></A>
static void <I></I>
<B>ddClearGlobal</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>maxlevel</b> <i></i>
)
</pre>
<dd> Scans the DD and clears the LSB of the next pointers.
  The LSB of the next pointers are used as markers to tell whether a
  node was reached. Once the roots are counted, these flags are
  reset.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddCountRoots">ddCountRoots</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddClearGlobal"></A>
static void <I></I>
<B>ddClearGlobal</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> The LSB of the next pointers are used as markers to tell
  whether a node was reached by at least one DFS. Once the interaction
  matrix is built, these flags are reset.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddClearLocal"></A>
static void <I></I>
<B>ddClearLocal</B>(
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Performs a DFS from f, clearing the LSB of the then pointers.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddCofMintermAux"></A>
static double * <I></I>
<B>ddCofMintermAux</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Traverses the DD node and computes the fraction of
  minterms in the on-set of all positive cofactors simultaneously.
  It allocates an array with two more entries than there are
  variables below the one labeling the node.  One extra entry (the
  first in the array) is for the variable labeling the node. The other
  entry (the last one in the array) holds the fraction of minterms of
  the function rooted at node.  Each other entry holds the value for
  one cofactor. The array is put in a symbol table, to avoid repeated
  computation, and its address is returned by the procedure, for use
  by the caller.  Returns a pointer to the array of cofactor measures.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSign.c"TARGET="ABSTRACT"><CODE>cuddSign.c</CODE></A>

<dt><pre>
<A NAME="ddCountInternalMtrNodes"></A>
static int <I></I>
<B>ddCountInternalMtrNodes</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Counts the number of internal nodes of the group tree.
  Returns the count.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddCountMintermAux"></A>
static double <I></I>
<B>ddCountMintermAux</B>(
  DdNode * <b>node</b>, <i></i>
  double  <b>max</b>, <i></i>
  DdHashTable * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountMinterm.
  It is based on the following identity. Let |f| be the
  number of minterms of f. Then:
  <xmp>
    |f| = (|f0|+|f1|)/2
  </xmp>
  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.  Returns the number of minterms of the function rooted at
  node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCountPathAux"></A>
static double <I></I>
<B>ddCountPathAux</B>(
  DdNode * <b>node</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountPath.
  It is based on the following identity. Let |f| be the
  number of paths of f. Then:
  <xmp>
    |f| = |f0|+|f1|
  </xmp>
  where f0 and f1 are the two cofactors of f.  Uses the
  identity |f'| = |f|, to improve the utilization of the (local) cache.
  Returns the number of paths of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCountPathsToNonZero"></A>
static double <I></I>
<B>ddCountPathsToNonZero</B>(
  DdNode * <b>N</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountPathsToNonZero.
  It is based on the following identity. Let |f| be the
  number of paths of f. Then:
  <xmp>
    |f| = |f0|+|f1|
  </xmp>
  where f0 and f1 are the two cofactors of f.  Returns the number of
  paths of the function rooted at node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddCountRoots"></A>
static int <I></I>
<B>ddCountRoots</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Counts the number of roots at the levels between lower and
  upper.  The computation is based on breadth-first search.
  A node is a root if it is not reachable from any previously visited node.
  (All the nodes at level lower are therefore considered roots.)
  The visited flag uses the LSB of the next pointer.  Returns the root
  count. The roots that are constant nodes are always ignored.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddClearGlobal">ddClearGlobal</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddCreateGroup"></A>
static void <I></I>
<B>ddCreateGroup</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Creates a group encompassing variables from x to y in the
  DD table. In the current implementation it must be y == x+1.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddDagInt"></A>
static int <I></I>
<B>ddDagInt</B>(
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DagSize. Returns the
  number of nodes in the graph rooted at n.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddDissolveGroup"></A>
static void <I></I>
<B>ddDissolveGroup</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> x and y are variables in a group to be cut in two. The cut
  is to pass between x and y.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpBlif"></A>
static int <I></I>
<B>ddDoDumpBlif</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  char ** <b>names</b>, <i></i>
  int  <b>mv</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DumpBlif. Traverses
  the BDD f and writes a multiplexer-network description to the file
  pointed by fp in blif format. f is assumed to be a regular pointer
  and ddDoDumpBlif guarantees this assumption in the recursive calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpDDcal"></A>
static int <I></I>
<B>ddDoDumpDDcal</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  char ** <b>names</b>, <i></i>
  unsigned long  <b>mask</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DumpDDcal. Traverses
  the BDD f and writes a line for each node to the file
  pointed by fp in DDcal format. f is assumed to be a regular pointer
  and ddDoDumpDDcal guarantees this assumption in the recursive calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpDaVinci"></A>
static int <I></I>
<B>ddDoDumpDaVinci</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  char ** <b>names</b>, <i></i>
  unsigned long  <b>mask</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_DumpDaVinci. Traverses
  the BDD f and writes a term expression to the file
  pointed by fp in daVinci format. f is assumed to be a regular pointer
  and ddDoDumpDaVinci guarantees this assumption in the recursive calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddDoDumpFactoredForm"></A>
static int <I></I>
<B>ddDoDumpFactoredForm</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  FILE * <b>fp</b>, <i></i>
  char ** <b>names</b> <i></i>
)
</pre>
<dd> Performs the recursive step of
  Cudd_DumpFactoredForm. Traverses the BDD f and writes a factored
  form for each node to the file pointed by fp in terms of the
  factored forms of the children. Constants are propagated, and
  absorption is applied.  f is assumed to be a regular pointer and
  ddDoDumpFActoredForm guarantees this assumption in the recursive
  calls.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_DumpFactoredForm">Cudd_DumpFactoredForm</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExport.c"TARGET="ABSTRACT"><CODE>cuddExport.c</CODE></A>

<dt><pre>
<A NAME="ddEpdCountMintermAux"></A>
static int <I></I>
<B>ddEpdCountMintermAux</B>(
  DdNode * <b>node</b>, <i></i>
  EpDouble * <b>max</b>, <i></i>
  EpDouble * <b>epd</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_EpdCountMinterm.
  It is based on the following identity. Let |f| be the
  number of minterms of f. Then:
  <xmp>
    |f| = (|f0|+|f1|)/2
  </xmp>
  where f0 and f1 are the two cofactors of f.  Does not use the
  identity |f'| = max - |f|, to minimize loss of accuracy due to
  roundoff.  Returns the number of minterms of the function rooted at
  node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddEpdFree"></A>
static enum st_retval <I></I>
<B>ddEpdFree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory used to store the minterm counts
  recorded in the visited table. Returns ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddExchange"></A>
static int <I></I>
<B>ddExchange</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> This is the same funcion as ddSwapping except for
  comparison expression.  Use probability function, exp(-size_change/temp).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddExtSymmCheck"></A>
static int <I></I>
<B>ddExtSymmCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for extended symmetry of x and y. Returns 1 in
  case of extended symmetry; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddFindEssentialRecur"></A>
static DdNode * <I></I>
<B>ddFindEssentialRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b> <i></i>
)
</pre>
<dd> Implements the recursive step of Cudd_FindEssential.
  Returns a pointer to the cube BDD if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="ddFindNodeHiLo"></A>
static void <I></I>
<B>ddFindNodeHiLo</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>lower</b>, <i></i>
  int * <b>upper</b> <i></i>
)
</pre>
<dd> Finds the lower and upper bounds of the group
  represented by treenode.  From the index and size fields we need to
  derive the current positions, and find maximum and minimum.
<p>

<dd> <b>Side Effects</b> The bounds are returned as side effects.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddFindTwoLiteralClausesRecur"></A>
static DdTlcInfo * <I></I>
<B>ddFindTwoLiteralClausesRecur</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>table</b> <i></i>
)
</pre>
<dd> Implements the recursive step of
  Cudd_FindTwoLiteralClauses.  The DD node is assumed to be not
  constant.  Returns a pointer to a set of clauses if successful; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_FindTwoLiteralClauses">Cudd_FindTwoLiteralClauses</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="ddFixLimits"></A>
static void <I></I>
<B>ddFixLimits</B>(
  DdManager * <b>unique</b> <i></i>
)
</pre>
<dd> Adjusts the values of table fields controlling the.
  sizes of subtables and computed table. If the computed table is too small
  according to the new values, it is resized.
<p>

<dd> <b>Side Effects</b> Modifies manager fields. May resize computed table.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddGroupMoveBackward"></A>
static int <I></I>
<B>ddGroupMoveBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap two groups.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupMove"></A>
static int <I></I>
<B>ddGroupMove</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups and records the move. Returns the
  number of keys in the DD table in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingAux"></A>
static int <I></I>
<B>ddGroupSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  int  <b>lazyFlag</b> <i></i>
)
</pre>
<dd> Sifts one variable up and down until it has taken all
  positions. Checks for aggregation. There may be at most two sweeps,
  even if the group grows.  Assumes that x is either an isolated
  variable, or it is the bottom of a group. All groups may not have
  been found. The variable being moved is returned to the best position
  seen during sifting.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingBackward"></A>
static int <I></I>
<B>ddGroupSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b>, <i></i>
  int  <b>upFlag</b>, <i></i>
  int  <b>lazyFlag</b> <i></i>
)
</pre>
<dd> Determines the best position for a variables and returns
  it there.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingDown"></A>
static int <I></I>
<B>ddGroupSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts down a variable until it reaches position xHigh.
  Assumes that x is the bottom of a group (or a singleton).  Records
  all the moves.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSiftingUp"></A>
static int <I></I>
<B>ddGroupSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts up a variable until either it reaches position
  xLow or the size of the DD heap increases too much. Assumes that y is
  the top of a group (or a singleton).  Checks y for aggregation to the
  adjacent variables. Records all the moves that are appended to the
  list of moves received as input and returned as a side effect.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddGroupSifting"></A>
static int <I></I>
<B>ddGroupSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  DD_CHKFP  <b>checkFunction</b>, <i></i>
  int  <b>lazyFlag</b> <i></i>
)
</pre>
<dd> Sifts from treenode->low to treenode->high. If
  croupcheck == CUDD_GROUP_CHECK7, it checks for group creation at the
  end of the initial sifting. If a group is created, it is then sifted
  again. After sifting one variable, the group that contains it is
  dissolved.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddIsIthAddVarPair"></A>
static int <I></I>
<B>ddIsIthAddVarPair</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>g</b>, <i></i>
  unsigned int  <b>i</b> <i></i>
)
</pre>
<dd> Comparison of a pair of functions to the i-th ADD
  variable. Returns 1 if the functions are the i-th ADD variable and its
  complement; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="ddIsIthAddVar"></A>
static int <I></I>
<B>ddIsIthAddVar</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  unsigned int  <b>i</b> <i></i>
)
</pre>
<dd> Comparison of a function to the i-th ADD variable. Returns 1 if
  the function is the i-th ADD variable; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCompose.c"TARGET="ABSTRACT"><CODE>cuddCompose.c</CODE></A>

<dt><pre>
<A NAME="ddIsVarHandled"></A>
static int <I></I>
<B>ddIsVarHandled</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Checks whether a variables is already handled. This
  function is used for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddJumpingAux"></A>
static int <I></I>
<B>ddJumpingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> If x==x_low, it executes jumping_down. If x==x_high, it
  executes jumping_up. This funcion is similar to ddSiftingAux. Returns
  1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddJumpingDown"></A>
static Move * <I></I>
<B>ddJumpingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_high</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> This is a simplified version of ddSiftingDown. It does not
  use lower bounding. Returns the set of moves in case of success; NULL
  if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddJumpingUp"></A>
static Move * <I></I>
<B>ddJumpingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b>, <i></i>
  int  <b>initial_size</b> <i></i>
)
</pre>
<dd> This is a simplified version of ddSiftingUp. It does not
  use lower bounding. Returns the set of moves in case of success; NULL
  if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="ddLCHash"></A>
static unsigned int <I></I>
<B>ddLCHash</B>(
  DdNodePtr * <b>key</b>, <i></i>
  unsigned int  <b>keysize</b>, <i></i>
  int  <b>shift</b> <i></i>
)
</pre>
<dd> Computes the hash value for a local cache. Returns the
  bucket index.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME="ddLeavesInt"></A>
static int <I></I>
<B>ddLeavesInt</B>(
  DdNode * <b>n</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_CountLeaves. Returns
  the number of leaves in the DD rooted at n.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_CountLeaves">Cudd_CountLeaves</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingAux"></A>
static int <I></I>
<B>ddLinearAndSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. At each step a linear transformation is tried, and, if it
  decreases the size of the DD, it is accepted. Finds the best position
  and does the required changes.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingBackward"></A>
static int <I></I>
<B>ddLinearAndSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>size</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingDown"></A>
static Move * <I></I>
<B>ddLinearAndSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable down and applies linear
  transformations. Moves x down until either it reaches the bound
  (xHigh) or the size of the DD heap increases too much. Returns the
  set of moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearAndSiftingUp"></A>
static Move * <I></I>
<B>ddLinearAndSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  Move * <b>prevMoves</b> <i></i>
)
</pre>
<dd> Sifts a variable up and applies linear transformations.
  Moves y up until either it reaches the bound (xLow) or the size of
  the DD heap increases too much.  Returns the set of moves in case of
  success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddLinearUniqueCompare"></A>
static int <I></I>
<B>ddLinearUniqueCompare</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddMergeGroups"></A>
static void <I></I>
<B>ddMergeGroups</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Creates a single group from low to high and adjusts the
  index field of the tree node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddNoCheck"></A>
static int <I></I>
<B>ddNoCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Pretends to check two variables for aggregation. Always
  returns 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddPatchTree"></A>
static void <I></I>
<B>ddPatchTree</B>(
  DdManager * <b>dd</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Fixes a variable tree after the insertion of new subtables.
  After such an insertion, the low fields of the tree below the insertion
  point are inconsistent.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddPermuteWindow3"></A>
static int <I></I>
<B>ddPermuteWindow3</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b> <i></i>
)
</pre>
<dd> Tries all the permutations of the three variables between
  x and x+2 and retains the best. Assumes that no dead nodes are
  present.  Returns the index of the best permutation (1-6) in case of
  success; 0 otherwise.Assumes that no dead nodes are present.  Returns
  the index of the best permutation (1-6) in case of success; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddPermuteWindow4"></A>
static int <I></I>
<B>ddPermuteWindow4</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>w</b> <i></i>
)
</pre>
<dd> Tries all the permutations of the four variables between
  w and w+3 and retains the best. Assumes that no dead nodes are
  present.  Returns the index of the best permutation (1-24) in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddPickArbitraryMinterms"></A>
static int <I></I>
<B>ddPickArbitraryMinterms</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  int  <b>nvars</b>, <i></i>
  int  <b>nminterms</b>, <i></i>
  char ** <b>string</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_bddPickArbitraryMinterms.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_bddPickArbitraryMinterms">Cudd_bddPickArbitraryMinterms</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddPickRepresentativeCube"></A>
static int <I></I>
<B>ddPickRepresentativeCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>node</b>, <i></i>
  double * <b>weight</b>, <i></i>
  char * <b>string</b> <i></i>
)
</pre>
<dd> Finds a representative cube of a BDD with the weight of
  each variable. From the top variable, if the weight is greater than or
  equal to 0.0, choose THEN branch unless the child is the constant 0.
  Otherwise, choose ELSE branch unless the child is the constant 0.
<p>

<dd> <b>Side Effects</b> Cudd_SubsetWithMaskVars Cudd_bddPickOneCube
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddPrintMintermAux"></A>
static void <I></I>
<B>ddPrintMintermAux</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int * <b>list</b> <i>current recursion path</i>
)
</pre>
<dd> Performs the recursive step of Cudd_PrintMinterm.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddRehashZdd"></A>
static void <I></I>
<B>ddRehashZdd</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>i</b> <i></i>
)
</pre>
<dd> Rehashes a ZDD unique subtable.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddRehash">cuddRehash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddReorderChildren"></A>
static int <I></I>
<B>ddReorderChildren</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Reorders the children of a group tree node according to
  the options. After reordering puts all the variables in the group
  and/or its descendents in a single group. This allows hierarchical
  reordering.  If the variables in the group do not exist yet, simply
  does nothing. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddReorderPostprocess"></A>
static int <I></I>
<B>ddReorderPostprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Cleans up at the end of reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddReorderPreprocess"></A>
static int <I></I>
<B>ddReorderPreprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prepares the DD heap for dynamic reordering. Does
  garbage collection, to guarantee that there are no dead nodes;
  clears the cache, which is invalidated by dynamic reordering; initializes
  the number of isolated projection functions; and initializes the
  interaction matrix.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddReportRefMess"></A>
static void <I></I>
<B>ddReportRefMess</B>(
  DdManager * <b>unique</b>, <i>manager</i>
  int  <b>i</b>, <i>table in which the problem occurred</i>
  const char * <b>caller</b> <i>procedure that detected the problem</i>
)
</pre>
<dd> Reports problem in garbage collection.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddGarbageCollect">cuddGarbageCollect</a>
<a href="#cuddGarbageCollectZdd">cuddGarbageCollectZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddResetVarHandled"></A>
static int <I></I>
<B>ddResetVarHandled</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Resets a variable to be processed. This function is used
  for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddResizeTable"></A>
static int <I></I>
<B>ddResizeTable</B>(
  DdManager * <b>unique</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Increases the number of subtables in a unique table so
  that it meets or exceeds index. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddResizeTableZdd">cuddResizeTableZdd</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddTable.c"TARGET="ABSTRACT"><CODE>cuddTable.c</CODE></A>

<dt><pre>
<A NAME="ddSecDiffCheck"></A>
static int <I></I>
<B>ddSecDiffCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks two variables for aggregation. The check is based
  on the second difference of the number of nodes as a function of the
  layer. If the second difference is lower than a given threshold
  (typically negative) then the two variables should be aggregated.
  Returns 1 if the two variables pass the test; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddSetVarHandled"></A>
static int <I></I>
<B>ddSetVarHandled</B>(
  DdManager * <b>dd</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Sets a variable to already handled. This function is used
  for lazy sifting.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddShuffle"></A>
static int <I></I>
<B>ddShuffle</B>(
  DdManager * <b>table</b>, <i></i>
  DdHalfWord * <b>permutation</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Reorders variables according to a given permutation.
  The i-th permutation array contains the index of the variable that
  should be brought to the i-th level. ddShuffle assumes that no
  dead nodes are present and that the interaction matrix is properly
  initialized.  The reordering is achieved by a series of upward sifts.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddShuffle"></A>
static int <I></I>
<B>ddShuffle</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>permutation</b> <i></i>
)
</pre>
<dd> Reorders variables according to a given permutation.
  The i-th permutation array contains the index of the variable that
  should be brought to the i-th level. ddShuffle assumes that no
  dead nodes are present and that the interaction matrix is properly
  initialized.  The reordering is achieved by a series of upward sifts.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftUp"></A>
static int <I></I>
<B>ddSiftUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Takes a variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.
  Returns 1 if successful; 0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="ddSiftUp"></A>
static int <I></I>
<B>ddSiftUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Takes a variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.
  Returns 1 if successful; 0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingAux"></A>
static int <I></I>
<B>ddSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingBackward"></A>
static int <I></I>
<B>ddSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>size</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingDown"></A>
static Move * <I></I>
<B>ddSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Sifts a variable down. Moves x down until either it
  reaches the bound (xHigh) or the size of the DD heap increases too
  much. Returns the set of moves in case of success; NULL if memory is
  full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSiftingUp"></A>
static Move * <I></I>
<B>ddSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Sifts a variable up. Moves y up until either it reaches
  the bound (xLow) or the size of the DD heap increases too much.
  Returns the set of moves in case of success; NULL if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSuppInteract"></A>
static void <I></I>
<B>ddSuppInteract</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>support</b> <i></i>
)
</pre>
<dd> Performs a DFS from f. Uses the LSB of the then pointer
  as visited flag.
<p>

<dd> <b>Side Effects</b> Accumulates in support the variables on which f depends.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddSupportStep"></A>
static void <I></I>
<B>ddSupportStep</B>(
  DdNode * <b>f</b>, <i></i>
  int * <b>support</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_Support. Performs a
  DFS from f. The support is accumulated in supp as a side effect. Uses
  the LSB of the then pointer as visited flag.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddClearFlag">ddClearFlag</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="ddSwapAny"></A>
static Move * <I></I>
<B>ddSwapAny</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps any two variables. Returns the set of moves.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddSymmGroupMoveBackward"></A>
static int <I></I>
<B>ddSymmGroupMoveBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap of two groups. x is assumed to be the
  bottom variable of the first group. y is assumed to be the top
  variable of the second group.  Returns the number of keys in the table
  if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmGroupMove"></A>
static int <I></I>
<B>ddSymmGroupMove</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups. x is assumed to be the bottom variable
  of the first group. y is assumed to be the top variable of the second
  group.  Updates the list of moves. Returns the number of keys in the
  table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingAux"></A>
static int <I></I>
<B>ddSymmSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is not part of a symmetry group. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingBackward"></A>
static int <I></I>
<B>ddSymmSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  position giving the minimum size. In case of ties, returns to the
  closest position giving the minimum size. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingConvAux"></A>
static int <I></I>
<B>ddSymmSiftingConvAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Given xLow <= x <= xHigh moves x up and down between the
  boundaries. Finds the best position and does the required changes.
  Assumes that x is either an isolated variable, or it is the bottom of
  a symmetry group. All symmetries may not have been found, because of
  exceeded growth limit. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingDown"></A>
static Move * <I></I>
<B>ddSymmSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Moves x down until either it reaches the bound (xHigh)
  or the size of the DD heap increases too much. Assumes that x is the
  bottom of a symmetry group. Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSiftingUp"></A>
static Move * <I></I>
<B>ddSymmSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Moves x up until either it reaches the bound (xLow) or
  the size of the DD heap increases too much. Assumes that x is the top
  of a symmetry group.  Checks x for symmetry to the adjacent
  variables. If symmetry is found, the symmetry group of x is merged
  with the symmetry group of the other variable. Returns the set of
  moves in case of success; MV_OOM if memory is full.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmSummary"></A>
static void <I></I>
<B>ddSymmSummary</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b>, <i></i>
  int * <b>symvars</b>, <i></i>
  int * <b>symgroups</b> <i></i>
)
</pre>
<dd> Counts numbers of symmetric variables and symmetry
  groups.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddSymmUniqueCompare"></A>
static int <I></I>
<B>ddSymmUniqueCompare</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSymmetry.c"TARGET="ABSTRACT"><CODE>cuddSymmetry.c</CODE></A>

<dt><pre>
<A NAME="ddTreeSiftingAux"></A>
static int <I></I>
<B>ddTreeSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Recursively visits the group tree and reorders each
  group in postorder fashion.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddUndoMoves"></A>
static Move* <I></I>
<B>ddUndoMoves</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b> <i></i>
)
</pre>
<dd> Given a set of moves, returns the DD heap to the
  order in effect before the moves.  Returns 1 in case of success;
  0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLinear.c"TARGET="ABSTRACT"><CODE>cuddLinear.c</CODE></A>

<dt><pre>
<A NAME="ddUniqueCompareGroup"></A>
static int <I></I>
<B>ddUniqueCompareGroup</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.  Returns the
  difference in number of keys between the two variables being
  compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddUniqueCompare"></A>
static int <I></I>
<B>ddUniqueCompare</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the
  variables according to the number of keys in the subtables.
  Returns the difference in number of keys between the two
  variables being compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddUpdateInteract"></A>
static void <I></I>
<B>ddUpdateInteract</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>support</b> <i></i>
)
</pre>
<dd> If support[i
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddInteract.c"TARGET="ABSTRACT"><CODE>cuddInteract.c</CODE></A>

<dt><pre>
<A NAME="ddUpdateMtrTree"></A>
static int <I></I>
<B>ddUpdateMtrTree</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>perm</b>, <i></i>
  int * <b>invperm</b> <i></i>
)
</pre>
<dd> Updates the BDD variable group tree before a shuffle.
  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> Changes the BDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddReorder.c"TARGET="ABSTRACT"><CODE>cuddReorder.c</CODE></A>

<dt><pre>
<A NAME="ddVarGroupCheck"></A>
static int <I></I>
<B>ddVarGroupCheck</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Checks for grouping of x and y. Returns 1 in
  case of grouping; 0 otherwise. This function is used for lazy sifting.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGroup.c"TARGET="ABSTRACT"><CODE>cuddGroup.c</CODE></A>

<dt><pre>
<A NAME="ddWindow2"></A>
static int <I></I>
<B>ddWindow2</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by applying a sliding window of width 2.
  Tries both permutations of the variables in a window
  that slides from low to high.  Assumes that no dead nodes are
  present.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindow3"></A>
static int <I></I>
<B>ddWindow3</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by applying a sliding window of width 3.
  Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindow4"></A>
static int <I></I>
<B>ddWindow4</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by applying a sliding window of width 4.
  Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindowConv2"></A>
static int <I></I>
<B>ddWindowConv2</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by repeatedly applying a sliding window of width
  2. Tries both permutations of the variables in a window
  that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindowConv3"></A>
static int <I></I>
<B>ddWindowConv3</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by repeatedly applying a sliding window of width
  3. Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="ddWindowConv4"></A>
static int <I></I>
<B>ddWindowConv4</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Reorders by repeatedly applying a sliding window of width
  4. Tries all possible permutations to the variables in a
  window that slides from low to high.  Assumes that no dead nodes are
  present.  Uses an event-driven approach to determine convergence.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddWindow.c"TARGET="ABSTRACT"><CODE>cuddWindow.c</CODE></A>

<dt><pre>
<A NAME="debugCheckParent"></A>
static void <I></I>
<B>debugCheckParent</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Searches all the subtables above node. Very expensive.
  The same check is now implemented more efficiently in ddDebugCheck.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#debugFindParent">debugFindParent</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="debugFindParent"></A>
static void <I></I>
<B>debugFindParent</B>(
  DdManager * <b>table</b>, <i></i>
  DdNode * <b>node</b> <i></i>
)
</pre>
<dd> Searches the subtables above node for its parents.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddCheck.c"TARGET="ABSTRACT"><CODE>cuddCheck.c</CODE></A>

<dt><pre>
<A NAME="dp2"></A>
static int <I></I>
<B>dp2</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>t</b> <i></i>
)
</pre>
<dd> Performs the recursive step of cuddP. Returns 1 in case
  of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddUtil.c"TARGET="ABSTRACT"><CODE>cuddUtil.c</CODE></A>

<dt><pre>
<A NAME="emptyClauseSet"></A>
static DdTlcInfo * <I></I>
<B>emptyClauseSet</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns a pointer to an empty set of clauses if
  successful; NULL otherwise.  No bit vector for the phases is
  allocated.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="equalp"></A>
static int <I></I>
<B>equalp</B>(
  DdHalfWord  <b>var1a</b>, <i></i>
  short  <b>phase1a</b>, <i></i>
  DdHalfWord  <b>var1b</b>, <i></i>
  short  <b>phase1b</b>, <i></i>
  DdHalfWord  <b>var2a</b>, <i></i>
  short  <b>phase2a</b>, <i></i>
  DdHalfWord  <b>var2b</b>, <i></i>
  short  <b>phase2b</b> <i></i>
)
</pre>
<dd> Returns true iff the two arguments are identical
  clauses.  Since literals are sorted, we only need to compare
  literals in the same position.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#beforep">beforep</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="find_average_fitness"></A>
static double <I></I>
<B>find_average_fitness</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the average fitness of the population.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="find_best"></A>
static int <I></I>
<B>find_best</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the index of the fittest individual.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="fixVarTree"></A>
static void <I></I>
<B>fixVarTree</B>(
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>perm</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Fixes a variable group tree.
<p>

<dd> <b>Side Effects</b> Changes the variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAPI.c"TARGET="ABSTRACT"><CODE>cuddAPI.c</CODE></A>

<dt><pre>
<A NAME="freeMatrix"></A>
static void <I></I>
<B>freeMatrix</B>(
  DdHalfWord ** <b>matrix</b> <i></i>
)
</pre>
<dd> Frees a two-dimensional matrix allocated by getMatrix.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#getMatrix">getMatrix</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="freePathPair"></A>
static enum st_retval <I></I>
<B>freePathPair</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the entries of the visited symbol table. Returns
  ST_CONTINUE.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="gatherInfoAux"></A>
static NodeData * <I></I>
<B>gatherInfoAux</B>(
  DdNode * <b>node</b>, <i>function to analyze</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>parity</b> <i>gather parity information</i>
)
</pre>
<dd> Recursively counts minterms and computes reference
  counts of each node in the BDD.  Similar to the cuddCountMintermAux
  which recursively counts the number of minterms for the dag rooted
  at each node in terms of the total number of variables (max). It assumes
  that the node pointer passed to it is regular and it maintains the
  invariant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#gatherInfo">gatherInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="gatherInfo"></A>
static ApproxInfo * <I></I>
<B>gatherInfo</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>function to be analyzed</i>
  int  <b>numVars</b>, <i>number of variables node depends on</i>
  int  <b>parity</b> <i>gather parity information</i>
)
</pre>
<dd> Counts minterms and computes reference counts of each
  node in the BDD . The minterm count is separately computed for the
  node and its complement. This is to avoid cancellation
  errors. Returns a pointer to the data structure holding the
  information gathered if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddUnderApprox">cuddUnderApprox</a>
<a href="#gatherInfoAux">gatherInfoAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="gcd"></A>
static int <I></I>
<B>gcd</B>(
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Returns the gcd of two integers. Uses the binary GCD
  algorithm described in Cormen, Leiserson, and Rivest.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getCube"></A>
static DdNode * <I></I>
<B>getCube</B>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int  <b>cost</b> <i></i>
)
</pre>
<dd> Build a BDD for a largest cube of f.
  Given the minimum length from the root, and the minimum
  lengths for each node (in visited), apply triangulation at each node.
  Of the two children of each node on a shortest path, at least one is
  on a shortest path. In case of ties the procedure chooses the THEN
  children.
  Returns a pointer to the cube BDD representing the path if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="getLargest"></A>
static cuddPathPair <I></I>
<B>getLargest</B>(
  DdNode * <b>root</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Finds the size of the largest cube(s) in a DD.
  This problem is translated into finding the shortest paths from a node
  when both THEN and ELSE arcs have unit lengths.
  Uses a local symbol table to store the lengths for each
  node. Only the lengths for the regular nodes are entered in the table,
  because those for the complement nodes are simply obtained by swapping
  the two lenghts.
  Returns a pair of lengths: the length of the shortest path to 1;
  and the length of the shortest path to 0. This is done so as to take
  complement arcs into account.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="getLevelKeys"></A>
static int <I></I>
<B>getLevelKeys</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>l</b> <i></i>
)
</pre>
<dd> Returns the number of nodes at one level of a unique table.
  The projection function, if isolated, is not counted.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getMatrix"></A>
static DdHalfWord ** <I></I>
<B>getMatrix</B>(
  int  <b>rows</b>, <i>number of rows</i>
  int  <b>cols</b> <i>number of columns</i>
)
</pre>
<dd> Allocates a two-dimensional matrix of ints.
  Returns the pointer to the matrix if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#freeMatrix">freeMatrix</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getMaxBinomial"></A>
static int <I></I>
<B>getMaxBinomial</B>(
  int  <b>n</b> <i></i>
)
</pre>
<dd> Computes the maximum value of (n choose k) for a given
  n.  The maximum value occurs for k = n/2 when n is even, or k =
  (n-1)/2 when n is odd.  The algorithm used in this procedure avoids
  intermediate overflow problems.  It is based on the identity
  <pre>
    binomial(n,k) = n/k * binomial(n-1,k-1).
  </pre>
  Returns the computed value if successful; -1 if out of range.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="getPath"></A>
static DdNode * <I></I>
<B>getPath</B>(
  DdManager * <b>manager</b>, <i></i>
  st_table * <b>visited</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  int * <b>weight</b>, <i></i>
  int  <b>cost</b> <i></i>
)
</pre>
<dd> Build a BDD for a shortest path of f.
  Given the minimum length from the root, and the minimum
  lengths for each node (in visited), apply triangulation at each node.
  Of the two children of each node on a shortest path, at least one is
  on a shortest path. In case of ties the procedure chooses the THEN
  children.
  Returns a pointer to the cube BDD representing the path if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="getShortest"></A>
static cuddPathPair <I></I>
<B>getShortest</B>(
  DdNode * <b>root</b>, <i></i>
  int * <b>cost</b>, <i></i>
  int * <b>support</b>, <i></i>
  st_table * <b>visited</b> <i></i>
)
</pre>
<dd> Finds the length of the shortest path(s) in a DD.
  Uses a local symbol table to store the lengths for each
  node. Only the lengths for the regular nodes are entered in the table,
  because those for the complement nodes are simply obtained by swapping
  the two lenghts.
  Returns a pair of lengths: the length of the shortest path to 1;
  and the length of the shortest path to 0. This is done so as to take
  complement arcs into account.
<p>

<dd> <b>Side Effects</b> Accumulates the support of the DD in support.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSat.c"TARGET="ABSTRACT"><CODE>cuddSat.c</CODE></A>

<dt><pre>
<A NAME="hashDelete"></A>
static void <I></I>
<B>hashDelete</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  DdQueueItem * <b>item</b> <i></i>
)
</pre>
<dd> Removes an item from the hash table of a level queue.
  Nothing is done if the item is not in the table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueDequeue">cuddLevelQueueDequeue</a>
<a href="#hashInsert">hashInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="hashInsert"></A>
static int <I></I>
<B>hashInsert</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  DdQueueItem * <b>item</b> <i></i>
)
</pre>
<dd> Inserts an item in the hash table of a level queue. Returns
  1 if successful; 0 otherwise. No check is performed to see if an item with
  the same key is already in the hash table.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="hashLookup"></A>
static DdQueueItem * <I></I>
<B>hashLookup</B>(
  DdLevelQueue * <b>queue</b>, <i></i>
  void * <b>key</b> <i></i>
)
</pre>
<dd> Looks up a key in the hash table of a level queue. Returns
  a pointer to the item with the given key if the key is found; NULL
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddLevelQueueEnqueue">cuddLevelQueueEnqueue</a>
<a href="#hashInsert">hashInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="hashResize"></A>
static int <I></I>
<B>hashResize</B>(
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Resizes the hash table of a level queue. Returns 1 if
  successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#hashInsert">hashInsert</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME="impliedp"></A>
static int <I></I>
<B>impliedp</B>(
  DdHalfWord  <b>var1</b>, <i></i>
  short  <b>phase1</b>, <i></i>
  DdHalfWord  <b>var2</b>, <i></i>
  short  <b>phase2</b>, <i></i>
  BitVector * <b>olv</b>, <i></i>
  BitVector * <b>olp</b> <i></i>
)
</pre>
<dd> Returns true iff either literal of a clause is in a set
  of literals.  The first four arguments specify the clause.  The
  remaining two arguments specify the literal set.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="initSymmInfo"></A>
static DdHalfWord * <I></I>
<B>initSymmInfo</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Translates the symmetry information stored in the next
  field of each subtable from level to indices. This procedure is called
  immediately after symmetric sifting, so that the next fields are correct.
  By translating this informaton in terms of indices, we make it independent
  of subsequent reorderings. The format used is that of the next fields:
  a circular list where each variable points to the next variable in the
  same symmetry group. Only the entries between lower and upper are
  considered.  The procedure returns a pointer to an array
  holding the symmetry information if successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#checkSymmInfo">checkSymmInfo</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="largest"></A>
static int <I></I>
<B>largest</B>(
   <b></b> <i></i>
)
</pre>
<dd> Finds the largest DD in the population. If an order is
  repeated, it avoids choosing the copy that is in the computed table
  (it has repeat[i
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="make_random"></A>
static int <I></I>
<B>make_random</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b> <i></i>
)
</pre>
<dd> Generates the random sequences for the initial population.
  The sequences are permutations of the indices between lower and
  upper in the current order.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="mintermsFromUniverse"></A>
static DdNode * <I></I>
<B>mintermsFromUniverse</B>(
  DdManager * <b>manager</b>, <i></i>
  DdNode ** <b>vars</b>, <i></i>
  int  <b>numVars</b>, <i></i>
  double  <b>n</b>, <i></i>
  int  <b>index</b> <i></i>
)
</pre>
<dd> Recursive procedure to extract n mintems from constant 1.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="oneliteralp"></A>
static int <I></I>
<B>oneliteralp</B>(
  DdHalfWord  <b>var</b> <i></i>
)
</pre>
<dd> Returns true iff the argument is a one-literal clause.
  A one-litaral clause has the constant FALSE as second literal.
  Since the constant TRUE is never used, it is sufficient to test for
  a constant.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="pushDown"></A>
static void <I></I>
<B>pushDown</B>(
  DdHalfWord * <b>order</b>, <i></i>
  int  <b>j</b>, <i></i>
  int  <b>level</b> <i></i>
)
</pre>
<dd> Pushes a variable in the order down to position "level."
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="rand_int"></A>
static int <I></I>
<B>rand_int</B>(
  int  <b>a</b> <i></i>
)
</pre>
<dd> Generates a random number between 0 and the integer a.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="random_generator"></A>
static double <I></I>
<B>random_generator</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns a double precision value between 0.0 and 1.0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="restoreOrder"></A>
static int <I></I>
<B>restoreOrder</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>array</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Restores the variable order in array by a series of sifts up.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="roulette"></A>
static int <I></I>
<B>roulette</B>(
  int * <b>p1</b>, <i></i>
  int * <b>p2</b> <i></i>
)
</pre>
<dd> Selects two distinct parents with the roulette wheel method.
<p>

<dd> <b>Side Effects</b> The indices of the selected parents are returned as side
  effects.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="selectMintermsFromUniverse"></A>
static DdNode * <I></I>
<B>selectMintermsFromUniverse</B>(
  DdManager * <b>manager</b>, <i></i>
  int * <b>varSeen</b>, <i></i>
  double  <b>n</b> <i></i>
)
</pre>
<dd> This function prepares an array of variables which have not been
  encountered so far when traversing the procedure cuddSplitSetRecur. This
  array is then used to extract the required number of minterms from a constant
  1. The algorithm guarantees that the size of BDD will be utmost log(n).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSplit.c"TARGET="ABSTRACT"><CODE>cuddSplit.c</CODE></A>

<dt><pre>
<A NAME="sentinelp"></A>
static int <I></I>
<B>sentinelp</B>(
  DdHalfWord  <b>var1</b>, <i></i>
  DdHalfWord  <b>var2</b> <i></i>
)
</pre>
<dd> Returns true iff the argument is the sentinel clause.
  A sentinel clause has both variables equal to 0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="separateCube"></A>
static DdNode * <I></I>
<B>separateCube</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  CUDD_VALUE_TYPE * <b>distance</b> <i></i>
)
</pre>
<dd> Separates cube from distance.  Returns the cube if
  successful; NULL otherwise.
<p>

<dd> <b>Side Effects</b> The distance is returned as a side effect.
<p>

<dd> <b>See Also</b> <code><a href="#cuddBddClosestCube">cuddBddClosestCube</a>
<a href="#createResult">createResult</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddPriority.c"TARGET="ABSTRACT"><CODE>cuddPriority.c</CODE></A>

<dt><pre>
<A NAME="siftBackwardProb"></A>
static int <I></I>
<B>siftBackwardProb</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> Otherwise, "tosses a coin" to decide whether to keep
  the current configuration or return the DD to the original
  one. Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="sift_up"></A>
static int <I></I>
<B>sift_up</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>x_low</b> <i></i>
)
</pre>
<dd> Takes a variable from position x and sifts it up to
  position x_low;  x_low should be less than x. Returns 1 if successful;
  0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddGenetic.c"TARGET="ABSTRACT"><CODE>cuddGenetic.c</CODE></A>

<dt><pre>
<A NAME="stPathTableDdFree"></A>
static enum st_retval <I></I>
<B>stPathTableDdFree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> None
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddSubsetSP.c"TARGET="ABSTRACT"><CODE>cuddSubsetSP.c</CODE></A>

<dt><pre>
<A NAME="st_zdd_count_dbl_free"></A>
static enum st_retval <I></I>
<B>st_zdd_count_dbl_free</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory associated with the computed table of
  Cudd_zddCountDouble.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="st_zdd_countfree"></A>
static enum st_retval <I></I>
<B>st_zdd_countfree</B>(
  char * <b>key</b>, <i></i>
  char * <b>value</b>, <i></i>
  char * <b>arg</b> <i></i>
)
</pre>
<dd> Frees the memory associated with the computed table of
  Cudd_zddCount.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddCount.c"TARGET="ABSTRACT"><CODE>cuddZddCount.c</CODE></A>

<dt><pre>
<A NAME="stopping_criterion"></A>
static int <I></I>
<B>stopping_criterion</B>(
  int  <b>c1</b>, <i></i>
  int  <b>c2</b>, <i></i>
  int  <b>c3</b>, <i></i>
  int  <b>c4</b>, <i></i>
  double  <b>temp</b> <i></i>
)
</pre>
<dd> If temperature is STOP_TEMP or there is no improvement
  then terminates. Returns 1 if the termination criterion is met; 0
  otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddAnneal.c"TARGET="ABSTRACT"><CODE>cuddAnneal.c</CODE></A>

<dt><pre>
<A NAME="tlcInfoAlloc"></A>
static DdTlcInfo * <I></I>
<B>tlcInfoAlloc</B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns a pointer to a DdTlcInfo Structure if successful;
  NULL otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_tlcInfoFree">Cudd_tlcInfoFree</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddEssent.c"TARGET="ABSTRACT"><CODE>cuddEssent.c</CODE></A>

<dt><pre>
<A NAME="updateEntry"></A>
static int <I></I>
<B>updateEntry</B>(
  DdManager * <b>table</b>, <i></i>
  DdHalfWord * <b>order</b>, <i></i>
  int  <b>level</b>, <i></i>
  int  <b>cost</b>, <i></i>
  DdHalfWord ** <b>orders</b>, <i></i>
  int * <b>costs</b>, <i></i>
  int  <b>subsets</b>, <i></i>
  char * <b>mask</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Updates entry for a subset. Finds the subset, if it exists.
  If the new order for the subset has lower cost, or if the subset did not
  exist, it stores the new order and cost. Returns the number of subsets
  currently in the table.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="updateParity"></A>
static void <I></I>
<B>updateParity</B>(
  DdNode * <b>node</b>, <i>function to analyze</i>
  ApproxInfo * <b>info</b>, <i>info on BDD</i>
  int  <b>newparity</b> <i>new parity for node</i>
)
</pre>
<dd> Recursively update the parity of the paths reaching a node.
  Assumes that node is regular and propagates the invariant.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#gatherInfoAux">gatherInfoAux</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="updateRefs"></A>
static int <I></I>
<B>updateRefs</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  DdNode * <b>skip</b>, <i></i>
  ApproxInfo * <b>info</b>, <i></i>
  DdLevelQueue * <b>queue</b> <i></i>
)
</pre>
<dd> Update function reference counts to account for replacement.
  Returns the number of nodes saved if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>UAmarkNodes
RAmarkNodes
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddApprox.c"TARGET="ABSTRACT"><CODE>cuddApprox.c</CODE></A>

<dt><pre>
<A NAME="updateUB"></A>
static int <I></I>
<B>updateUB</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>oldBound</b>, <i></i>
  DdHalfWord * <b>bestOrder</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Updates the upper bound and saves the best order seen so far.
  Returns the current value of the upper bound.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddExact.c"TARGET="ABSTRACT"><CODE>cuddExact.c</CODE></A>

<dt><pre>
<A NAME="zddCountInternalMtrNodes"></A>
static int <I></I>
<B>zddCountInternalMtrNodes</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Counts the number of internal nodes of the group tree.
  Returns the count.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddFindNodeHiLo"></A>
static void <I></I>
<B>zddFindNodeHiLo</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int * <b>lower</b>, <i></i>
  int * <b>upper</b> <i></i>
)
</pre>
<dd> Finds the lower and upper bounds of the group represented
  by treenode.  The high and low fields of treenode are indices.  From
  those we need to derive the current positions, and find maximum and
  minimum.
<p>

<dd> <b>Side Effects</b> The bounds are returned as side effects.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddFixTree"></A>
static void <I></I>
<B>zddFixTree</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b> <i></i>
)
</pre>
<dd> Fixes the ZDD variable group tree after a
  shuffle. Assumes that the order of the variables in a terminal node
  has not been changed.
<p>

<dd> <b>Side Effects</b> Changes the ZDD variable group tree.
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddGroupMoveBackward"></A>
static int <I></I>
<B>zddGroupMoveBackward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap two groups.  Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupMove"></A>
static int <I></I>
<B>zddGroupMove</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups and records the move. Returns the
  number of keys in the DD table in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingAux"></A>
static int <I></I>
<B>zddGroupSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  int  <b>xHigh</b> <i></i>
)
</pre>
<dd> Sifts one variable up and down until it has taken all
  positions. Checks for aggregation. There may be at most two sweeps,
  even if the group grows.  Assumes that x is either an isolated
  variable, or it is the bottom of a group. All groups may not have
  been found. The variable being moved is returned to the best position
  seen during sifting.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingBackward"></A>
static int <I></I>
<B>zddGroupSiftingBackward</B>(
  DdManager * <b>table</b>, <i></i>
  Move * <b>moves</b>, <i></i>
  int  <b>size</b> <i></i>
)
</pre>
<dd> Determines the best position for a variables and returns
  it there.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingDown"></A>
static int <I></I>
<B>zddGroupSiftingDown</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xHigh</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts down a variable until it reaches position xHigh.
  Assumes that x is the bottom of a group (or a singleton).  Records
  all the moves.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSiftingUp"></A>
static int <I></I>
<B>zddGroupSiftingUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>y</b>, <i></i>
  int  <b>xLow</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Sifts up a variable until either it reaches position
  xLow or the size of the DD heap increases too much. Assumes that y is
  the top of a group (or a singleton).  Checks y for aggregation to the
  adjacent variables. Records all the moves that are appended to the
  list of moves received as input and returned as a side effect.
  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddGroupSifting"></A>
static int <I></I>
<B>zddGroupSifting</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>lower</b>, <i></i>
  int  <b>upper</b> <i></i>
)
</pre>
<dd> Sifts from treenode->low to treenode->high. If
  croupcheck == CUDD_GROUP_CHECK7, it checks for group creation at the
  end of the initial sifting. If a group is created, it is then sifted
  again. After sifting one variable, the group that contains it is
  dissolved.  Returns 1 in case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddMergeGroups"></A>
static void <I></I>
<B>zddMergeGroups</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  int  <b>low</b>, <i></i>
  int  <b>high</b> <i></i>
)
</pre>
<dd> Creates a single group from low to high and adjusts the
  idex field of the tree node.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddPortFromBddStep"></A>
static DdNode * <I></I>
<B>zddPortFromBddStep</B>(
  DdManager * <b>dd</b>, <i></i>
  DdNode * <b>B</b>, <i></i>
  int  <b>expected</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPortFromBdd.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddPort.c"TARGET="ABSTRACT"><CODE>cuddZddPort.c</CODE></A>

<dt><pre>
<A NAME="zddPortToBddStep"></A>
static DdNode * <I></I>
<B>zddPortToBddStep</B>(
  DdManager * <b>dd</b>, <i>manager</i>
  DdNode * <b>f</b>, <i>ZDD to be converted</i>
  int  <b>depth</b> <i>recursion depth</i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPortToBdd.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddPort.c"TARGET="ABSTRACT"><CODE>cuddZddPort.c</CODE></A>

<dt><pre>
<A NAME="zddPrintCoverAux"></A>
static void <I></I>
<B>zddPrintCoverAux</B>(
  DdManager * <b>zdd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int  <b>level</b>, <i>depth in the recursion</i>
  int * <b>list</b> <i>current recursion path</i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPrintCover.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="zddReorderChildren"></A>
static int <I></I>
<B>zddReorderChildren</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Reorders the children of a group tree node according to
  the options. After reordering puts all the variables in the group
  and/or its descendents in a single group. This allows hierarchical
  reordering.  If the variables in the group do not exist yet, simply
  does nothing. Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddReorderPostprocess"></A>
static int <I></I>
<B>zddReorderPostprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Shrinks almost empty subtables at the end of reordering to
  guarantee that they have a reasonable load factor. However, if there many
  nodes are being reclaimed, then no resizing occurs. Returns 1 in case of
  success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddReorderPreprocess"></A>
static void <I></I>
<B>zddReorderPreprocess</B>(
  DdManager * <b>table</b> <i></i>
)
</pre>
<dd> Prepares the ZDD heap for dynamic reordering. Does
  garbage collection, to guarantee that there are no dead nodes;
  and clears the cache, which is invalidated by dynamic reordering.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddShuffle"></A>
static int <I></I>
<B>zddShuffle</B>(
  DdManager * <b>table</b>, <i></i>
  int * <b>permutation</b> <i></i>
)
</pre>
<dd> Reorders ZDD variables according to a given permutation.
  The i-th permutation array contains the index of the variable that
  should be brought to the i-th level. zddShuffle assumes that no
  dead nodes are present.  The reordering is achieved by a series of
  upward sifts.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddSiftUp"></A>
static int <I></I>
<B>zddSiftUp</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>xLow</b> <i></i>
)
</pre>
<dd> Takes a ZDD variable from position x and sifts it up to
  position xLow;  xLow should be less than or equal to x.
  Returns 1 if successful; 0 otherwise
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddSwapAny"></A>
static Move * <I></I>
<B>zddSwapAny</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Swaps any two variables. Returns the set of moves.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddReord.c"TARGET="ABSTRACT"><CODE>cuddZddReord.c</CODE></A>

<dt><pre>
<A NAME="zddTreeSiftingAux"></A>
static int <I></I>
<B>zddTreeSiftingAux</B>(
  DdManager * <b>table</b>, <i></i>
  MtrNode * <b>treenode</b>, <i></i>
  Cudd_ReorderingType  <b>method</b> <i></i>
)
</pre>
<dd> Recursively visits the group tree and reorders each
  group in postorder fashion.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddUniqueCompareGroup"></A>
static int <I></I>
<B>zddUniqueCompareGroup</B>(
  int * <b>ptrX</b>, <i></i>
  int * <b>ptrY</b> <i></i>
)
</pre>
<dd> Comparison function used by qsort to order the variables
  according to the number of keys in the subtables.  Returns the
  difference in number of keys between the two variables being
  compared.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddGroup.c"TARGET="ABSTRACT"><CODE>cuddZddGroup.c</CODE></A>

<dt><pre>
<A NAME="zddVarToConst"></A>
static void <I></I>
<B>zddVarToConst</B>(
  DdNode * <b>f</b>, <i></i>
  DdNode ** <b>gp</b>, <i></i>
  DdNode ** <b>hp</b>, <i></i>
  DdNode * <b>base</b>, <i></i>
  DdNode * <b>empty</b> <i></i>
)
</pre>
<dd> Replaces variables with constants if possible (part of
  canonical form).
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="zdd_group_move_backward"></A>
static int <I></I>
<B>zdd_group_move_backward</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b> <i></i>
)
</pre>
<dd> Undoes the swap of two groups. x is assumed to be the
  bottom variable of the first group. y is assumed to be the top
  variable of the second group.  Returns 1 if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="zdd_group_move"></A>
static int <I></I>
<B>zdd_group_move</B>(
  DdManager * <b>table</b>, <i></i>
  int  <b>x</b>, <i></i>
  int  <b>y</b>, <i></i>
  Move ** <b>moves</b> <i></i>
)
</pre>
<dd> Swaps two groups. x is assumed to be the bottom variable
  of the first group. y is assumed to be the top variable of the second
  group.  Updates the list of moves. Returns the number of keys in the
  table if successful; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSymm.c"TARGET="ABSTRACT"><CODE>cuddZddSymm.c</CODE></A>

<dt><pre>
<A NAME="zdd_print_minterm_aux"></A>
static void <I></I>
<B>zdd_print_minterm_aux</B>(
  DdManager * <b>zdd</b>, <i>manager</i>
  DdNode * <b>node</b>, <i>current node</i>
  int  <b>level</b>, <i>depth in the recursion</i>
  int * <b>list</b> <i>current recursion path</i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddPrintMinterm.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME="zdd_subset0_aux"></A>
static DdNode * <I></I>
<B>zdd_subset0_aux</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddSubset0.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="zdd_subset1_aux"></A>
static DdNode * <I></I>
<B>zdd_subset1_aux</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>P</b>, <i></i>
  DdNode * <b>zvar</b> <i></i>
)
</pre>
<dd> Performs the recursive step of Cudd_zddSubset1.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddSetop.c"TARGET="ABSTRACT"><CODE>cuddZddSetop.c</CODE></A>

<dt><pre>
<A NAME="zp2"></A>
static int <I></I>
<B>zp2</B>(
  DdManager * <b>zdd</b>, <i></i>
  DdNode * <b>f</b>, <i></i>
  st_table * <b>t</b> <i></i>
)
</pre>
<dd> Performs the recursive step of cuddZddP. Returns 1 in
  case of success; 0 otherwise.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddZddUtil.c"TARGET="ABSTRACT"><CODE>cuddZddUtil.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Adds node to the head of the free list.  Does not
  deallocate memory chunks that become free.  This function is also
  used by the dynamic reordering functions.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddAllocNode">cuddAllocNode</a>
<a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
<a href="#cuddDeallocMove">cuddDeallocMove</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Adds node to the head of the free list.  Does not
  deallocate memory chunks that become free.  This function is also
  used by the dynamic reordering functions.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#cuddDeallocNode">cuddDeallocNode</a>
<a href="#cuddDynamicAllocNode">cuddDynamicAllocNode</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Clears the 4 least significant bits of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Complements a DD if condition c is true; c should be
  either 0 or 1, because it is used directly (for efficiency). If in
  doubt on the values c may take, use "(c) ? Cudd_Not(node) : node".
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Not">Cudd_Not</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Complements a DD by flipping the complement attribute of
  the pointer (the least significant bit).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_NotCond">Cudd_NotCond</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes hash function for keys of three operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddLCHash2">ddLCHash2</a>
<a href="#ddLCHash">ddLCHash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes hash function for keys of two operands.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#ddLCHash3">ddLCHash3</a>
<a href="#ddLCHash">ddLCHash</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLCache.c"TARGET="ABSTRACT"><CODE>cuddLCache.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the absolute value of a number.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the maximum of two numbers.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddMin">ddMin</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Computes the minimum of two numbers.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddMax">ddMax</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Decreases the reference count of node. It is primarily
  used in recursive procedures to decrease the ref count of a result
  node before returning it. This accomplishes the goal of removing the
  protection applied by a previous cuddRef. This being a macro, it is
  faster than Cudd_Deref, but it cannot be used in constructs like
  cuddDeref(a = b()).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Deref">Cudd_Deref</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Enforces DD_MINUS_INF_VAL <= x <= DD_PLUS_INF_VAL.
  Furthermore, if x <= DD_MINUS_INF_VAL/2, x is set to
  DD_MINUS_INF_VAL. Similarly, if DD_PLUS_INF_VAL/2 <= x, x is set to
  DD_PLUS_INF_VAL.  Normally this macro is a NOOP. However, if
  HAVE_IEEE_754 is not defined, it makes sure that a value does not
  get larger than infinity in absolute value, and once it gets to
  infinity, stays there.  If the value overflows before this macro is
  applied, no recovery is possible.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Extract the least significant digit of a double digit. Used
  in the manipulation of arbitrary precision integers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>DD_MSDIGIT
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Extract the most significant digit of a double digit. Used
  in the manipulation of arbitrary precision integers.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code>DD_LSDIGIT
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Finds the current position of ZDD variable index in the
  order.  This macro duplicates the functionality of Cudd_ReadPermZdd,
  but it does not check for out-of-bounds indices and it is more
  efficient.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPermZdd">Cudd_ReadPermZdd</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Finds the current position of variable index in the
  order.  This macro duplicates the functionality of Cudd_ReadPerm,
  but it does not check for out-of-bounds indices and it is more
  efficient.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the cache for functions with two
  operands.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddHash">ddHash</a>
<a href="#ddCHash">ddCHash</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the cache.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddHash">ddHash</a>
<a href="#ddCHash2">ddCHash2</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the table of a level queue.
<p>

<dd> <b>Side Effects</b> None
<p>

<dd> <b>See Also</b> <code><a href="#hashInsert">hashInsert</a>
<a href="#hashLookup">hashLookup</a>
<a href="#hashDelete">hashDelete</a>
</code>

<DD> <B>Defined in </B> <A HREF="cuddAllFile.html#cuddLevelQ.c"TARGET="ABSTRACT"><CODE>cuddLevelQ.c</CODE></A>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Hash function for the unique table.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#ddCHash">ddCHash</a>
<a href="#ddCHash2">ddCHash2</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Increases the reference count of a node, if it is not
  saturated. This being a macro, it is faster than Cudd_Ref, but it
  cannot be used in constructs like cuddRef(a = b()).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Ref">Cudd_Ref</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the cubes of a decision diagram f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> int *cube;
  <li> CUDD_VALUE_TYPE value;
  </ul>
  Cudd_ForeachCube allocates and frees the generator. Therefore the
  application should not try to do that. Also, the cube is freed at the
  end of Cudd_ForeachCube and hence is not available outside of the loop.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure
  that dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur. Alternatively, it is sufficient to
  disable dynamic reordering. It is a mistake to dispose of a diagram
  on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachNode">Cudd_ForeachNode</a>
<a href="#Cudd_FirstCube">Cudd_FirstCube</a>
<a href="#Cudd_NextCube">Cudd_NextCube</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the nodes of a decision diagram f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> DdNode *node;
  </ul>
  The nodes are returned in a seemingly random order.
  Cudd_ForeachNode allocates and frees the generator. Therefore the
  application should not try to do that.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators. It is the user's responsibility to make sure
  that dynamic reordering does not occur. As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur. Alternatively, it is sufficient to
  disable dynamic reordering. It is a mistake to dispose of a diagram
  on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_FirstNode">Cudd_FirstNode</a>
<a href="#Cudd_NextNode">Cudd_NextNode</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the paths of a ZDD f.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *f;
  <li> DdGen *gen;
  <li> int *path;
  </ul>
  Cudd_zddForeachPath allocates and frees the generator. Therefore the
  application should not try to do that. Also, the path is freed at the
  end of Cudd_zddForeachPath and hence is not available outside of the loop.<p>
  CAUTION: It is assumed that dynamic reordering will not occur while
  there are open generators.  It is the user's responsibility to make sure
  that dynamic reordering does not occur.  As long as new nodes are not created
  during generation, and dynamic reordering is not called explicitly,
  dynamic reordering will not occur.  Alternatively, it is sufficient to
  disable dynamic reordering.  It is a mistake to dispose of a diagram
  on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_zddFirstPath">Cudd_zddFirstPath</a>
<a href="#Cudd_zddNextPath">Cudd_zddNextPath</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
<a href="#Cudd_AutodynDisable">Cudd_AutodynDisable</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Iterates over the primes of a Boolean function producing
  a prime and irredundant cover.
  <ul>
  <li> DdManager *manager;
  <li> DdNode *l;
  <li> DdNode *u;
  <li> DdGen *gen;
  <li> int *cube;
  </ul>
  The Boolean function is described by an upper bound and a lower bound.  If
  the function is completely specified, the two bounds coincide.
  Cudd_ForeachPrime allocates and frees the generator.  Therefore the
  application should not try to do that.  Also, the cube is freed at the
  end of Cudd_ForeachPrime and hence is not available outside of the loop.<p>
  CAUTION: It is a mistake to change a diagram on which generation is ongoing.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ForeachCube">Cudd_ForeachCube</a>
<a href="#Cudd_FirstPrime">Cudd_FirstPrime</a>
<a href="#Cudd_NextPrime">Cudd_NextPrime</a>
<a href="#Cudd_GenFree">Cudd_GenFree</a>
<a href="#Cudd_IsGenEmpty">Cudd_IsGenEmpty</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Outputs a line of stats if DD_COUNT and DD_STATS are
  defined. Increments the number of recursive calls if DD_COUNT is
  defined.
<p>

<dd> <b>Side Effects</b> None
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if a pointer is complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Regular">Cudd_Regular</a>
<a href="#Cudd_Complement">Cudd_Complement</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if the absolute value of the difference of the two
  arguments x and y is less than e.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if the node is a constant node (rather than an
  internal node). All constant nodes have the same index
  (CUDD_CONST_INDEX). The pointer passed to Cudd_IsConstant may be either
  regular or complemented.
<p>

<dd> <b>Side Effects</b> none
<p>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns 1 if the node is a constant node (rather than an
  internal node). All constant nodes have the same index
  (CUDD_CONST_INDEX). The pointer passed to cuddIsConstant must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_IsConstant">Cudd_IsConstant</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the arithmetic 0 constant node. This is different
  from the logical zero. The latter is obtained by
  Cudd_Not(DD_ONE(dd)).
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
<a href="#Cudd_Not">Cudd_Not</a>
DD_PLUS_INFINITY
DD_MINUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the complemented version of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Regular">Cudd_Regular</a>
<a href="#Cudd_IsComplement">Cudd_IsComplement</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the constant 1 node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ZERO
DD_PLUS_INFINITY
DD_MINUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the current position in the order of variable
  index. This macro is obsolete and is kept for compatibility. New
  applications should use Cudd_ReadPerm instead.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_ReadPerm">Cudd_ReadPerm</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the else child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
  The pointer passed to cuddE must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_E">Cudd_E</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the else child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_T">Cudd_T</a>
<a href="#Cudd_V">Cudd_V</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the minus infinity constant node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
DD_ZERO
DD_PLUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the plus infinity constant node.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code>DD_ONE
DD_ZERO
DD_MINUS_INFINITY
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the regular version of a pointer.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_Complement">Cudd_Complement</a>
<a href="#Cudd_IsComplement">Cudd_IsComplement</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the then child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
  The pointer passed to cuddT must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_T">Cudd_T</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the then child of an internal node. If
  <code>node</code> is a constant node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_E">Cudd_E</a>
<a href="#Cudd_V">Cudd_V</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the value of a constant node. If
  <code>node</code> is an internal node, the result is unpredictable.
  The pointer passed to cuddV must be regular.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_V">Cudd_V</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Returns the value of a constant node. If
  <code>node</code> is an internal node, the result is unpredictable.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#Cudd_T">Cudd_T</a>
<a href="#Cudd_E">Cudd_E</a>
</code>

<DD> <B>Defined in </B> <CODE>cudd.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Saturating decrement operator.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#cuddSatInc">cuddSatInc</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>

<dt><pre>
<A NAME=""></A>
 <I></I>
<B></B>(
   <b></b> <i></i>
)
</pre>
<dd> Saturating increment operator.
<p>

<dd> <b>Side Effects</b> none
<p>

<dd> <b>See Also</b> <code><a href="#cuddSatDec">cuddSatDec</a>
</code>

<DD> <B>Defined in </B> <CODE>cuddInt.h</CODE>


</DL>
<HR>
Last updated on 20090220 23h06
</BODY></HTML>
